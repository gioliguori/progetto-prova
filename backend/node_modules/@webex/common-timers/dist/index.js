"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.Timer = void 0;
exports.safeSetInterval = safeSetInterval;
exports.safeSetTimeout = safeSetTimeout;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Wrapper around setTimout which (in node) unrefs the returned timer to avoid
 * wedging the process open unexpectedly.
 * @param {Mixed} args
 * @protected
 * @returns {NodeJS.Timeout|Number}
 */
function safeSetTimeout() {
  var timer = setTimeout.apply(void 0, arguments);
  if (timer.unref) {
    timer.unref();
  }
  return timer;
}

/**
 * Wrapper around setInterval which (in node) unrefs the returned timer to avoid
 * wedging the process open unexpectedly.
 * @param {Mixed} args
 * @protected
 * @returns {NodeJS.Timeout|Number}
 */
function safeSetInterval() {
  var interval = setInterval.apply(void 0, arguments);
  if (interval.unref) {
    interval.unref();
  }
  return interval;
}

/**
 * Create a restartable timer
 */
var Timer = exports.Timer = /*#__PURE__*/function () {
  /**
   * Construct timer
   * @param {Function} callback Function called when the timer expired
   * @param {number} timeout duration of the timeout in milliseconds
   */
  function Timer(callback, timeout) {
    var _this = this;
    (0, _classCallCheck2.default)(this, Timer);
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "timeout", void 0);
    (0, _defineProperty2.default)(this, "callback", void 0);
    (0, _defineProperty2.default)(this, "currentTimer", void 0);
    this.state = 'init';
    this.timeout = timeout;
    this.callback = function () {
      _this.state = 'done';
      callback();
    };
  }

  /**
   * Start timer
   * @returns {void}
   */
  (0, _createClass2.default)(Timer, [{
    key: "start",
    value: function start() {
      if (this.state !== 'init') {
        throw new Error("Can't start the timer when it's in ".concat(this.state, " state"));
      }
      this.startTimer();
      this.state = 'running';
    }

    /**
     * Clear the current timer and start a new one
     * @returns {void}
     */
  }, {
    key: "reset",
    value: function reset() {
      if (this.state !== 'running') {
        throw new Error("Can't reset the timer when it's in ".concat(this.state, " state"));
      }
      this.clearTimer();
      this.startTimer();
    }

    /**
     * Clear the timer
     * @returns {void}
     */
  }, {
    key: "cancel",
    value: function cancel() {
      if (this.state !== 'running') {
        throw new Error("Can't cancel the timer when it's in ".concat(this.state, " state"));
      }
      this.clearTimer();
      this.state = 'done';
    }

    /**
     * Create the actual timer
     * @private
     * @returns {undefined}
     */
  }, {
    key: "startTimer",
    value: function startTimer() {
      this.currentTimer = safeSetTimeout(this.callback, this.timeout);
    }

    /**
     * Clear the actual timer
     * @private
     * @returns {undefined}
     */
  }, {
    key: "clearTimer",
    value: function clearTimer() {
      clearTimeout(this.currentTimer);
    }
  }]);
  return Timer;
}();
//# sourceMappingURL=index.js.map
