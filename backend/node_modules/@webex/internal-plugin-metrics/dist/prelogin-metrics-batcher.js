"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _lodash = require("lodash");
var _batcher = _interopRequireDefault(require("./batcher"));
var _callDiagnosticMetrics = require("./call-diagnostic/call-diagnostic-metrics.util");
var _utils = require("./utils");
var PRE_LOGIN_METRICS_IDENTIFIER = 'Pre Login Metrics -->';
var PreLoginMetricsBatcher = _batcher.default.extend({
  namespace: 'Metrics',
  preLoginId: undefined,
  /**
   * Save the pre-login ID.
   * @param {string} preLoginId The pre-login ID to be saved.
   * @returns {void}
   */
  savePreLoginId: function savePreLoginId(preLoginId) {
    this.preLoginId = preLoginId;
  },
  /**
   * Prepare item
   * @param {any} item
   * @returns {Promise<any>}
   */
  prepareItem: function prepareItem(item) {
    return _promise.default.resolve((0, _callDiagnosticMetrics.prepareDiagnosticMetricItem)(this.webex, item));
  },
  /**
   * Prepare request, add time sensitive date etc.
   * @param {any[]} queue
   * @returns {Promise<any[]>}
   */
  prepareRequest: function prepareRequest(queue) {
    // Add sent timestamp
    queue.forEach(function (item) {
      item.eventPayload.originTime = item.eventPayload.originTime || {};
      item.eventPayload.originTime.sent = new Date().toISOString();
    });
    return _promise.default.resolve(queue);
  },
  /**
   *
   * @param {any} payload
   * @returns {Promise<any>}
   */
  submitHttpRequest: function submitHttpRequest(payload) {
    var _this = this;
    var batchId = (0, _lodash.uniqueId)('prelogin-batch-');
    if (this.preLoginId === undefined) {
      this.webex.logger.error(PRE_LOGIN_METRICS_IDENTIFIER, "PreLoginMetricsBatcher: @submitHttpRequest#".concat(batchId, ". PreLoginId is not set."));
      return _promise.default.reject(new Error('PreLoginId is not set.'));
    }
    return this.webex.request({
      method: 'POST',
      service: 'metrics',
      resource: 'clientmetrics-prelogin',
      headers: {
        authorization: false,
        'x-prelogin-userid': this.preLoginId
      },
      body: {
        metrics: payload
      },
      waitForServiceTimeout: this.webex.config.metrics.waitForServiceTimeout
    }).then(function (res) {
      _this.webex.logger.log(PRE_LOGIN_METRICS_IDENTIFIER, "PreLoginMetricsBatcher: @submitHttpRequest#".concat(batchId, ". Request successful."));
      return res;
    }).catch(function (err) {
      _this.webex.logger.error(PRE_LOGIN_METRICS_IDENTIFIER, "PreLoginMetricsBatcher: @submitHttpRequest#".concat(batchId, ". Request failed:"), "error: ".concat((0, _utils.generateCommonErrorMetadata)(err)));
      return _promise.default.reject(err);
    });
  }
});
var _default = exports.default = PreLoginMetricsBatcher;
//# sourceMappingURL=prelogin-metrics-batcher.js.map
