"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _webexCore = require("@webex/webex-core");
var _callDiagnosticMetrics = _interopRequireDefault(require("./call-diagnostic/call-diagnostic-metrics"));
var _callDiagnosticMetricsLatencies = _interopRequireDefault(require("./call-diagnostic/call-diagnostic-metrics-latencies"));
var _callDiagnosticMetrics2 = require("./call-diagnostic/call-diagnostic-metrics.util");
var _utils = require("./utils");
var _class;
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable class-methods-use-this */
/* eslint-disable valid-jsdoc */
// @ts-ignore
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Metrics plugin to centralize all types of metrics.
 * @class
 */
var Metrics = /*#__PURE__*/function (_WebexPlugin) {
  (0, _inherits2.default)(Metrics, _WebexPlugin);
  var _super = _createSuper(Metrics);
  /**
   * Constructor
   * @param args
   * @constructor
   * @private
   * @returns
   */
  function Metrics() {
    var _this;
    (0, _classCallCheck2.default)(this, Metrics);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));

    // @ts-ignore
    // Call Diagnostic latencies
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "callDiagnosticLatencies", void 0);
    // Helper classes to handle the different types of metrics
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "callDiagnosticMetrics", void 0);
    _this.callDiagnosticLatencies = new _callDiagnosticMetricsLatencies.default({}, {
      parent: _this.webex
    });
    _this.onReady();
    return _this;
  }

  /**
   * On Ready
   */
  (0, _createClass2.default)(Metrics, [{
    key: "onReady",
    value: function onReady() {
      var _this2 = this;
      // @ts-ignore
      this.webex.once('ready', function () {
        // @ts-ignore
        _this2.callDiagnosticMetrics = new _callDiagnosticMetrics.default({}, {
          parent: _this2.webex
        });
      });
    }

    /**
     * Used for internal purposes only
     * @param args
     */
  }, {
    key: "submitInternalEvent",
    value: function submitInternalEvent(_ref) {
      var name = _ref.name,
        payload = _ref.payload,
        options = _ref.options;
      if (name === 'internal.reset.join.latencies') {
        this.callDiagnosticLatencies.clearTimestamps();
      } else {
        this.callDiagnosticLatencies.saveTimestamp({
          key: name
        });
      }
    }

    /**
     * Behavioral event
     * @param args
     */
  }, {
    key: "submitBehavioralEvent",
    value: function submitBehavioralEvent(_ref2) {
      var name = _ref2.name,
        payload = _ref2.payload,
        options = _ref2.options;
      this.callDiagnosticLatencies.saveTimestamp({
        key: name
      });
      throw new Error('Not implemented.');
    }

    /**
     * Operational event
     * @param args
     */
  }, {
    key: "submitOperationalEvent",
    value: function submitOperationalEvent(_ref3) {
      var name = _ref3.name,
        payload = _ref3.payload,
        options = _ref3.options;
      throw new Error('Not implemented.');
    }

    /**
     * Call Analyzer: Media Quality Event
     * @param args
     */
  }, {
    key: "submitMQE",
    value: function submitMQE(_ref4) {
      var name = _ref4.name,
        payload = _ref4.payload,
        options = _ref4.options;
      this.callDiagnosticLatencies.saveTimestamp({
        key: name
      });
      this.callDiagnosticMetrics.submitMQE({
        name: name,
        payload: payload,
        options: options
      });
    }

    /**
     * Call Analyzer: Feature Usage Event
     * @param args
     */
  }, {
    key: "submitFeatureEvent",
    value: function submitFeatureEvent(_ref5) {
      var name = _ref5.name,
        payload = _ref5.payload,
        options = _ref5.options;
      throw new Error('Not implemented.');
    }

    /**
     * Call Analyzer: Client Event
     * @public
     * @param args
     */
  }, {
    key: "submitClientEvent",
    value: function submitClientEvent(_ref6) {
      var name = _ref6.name,
        payload = _ref6.payload,
        options = _ref6.options;
      if (!this.callDiagnosticLatencies || !this.callDiagnosticMetrics) {
        // @ts-ignore
        this.webex.logger.log("NewMetrics: @submitClientEvent. Attempted to submit before webex.ready. Event name: ".concat(name));
        return _promise.default.resolve();
      }
      this.callDiagnosticLatencies.saveTimestamp({
        key: name,
        options: {
          meetingId: options === null || options === void 0 ? void 0 : options.meetingId
        }
      });
      return this.callDiagnosticMetrics.submitClientEvent({
        name: name,
        payload: payload,
        options: options
      });
    }

    /**
     * Issue request to alias a user's pre-login ID with their CI UUID
     * @param {string} preLoginId
     * @returns {Object} HttpResponse object
     */
  }, {
    key: "clientMetricsAliasUser",
    value: function clientMetricsAliasUser(preLoginId) {
      var _this3 = this;
      // @ts-ignore
      return this.webex.request({
        method: 'POST',
        api: 'metrics',
        resource: 'clientmetrics',
        headers: {
          'x-prelogin-userid': preLoginId
        },
        body: {},
        qs: {
          alias: true
        }
      }).then(function (res) {
        // @ts-ignore
        _this3.webex.logger.log("NewMetrics: @clientMetricsAliasUser. Request successful.");
        return res;
      }).catch(function (err) {
        // @ts-ignore
        _this3.logger.error("NewMetrics: @clientMetricsAliasUser. Request failed:", "err: ".concat((0, _utils.generateCommonErrorMetadata)(err)));
        return _promise.default.reject(err);
      });
    }

    /**
     * Returns a promise that will resolve to fetch options for submitting a metric.
     *
     * This is to support quickly submitting metrics when the browser/tab is closing.
     * Calling submitClientEvent will not work because there some async steps that will
     * not complete before the browser is closed.  Instead, we pre-gather all the
     * information/options needed for the request(s), and then simply and quickly
     * fire the fetch(es) when beforeUnload is triggered.
     *
     * We must use fetch instead of request because fetch has a keepalive option that
     * allows the request it to outlive the page.
     *
     * Note: the timings values will be wrong, but setMetricTimingsAndFetch() will
     * properly adjust them before submitting.
     *
     * @public
     * @param {Object} arg
     * @param {String} arg.name - event name
     * @param {Object} arg.payload - event payload
     * @param {Object} arg.options - other options
     * @returns {Promise} promise that resolves to options to be used with fetch
     */
  }, {
    key: "buildClientEventFetchRequestOptions",
    value: (function () {
      var _buildClientEventFetchRequestOptions = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref7) {
        var name, payload, options;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              name = _ref7.name, payload = _ref7.payload, options = _ref7.options;
              return _context.abrupt("return", this.callDiagnosticMetrics.buildClientEventFetchRequestOptions({
                name: name,
                payload: payload,
                options: options
              }));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function buildClientEventFetchRequestOptions(_x) {
        return _buildClientEventFetchRequestOptions.apply(this, arguments);
      }
      return buildClientEventFetchRequestOptions;
    }()
    /**
     * Submits a metric from pre-built request options via the fetch API. Updates
     * the "$timings" and "originTime" values to Date.now() since the existing times
     * were set when the options were built (not submitted).
      * @param {any} options - the pre-built request options for submitting a metric
     * @returns {Promise} promise that resolves to the response object
     */
    )
  }, {
    key: "setMetricTimingsAndFetch",
    value: function setMetricTimingsAndFetch(options) {
      // @ts-ignore
      return this.webex.setTimingsAndFetch((0, _callDiagnosticMetrics2.setMetricTimings)(options));
    }

    /**
     * Returns true if the specified serviceErrorCode maps to an expected error.
     * @param {number} serviceErrorCode the service error code
     * @returns {boolean}
     */
  }, {
    key: "isServiceErrorExpected",
    value: function isServiceErrorExpected(serviceErrorCode) {
      return this.callDiagnosticMetrics.isServiceErrorExpected(serviceErrorCode);
    }
  }]);
  return Metrics;
}(_webexCore.WebexPlugin);
_class = Metrics;
// eslint-disable-next-line no-use-before-define
(0, _defineProperty2.default)(Metrics, "instance", void 0);
var _default = exports.default = Metrics;
//# sourceMappingURL=new-metrics.js.map
