import { WebexPlugin } from '@webex/webex-core';
import CallDiagnosticMetrics from './call-diagnostic/call-diagnostic-metrics';
import { RecursivePartial, ClientEvent, FeatureEvent, BehavioralEvent, OperationalEvent, MediaQualityEvent, InternalEvent, SubmitClientEventOptions } from './metrics.types';
import CallDiagnosticLatencies from './call-diagnostic/call-diagnostic-metrics-latencies';
/**
 * Metrics plugin to centralize all types of metrics.
 * @class
 */
declare class Metrics extends WebexPlugin {
    static instance: Metrics;
    callDiagnosticLatencies: CallDiagnosticLatencies;
    callDiagnosticMetrics: CallDiagnosticMetrics;
    /**
     * Constructor
     * @param args
     * @constructor
     * @private
     * @returns
     */
    constructor(...args: any[]);
    /**
     * On Ready
     */
    private onReady;
    /**
     * Used for internal purposes only
     * @param args
     */
    submitInternalEvent({ name, payload, options, }: {
        name: InternalEvent['name'];
        payload?: RecursivePartial<InternalEvent['payload']>;
        options?: any;
    }): void;
    /**
     * Behavioral event
     * @param args
     */
    submitBehavioralEvent({ name, payload, options, }: {
        name: BehavioralEvent['name'];
        payload?: RecursivePartial<BehavioralEvent['payload']>;
        options?: any;
    }): void;
    /**
     * Operational event
     * @param args
     */
    submitOperationalEvent({ name, payload, options, }: {
        name: OperationalEvent['name'];
        payload?: RecursivePartial<OperationalEvent['payload']>;
        options?: any;
    }): void;
    /**
     * Call Analyzer: Media Quality Event
     * @param args
     */
    submitMQE({ name, payload, options, }: {
        name: MediaQualityEvent['name'];
        payload: RecursivePartial<MediaQualityEvent['payload']> & {
            intervals: MediaQualityEvent['payload']['intervals'];
        };
        options: any;
    }): void;
    /**
     * Call Analyzer: Feature Usage Event
     * @param args
     */
    submitFeatureEvent({ name, payload, options, }: {
        name: FeatureEvent['name'];
        payload?: RecursivePartial<FeatureEvent['payload']>;
        options: any;
    }): void;
    /**
     * Call Analyzer: Client Event
     * @public
     * @param args
     */
    submitClientEvent({ name, payload, options, }: {
        name: ClientEvent['name'];
        payload?: RecursivePartial<ClientEvent['payload']>;
        options?: SubmitClientEventOptions;
    }): Promise<any>;
    /**
     * Issue request to alias a user's pre-login ID with their CI UUID
     * @param {string} preLoginId
     * @returns {Object} HttpResponse object
     */
    clientMetricsAliasUser(preLoginId: string): any;
    /**
     * Returns a promise that will resolve to fetch options for submitting a metric.
     *
     * This is to support quickly submitting metrics when the browser/tab is closing.
     * Calling submitClientEvent will not work because there some async steps that will
     * not complete before the browser is closed.  Instead, we pre-gather all the
     * information/options needed for the request(s), and then simply and quickly
     * fire the fetch(es) when beforeUnload is triggered.
     *
     * We must use fetch instead of request because fetch has a keepalive option that
     * allows the request it to outlive the page.
     *
     * Note: the timings values will be wrong, but setMetricTimingsAndFetch() will
     * properly adjust them before submitting.
     *
     * @public
     * @param {Object} arg
     * @param {String} arg.name - event name
     * @param {Object} arg.payload - event payload
     * @param {Object} arg.options - other options
     * @returns {Promise} promise that resolves to options to be used with fetch
     */
    buildClientEventFetchRequestOptions({ name, payload, options, }: {
        name: ClientEvent['name'];
        payload?: RecursivePartial<ClientEvent['payload']>;
        options?: SubmitClientEventOptions;
    }): Promise<any>;
    /**
     * Submits a metric from pre-built request options via the fetch API. Updates
     * the "$timings" and "originTime" values to Date.now() since the existing times
     * were set when the options were built (not submitted).
  
     * @param {any} options - the pre-built request options for submitting a metric
     * @returns {Promise} promise that resolves to the response object
     */
    setMetricTimingsAndFetch(options: any): Promise<any>;
    /**
     * Returns true if the specified serviceErrorCode maps to an expected error.
     * @param {number} serviceErrorCode the service error code
     * @returns {boolean}
     */
    isServiceErrorExpected(serviceErrorCode: number): boolean;
}
export default Metrics;
