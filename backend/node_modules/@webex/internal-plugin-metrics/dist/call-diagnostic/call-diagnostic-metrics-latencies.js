"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _map = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/map"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _webexCore = require("@webex/webex-core");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /* eslint-disable class-methods-use-this */ /* eslint-disable valid-jsdoc */
// we only care about client event and feature event for now
/**
 * @description Helper class to store latencies timestamp and to calculate various latencies for CA.
 * @exports
 * @class CallDiagnosticLatencies
 */
var CallDiagnosticLatencies = exports.default = /*#__PURE__*/function (_WebexPlugin) {
  (0, _inherits2.default)(CallDiagnosticLatencies, _WebexPlugin);
  var _super = _createSuper(CallDiagnosticLatencies);
  /**
   * @constructor
   */
  function CallDiagnosticLatencies() {
    var _this;
    (0, _classCallCheck2.default)(this, CallDiagnosticLatencies);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "latencyTimestamps", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "precomputedLatencies", void 0);
    // meetingId that the current latencies are for
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "meetingId", void 0);
    _this.latencyTimestamps = new _map.default();
    _this.precomputedLatencies = new _map.default();
    return _this;
  }

  /**
   * Clear timestamps
   */
  (0, _createClass2.default)(CallDiagnosticLatencies, [{
    key: "clearTimestamps",
    value: function clearTimestamps() {
      this.latencyTimestamps.clear();
      this.precomputedLatencies.clear();
    }

    /**
     * Associate current latencies with a meeting id
     * @param meetingId
     */
  }, {
    key: "setMeetingId",
    value: function setMeetingId(meetingId) {
      this.meetingId = meetingId;
    }

    /**
     * Returns the meeting object associated with current latencies
     * @returns meeting object
     */
  }, {
    key: "getMeeting",
    value: function getMeeting() {
      if (this.meetingId) {
        // @ts-ignore
        return this.webex.meetings.meetingCollection.get(this.meetingId);
      }
      return undefined;
    }

    /**
     * Store timestamp value
     * @param key - key
     * @param value - value
     * @param options - store options
     * @throws
     * @returns
     */
  }, {
    key: "saveTimestamp",
    value: function saveTimestamp(_ref) {
      var key = _ref.key,
        _ref$value = _ref.value,
        value = _ref$value === void 0 ? new Date().getTime() : _ref$value,
        _ref$options = _ref.options,
        options = _ref$options === void 0 ? {} : _ref$options;
      // save the meetingId so we can use the meeting object in latency calculations if needed
      var meetingId = options.meetingId;
      if (meetingId) {
        this.setMeetingId(meetingId);
      }
      // for some events we're only interested in the first timestamp not last
      // as these events can happen multiple times
      if (key === 'client.media.rx.start' || key === 'client.media.tx.start' || key === 'internal.client.meetinginfo.request' || key === 'internal.client.meetinginfo.response') {
        this.saveFirstTimestampOnly(key, value);
      } else {
        this.latencyTimestamps.set(key, value);
      }
    }

    /**
     * Store precomputed latency value
     * @param key - key
     * @param value - value
     * @param accumulate - when it is true, it overwrites existing value with sum of the current value and the new measurement otherwise just store the new measurement
     * @throws
     * @returns
     */
  }, {
    key: "saveLatency",
    value: function saveLatency(key, value) {
      var accumulate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var existingValue = accumulate ? this.precomputedLatencies.get(key) || 0 : 0;
      this.precomputedLatencies.set(key, value + existingValue);
    }

    /**
     * Measure latency for a request
     * @param callback - callback for which you would like to measure latency
     * @param key - key
     * @param accumulate - when it is true, it overwrites existing value with sum of the current value and the new measurement otherwise just store the new measurement
     * @returns
     */
  }, {
    key: "measureLatency",
    value: function measureLatency(callback, key) {
      var _this2 = this;
      var accumulate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var start = performance.now();
      return callback().finally(function () {
        _this2.saveLatency(key, performance.now() - start, accumulate);
      });
    }

    /**
     * Store only the first timestamp value for the given key
     * @param key - key
     * @param  value -value
     * @throws
     * @returns
     */
  }, {
    key: "saveFirstTimestampOnly",
    value: function saveFirstTimestampOnly(key) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date().getTime();
      if (this.latencyTimestamps.has(key)) {
        return;
      }
      this.latencyTimestamps.set(key, value);
    }

    /**
     * Helper to calculate end - start
     * @param a start
     * @param b end
     * @returns latency
     */
  }, {
    key: "getDiffBetweenTimestamps",
    value: function getDiffBetweenTimestamps(a, b) {
      var start = this.latencyTimestamps.get(a);
      var end = this.latencyTimestamps.get(b);
      if (start && end) {
        return end - start;
      }
      return undefined;
    }

    /**
     * Meeting Info Request
     * @note Meeting Info request happen not just in the join phase. CA requires
     * metrics around meeting info request that are only part of join phase.
     * This internal.* event is used to track the real timestamps
     * (when the actual request/response happen). This is because the actual CA event is
     * sent inside the join method on the meeting object based on some logic, but that's not exactly when
     * those events are actually fired. The logic only confirms that they have happened, and we send them over.
     * @returns - latency
     */
  }, {
    key: "getMeetingInfoReqResp",
    value: function getMeetingInfoReqResp() {
      return this.getDiffBetweenTimestamps('internal.client.meetinginfo.request', 'internal.client.meetinginfo.response');
    }

    /**
     * Interstitial Time
     * @returns - latency
     */
  }, {
    key: "getShowInterstitialTime",
    value: function getShowInterstitialTime() {
      return this.getDiffBetweenTimestamps('client.interstitial-window.start-launch', 'internal.client.interstitial-window.click.joinbutton');
    }

    /**
     * getU2CTime
     * @returns - latency
     */
  }, {
    key: "getU2CTime",
    value: function getU2CTime() {
      var u2cLatency = this.precomputedLatencies.get('internal.get.u2c.time');
      return u2cLatency ? Math.floor(u2cLatency) : undefined;
    }

    /**
     * Device Register Time
     * @returns - latency
     */
  }, {
    key: "getRegisterWDMDeviceJMT",
    value: function getRegisterWDMDeviceJMT() {
      return this.getDiffBetweenTimestamps('internal.register.device.request', 'internal.register.device.response');
    }

    /**
     * Call Init Join Request
     * @returns - latency
     */
  }, {
    key: "getCallInitJoinReq",
    value: function getCallInitJoinReq() {
      return this.getDiffBetweenTimestamps('internal.client.interstitial-window.click.joinbutton', 'client.locus.join.request');
    }

    /**
     * Locus Join Request
     * @returns - latency
     */
  }, {
    key: "getJoinReqResp",
    value: function getJoinReqResp() {
      return this.getDiffBetweenTimestamps('client.locus.join.request', 'client.locus.join.response');
    }

    /**
     * Time taken to do turn discovery
     * @returns - latency
     */
  }, {
    key: "getTurnDiscoveryTime",
    value: function getTurnDiscoveryTime() {
      return this.getDiffBetweenTimestamps('internal.client.add-media.turn-discovery.start', 'internal.client.add-media.turn-discovery.end');
    }

    /**
     * Local SDP Generated Remote SDP REceived
     * @returns - latency
     */
  }, {
    key: "getLocalSDPGenRemoteSDPRecv",
    value: function getLocalSDPGenRemoteSDPRecv() {
      return this.getDiffBetweenTimestamps('client.media-engine.local-sdp-generated', 'client.media-engine.remote-sdp-received');
    }

    /**
     * ICE Setup Time
     * @returns - latency
     */
  }, {
    key: "getICESetupTime",
    value: function getICESetupTime() {
      return this.getDiffBetweenTimestamps('client.ice.start', 'client.ice.end');
    }

    /**
     * Audio ICE time
     * @returns - latency
     */
  }, {
    key: "getAudioICESetupTime",
    value: function getAudioICESetupTime() {
      return this.getDiffBetweenTimestamps('client.ice.start', 'client.ice.end');
    }

    /**
     * Video ICE Time
     * @returns - latency
     */
  }, {
    key: "getVideoICESetupTime",
    value: function getVideoICESetupTime() {
      return this.getDiffBetweenTimestamps('client.ice.start', 'client.ice.end');
    }

    /**
     * Share ICE Time
     * @returns - latency
     */
  }, {
    key: "getShareICESetupTime",
    value: function getShareICESetupTime() {
      return this.getDiffBetweenTimestamps('client.ice.start', 'client.ice.end');
    }

    /**
     * Stay Lobby Time
     * @returns - latency
     */
  }, {
    key: "getStayLobbyTime",
    value: function getStayLobbyTime() {
      return this.getDiffBetweenTimestamps('client.locus.join.response', 'internal.host.meeting.participant.admitted');
    }

    /**
     * Page JMT
     * @returns - latency
     */
  }, {
    key: "getPageJMT",
    value: function getPageJMT() {
      return this.precomputedLatencies.get('internal.client.pageJMT') || undefined;
    }

    /**
     * Download Time JMT
     * @returns - latency
     */
  }, {
    key: "getDownloadTimeJMT",
    value: function getDownloadTimeJMT() {
      return this.precomputedLatencies.get('internal.download.time') || undefined;
    }

    /**
     * Click To Interstitial
     * @returns - latency
     */
  }, {
    key: "getClickToInterstitial",
    value: function getClickToInterstitial() {
      // for normal join (where green join button exists before interstitial, i.e reminder, space list etc)
      if (this.latencyTimestamps.get('internal.client.meeting.click.joinbutton')) {
        return this.getDiffBetweenTimestamps('internal.client.meeting.click.joinbutton', 'internal.client.meeting.interstitial-window.showed');
      }

      // for cross launch and guest flows
      return this.precomputedLatencies.get('internal.click.to.interstitial') || undefined;
    }

    /**
     * Interstitial To Join Ok
     * @returns - latency
     */
  }, {
    key: "getInterstitialToJoinOK",
    value: function getInterstitialToJoinOK() {
      return this.getDiffBetweenTimestamps('internal.client.interstitial-window.click.joinbutton', 'client.locus.join.response');
    }

    /**
     * Call Init To MediaEngineReady
     * @returns - latency
     */
  }, {
    key: "getCallInitMediaEngineReady",
    value: function getCallInitMediaEngineReady() {
      return this.getDiffBetweenTimestamps('internal.client.interstitial-window.click.joinbutton', 'client.media-engine.ready');
    }

    /**
     * Interstitial To Media Ok
     * @returns - latency
     */
  }, {
    key: "getInterstitialToMediaOKJMT",
    value: function getInterstitialToMediaOKJMT() {
      var interstitialJoinClickTimestamp = this.latencyTimestamps.get('internal.client.interstitial-window.click.joinbutton');

      // get the first timestamp
      var connectedMedia = this.latencyTimestamps.get('client.ice.end');
      var lobbyTime = this.getStayLobbyTime() || 0;
      if (interstitialJoinClickTimestamp && connectedMedia) {
        return connectedMedia - interstitialJoinClickTimestamp - lobbyTime;
      }
      return undefined;
    }

    /**
     * Total JMT
     * @returns - latency
     */
  }, {
    key: "getTotalJMT",
    value: function getTotalJMT() {
      var clickToInterstitial = this.getClickToInterstitial();
      var interstitialToJoinOk = this.getInterstitialToJoinOK();
      if (clickToInterstitial && interstitialToJoinOk) {
        return clickToInterstitial + interstitialToJoinOk;
      }
      return undefined;
    }

    /**
     * Join Conf JMT
     * @returns - latency
     */
  }, {
    key: "getJoinConfJMT",
    value: function getJoinConfJMT() {
      var joinReqResp = this.getJoinReqResp();
      var ICESetupTime = this.getICESetupTime();
      if (joinReqResp && ICESetupTime) {
        return joinReqResp + ICESetupTime;
      }
      return undefined;
    }

    /**
     * Total Media JMT
     * @returns - latency
     */
  }, {
    key: "getTotalMediaJMT",
    value: function getTotalMediaJMT() {
      var clickToInterstitial = this.getClickToInterstitial();
      var interstitialToJoinOk = this.getInterstitialToJoinOK();
      var joinConfJMT = this.getJoinConfJMT();
      var lobbyTime = this.getStayLobbyTime();
      if (clickToInterstitial && interstitialToJoinOk && joinConfJMT) {
        var _this$getMeeting;
        var totalMediaJMT = clickToInterstitial + interstitialToJoinOk + joinConfJMT;
        if ((_this$getMeeting = this.getMeeting()) !== null && _this$getMeeting !== void 0 && _this$getMeeting.allowMediaInLobby) {
          return totalMediaJMT;
        }
        return totalMediaJMT - lobbyTime;
      }
      return undefined;
    }

    /**
     * Client JMT
     * @returns - latency
     */
  }, {
    key: "getClientJMT",
    value: function getClientJMT() {
      var interstitialToJoinOk = this.getInterstitialToJoinOK();
      var joinConfJMT = this.getJoinConfJMT();
      if (interstitialToJoinOk && joinConfJMT) {
        return interstitialToJoinOk - joinConfJMT;
      }
      return undefined;
    }

    /**
     * Audio setup delay receive
     */
  }, {
    key: "getAudioJoinRespRxStart",
    value: function getAudioJoinRespRxStart() {
      return this.getDiffBetweenTimestamps('client.locus.join.response', 'client.media.rx.start');
    }

    /**
     * Video setup delay receive
     */
  }, {
    key: "getVideoJoinRespRxStart",
    value: function getVideoJoinRespRxStart() {
      return this.getDiffBetweenTimestamps('client.locus.join.response', 'client.media.rx.start');
    }

    /**
     * Total latency for all get cluster request.
     */
  }, {
    key: "getReachabilityClustersReqResp",
    value: function getReachabilityClustersReqResp() {
      var reachablityClusterReqResp = this.precomputedLatencies.get('internal.get.cluster.time');
      return reachablityClusterReqResp ? Math.floor(reachablityClusterReqResp) : undefined;
    }

    /**
     * Audio setup delay transmit
     */
  }, {
    key: "getAudioJoinRespTxStart",
    value: function getAudioJoinRespTxStart() {
      return this.getDiffBetweenTimestamps('client.locus.join.response', 'client.media.tx.start');
    }

    /**
     * Video setup delay transmit
     */
  }, {
    key: "getVideoJoinRespTxStart",
    value: function getVideoJoinRespTxStart() {
      return this.getDiffBetweenTimestamps('client.locus.join.response', 'client.media.tx.start');
    }

    /**
     * Total latency for all exchange ci token.
     */
  }, {
    key: "getExchangeCITokenJMT",
    value: function getExchangeCITokenJMT() {
      var exchangeCITokenJMT = this.precomputedLatencies.get('internal.exchange.ci.token.time');
      return exchangeCITokenJMT ? Math.floor(exchangeCITokenJMT) : undefined;
    }

    /**
     * Total latency for all refresh captcha requests.
     */
  }, {
    key: "getRefreshCaptchaReqResp",
    value: function getRefreshCaptchaReqResp() {
      var refreshCaptchaReqResp = this.precomputedLatencies.get('internal.refresh.captcha.time');
      return refreshCaptchaReqResp ? Math.floor(refreshCaptchaReqResp) : undefined;
    }

    /**
     * Get the latency for downloading intelligence models.
     * @returns - latency
     */
  }, {
    key: "getDownloadIntelligenceModelsReqResp",
    value: function getDownloadIntelligenceModelsReqResp() {
      var downloadIntelligenceModelsReqResp = this.precomputedLatencies.get('internal.api.fetch.intelligence.models');
      return downloadIntelligenceModelsReqResp ? Math.floor(downloadIntelligenceModelsReqResp) : undefined;
    }

    /**
     * Get the total latency for all other app API requests.
     * Excludes meeting info, because it's measured separately.
     * @returns - latency
     */
  }, {
    key: "getOtherAppApiReqResp",
    value: function getOtherAppApiReqResp() {
      var otherAppApiJMT = this.precomputedLatencies.get('internal.other.app.api.time');
      return otherAppApiJMT > 0 ? Math.floor(otherAppApiJMT) : undefined;
    }
  }]);
  return CallDiagnosticLatencies;
}(_webexCore.WebexPlugin);
//# sourceMappingURL=call-diagnostic-metrics-latencies.js.map
