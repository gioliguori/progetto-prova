"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _common = require("@webex/common");
var _uuid = _interopRequireDefault(require("uuid"));
var _lodash = require("lodash");
var _webexCore = require("@webex/webex-core");
var _metrics = require("../metrics");
var _callDiagnosticMetrics = require("./call-diagnostic-metrics.util");
var _config = require("../config");
var _callDiagnosticMetricsBatcher = _interopRequireDefault(require("./call-diagnostic-metrics-batcher"));
var _preloginMetricsBatcher = _interopRequireDefault(require("../prelogin-metrics-batcher"));
var _config2 = require("./config");
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /* eslint-disable @typescript-eslint/no-unused-vars */ /* eslint-disable class-methods-use-this */ /* eslint-disable valid-jsdoc */
var _BrowserDetection = (0, _common.BrowserDetection)(),
  getOSVersion = _BrowserDetection.getOSVersion,
  getBrowserName = _BrowserDetection.getBrowserName,
  getBrowserVersion = _BrowserDetection.getBrowserVersion;
/**
 * @description Util class to handle Call Analyzer Metrics
 * @export
 * @class CallDiagnosticMetrics
 */
var CallDiagnosticMetrics = exports.default = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(CallDiagnosticMetrics, _StatelessWebexPlugin);
  var _super = _createSuper(CallDiagnosticMetrics);
  /**
   * Constructor
   * @param args
   */
  function CallDiagnosticMetrics() {
    var _this;
    (0, _classCallCheck2.default)(this, CallDiagnosticMetrics);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    // @ts-ignore
    // @ts-ignore
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "callDiagnosticEventsBatcher", void 0);
    // @ts-ignore
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "preLoginMetricsBatcher", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "logger", void 0);
    // to avoid adding @ts-ignore everywhere
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "hasLoggedBrowserSerial", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "device", void 0);
    // the default validator before piping an event to the batcher
    // this function can be overridden by the user
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validator", function (options) {
      return _promise.default.resolve({
        event: options === null || options === void 0 ? void 0 : options.event,
        valid: true
      });
    });
    /**
     * Prepare the event and send the request to metrics-a service, pre login.
     * @param event
     * @param preLoginId
     * @returns
     */
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "submitToCallDiagnosticsPreLogin", function (event, preLoginId) {
      // build metrics-a event type
      var finalEvent = {
        eventPayload: event,
        type: ['diagnostic-event']
      };
      _this.preLoginMetricsBatcher.savePreLoginId(preLoginId);
      return _this.preLoginMetricsBatcher.request(finalEvent);
    });
    _this.logger = _this.webex.logger;
    // @ts-ignore
    _this.callDiagnosticEventsBatcher = new _callDiagnosticMetricsBatcher.default({}, {
      parent: _this.webex
    });
    // @ts-ignore
    _this.preLoginMetricsBatcher = new _preloginMetricsBatcher.default({}, {
      parent: _this.webex
    });
    return _this;
  }

  /**
   * Returns the login type of the current user
   * @returns one of 'login-ci','unverified-guest', null
   */
  (0, _createClass2.default)(CallDiagnosticMetrics, [{
    key: "getCurLoginType",
    value: function getCurLoginType() {
      // @ts-ignore
      if (this.webex.canAuthorize) {
        // @ts-ignore
        return this.webex.credentials.isUnverifiedGuest ? 'unverified-guest' : 'login-ci';
      }
      return null;
    }

    /**
     * Returns if the meeting has converged architecture enabled
     * @param options.meetingId
     */
  }, {
    key: "getIsConvergedArchitectureEnabled",
    value: function getIsConvergedArchitectureEnabled(_ref) {
      var meetingId = _ref.meetingId;
      if (meetingId) {
        var _meeting$meetingInfo;
        // @ts-ignore
        var meeting = this.webex.meetings.meetingCollection.get(meetingId);
        return meeting === null || meeting === void 0 ? void 0 : (_meeting$meetingInfo = meeting.meetingInfo) === null || _meeting$meetingInfo === void 0 ? void 0 : _meeting$meetingInfo.enableConvergedArchitecture;
      }
      return undefined;
    }

    /**
     * Returns meeting's subServiceType
     * @param meeting
     * @returns
     */
  }, {
    key: "getSubServiceType",
    value: function getSubServiceType(meeting) {
      if (meeting) {
        // @ts-ignore
        var meetingInfo = meeting === null || meeting === void 0 ? void 0 : meeting.meetingInfo;
        // if not Scheduled, not Webinar, pmr - then pmr
        if (!(meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.webexScheduled) && !(meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.enableEvent) && meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.pmr) {
          return _config2.WEBEX_SUB_SERVICE_TYPES.PMR;
        }
        // if Scheduled, not Webinar, not pmr - then ScheduledMeeting
        if (meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.webexScheduled && !(meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.enableEvent) && !(meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.pmr)) {
          return _config2.WEBEX_SUB_SERVICE_TYPES.SCHEDULED_MEETING;
        }
        // if Scheduled, Webinar, not pmr - then Webinar
        if (meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.webexScheduled && meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.enableEvent && !(meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.pmr)) {
          return _config2.WEBEX_SUB_SERVICE_TYPES.WEBINAR;
        }
      }
      return undefined;
    }

    /**
     * Get origin object for Call Diagnostic Event payload.
     * @param options
     * @param meetingId
     * @returns
     */
  }, {
    key: "getOrigin",
    value: function getOrigin(options, meetingId) {
      var _this$webex$meetings$, _this$webex$meetings$2, _this$webex$meetings$3, _this$webex$meetings$4, _this$webex$meetings$5, _this$webex$meetings$6;
      var defaultClientType = // @ts-ignore
      (_this$webex$meetings$ = this.webex.meetings.config) === null || _this$webex$meetings$ === void 0 ? void 0 : (_this$webex$meetings$2 = _this$webex$meetings$.metrics) === null || _this$webex$meetings$2 === void 0 ? void 0 : _this$webex$meetings$2.clientType;
      var defaultSubClientType = // @ts-ignore
      (_this$webex$meetings$3 = this.webex.meetings.config) === null || _this$webex$meetings$3 === void 0 ? void 0 : (_this$webex$meetings$4 = _this$webex$meetings$3.metrics) === null || _this$webex$meetings$4 === void 0 ? void 0 : _this$webex$meetings$4.subClientType;
      // @ts-ignore
      var providedClientVersion = (_this$webex$meetings$5 = this.webex.meetings.config) === null || _this$webex$meetings$5 === void 0 ? void 0 : (_this$webex$meetings$6 = _this$webex$meetings$5.metrics) === null || _this$webex$meetings$6 === void 0 ? void 0 : _this$webex$meetings$6.clientVersion;
      // @ts-ignore
      var defaultSDKClientVersion = "".concat(_config.CLIENT_NAME, "/").concat(this.webex.version);
      var versionMetadata = {};

      // sdk version split doesn't really make sense for now...
      if (providedClientVersion) {
        versionMetadata = (0, _callDiagnosticMetrics.extractVersionMetadata)(providedClientVersion);
      }
      if (!this.hasLoggedBrowserSerial) {
        this.logger.log(_config2.CALL_DIAGNOSTIC_LOG_IDENTIFIER, "CallDiagnosticMetrics: @createClientEventObjectInMeeting => collected browser data", (0, _stringify.default)((0, _common.getBrowserSerial)()));
        this.hasLoggedBrowserSerial = true;
      }
      if (defaultClientType && defaultSubClientType || options.clientType && options.subClientType) {
        var _this$webex$meetings, _this$webex$meetings$7, _this$webex$meetings$8, _this$webex$meetings$9, _this$webex$meetings$10, _this$webex$meetings$11;
        var origin = {
          name: 'endpoint',
          networkType: (options === null || options === void 0 ? void 0 : options.networkType) || 'unknown',
          userAgent: (0, _callDiagnosticMetrics.userAgentToString)({
            // @ts-ignore
            clientName: (_this$webex$meetings = this.webex.meetings) === null || _this$webex$meetings === void 0 ? void 0 : (_this$webex$meetings$7 = _this$webex$meetings.config) === null || _this$webex$meetings$7 === void 0 ? void 0 : (_this$webex$meetings$8 = _this$webex$meetings$7.metrics) === null || _this$webex$meetings$8 === void 0 ? void 0 : _this$webex$meetings$8.clientName,
            // @ts-ignore
            webexVersion: this.webex.version
          }),
          clientInfo: _objectSpread(_objectSpread({
            clientType: (options === null || options === void 0 ? void 0 : options.clientType) || defaultClientType,
            clientVersion: providedClientVersion || defaultSDKClientVersion
          }, versionMetadata), {}, {
            publicNetworkPrefix:
            // @ts-ignore
            (0, _callDiagnosticMetrics.anonymizeIPAddress)((_this$webex$meetings$9 = this.webex.meetings.geoHintInfo) === null || _this$webex$meetings$9 === void 0 ? void 0 : _this$webex$meetings$9.clientAddress) || undefined,
            localNetworkPrefix: (0, _callDiagnosticMetrics.anonymizeIPAddress)( // @ts-ignore
            (_this$webex$meetings$10 = this.webex.meetings.meetingCollection.get(meetingId)) === null || _this$webex$meetings$10 === void 0 ? void 0 : (_this$webex$meetings$11 = _this$webex$meetings$10.statsAnalyzer) === null || _this$webex$meetings$11 === void 0 ? void 0 : _this$webex$meetings$11.getLocalIpAddress()) || undefined,
            osVersion: getOSVersion() || 'unknown',
            subClientType: (options === null || options === void 0 ? void 0 : options.subClientType) || defaultSubClientType,
            os: (0, _metrics.getOSNameInternal)(),
            browser: getBrowserName(),
            browserVersion: getBrowserVersion()
          })
        };
        if (meetingId) {
          // @ts-ignore
          var meeting = this.webex.meetings.meetingCollection.get(meetingId);
          if (meeting !== null && meeting !== void 0 && meeting.environment) {
            origin.environment = meeting.environment;
          }
        }
        if (options !== null && options !== void 0 && options.environment) {
          origin.environment = options.environment;
        }
        if (options !== null && options !== void 0 && options.newEnvironment) {
          origin.newEnvironment = options.newEnvironment;
        }
        if (options !== null && options !== void 0 && options.clientLaunchMethod) {
          origin.clientInfo.clientLaunchMethod = options.clientLaunchMethod;
        }
        if (options !== null && options !== void 0 && options.browserLaunchMethod) {
          origin.clientInfo.browserLaunchMethod = options.browserLaunchMethod;
        }
        return origin;
      }
      throw new Error("ClientType and SubClientType can't be undefined");
    }

    /**
     * Gather identifier details for call diagnostic payload.
     * @throws Error if initialization fails.
     * @param options
     */
  }, {
    key: "getIdentifiers",
    value: function getIdentifiers(options) {
      var _meeting$locusInfo, _meeting$meetingInfo2, _meeting$meetingInfo3, _meeting$meetingInfo6, _meeting$meetingInfo8;
      var meeting = options.meeting,
        mediaConnections = options.mediaConnections,
        correlationId = options.correlationId,
        webexConferenceIdStr = options.webexConferenceIdStr,
        globalMeetingId = options.globalMeetingId,
        preLoginId = options.preLoginId;
      var identifiers = {
        correlationId: 'unknown'
      };
      if (meeting) {
        identifiers.correlationId = meeting.correlationId;
      }
      if (correlationId) {
        identifiers.correlationId = correlationId;
      }
      if (this.device) {
        var device = this.device;
        var _ref2 = (device === null || device === void 0 ? void 0 : device.config) || {},
          installationId = _ref2.installationId;
        identifiers.userId = (device === null || device === void 0 ? void 0 : device.userId) || preLoginId;
        identifiers.deviceId = device === null || device === void 0 ? void 0 : device.url;
        identifiers.orgId = device === null || device === void 0 ? void 0 : device.orgId;
        // @ts-ignore
        identifiers.locusUrl = this.webex.internal.services.get('locus');
        if (installationId) {
          identifiers.machineId = installationId;
        }
      }
      if (meeting !== null && meeting !== void 0 && (_meeting$locusInfo = meeting.locusInfo) !== null && _meeting$locusInfo !== void 0 && _meeting$locusInfo.fullState) {
        identifiers.locusUrl = meeting.locusUrl;
        identifiers.locusId = meeting.locusUrl && meeting.locusUrl.split('/').pop();
        identifiers.locusStartTime = meeting.locusInfo.fullState && meeting.locusInfo.fullState.lastActive;
      }
      if (meeting !== null && meeting !== void 0 && (_meeting$meetingInfo2 = meeting.meetingInfo) !== null && _meeting$meetingInfo2 !== void 0 && _meeting$meetingInfo2.confIdStr || meeting !== null && meeting !== void 0 && (_meeting$meetingInfo3 = meeting.meetingInfo) !== null && _meeting$meetingInfo3 !== void 0 && _meeting$meetingInfo3.confID) {
        var _meeting$meetingInfo4, _meeting$meetingInfo5;
        identifiers.webexConferenceIdStr = "".concat(((_meeting$meetingInfo4 = meeting.meetingInfo) === null || _meeting$meetingInfo4 === void 0 ? void 0 : _meeting$meetingInfo4.confIdStr) || ((_meeting$meetingInfo5 = meeting.meetingInfo) === null || _meeting$meetingInfo5 === void 0 ? void 0 : _meeting$meetingInfo5.confID));
      }
      if (meeting !== null && meeting !== void 0 && (_meeting$meetingInfo6 = meeting.meetingInfo) !== null && _meeting$meetingInfo6 !== void 0 && _meeting$meetingInfo6.meetingId) {
        var _meeting$meetingInfo7;
        identifiers.globalMeetingId = (_meeting$meetingInfo7 = meeting.meetingInfo) === null || _meeting$meetingInfo7 === void 0 ? void 0 : _meeting$meetingInfo7.meetingId;
      }
      if (meeting !== null && meeting !== void 0 && (_meeting$meetingInfo8 = meeting.meetingInfo) !== null && _meeting$meetingInfo8 !== void 0 && _meeting$meetingInfo8.siteName) {
        var _meeting$meetingInfo9;
        identifiers.webexSiteName = (_meeting$meetingInfo9 = meeting.meetingInfo) === null || _meeting$meetingInfo9 === void 0 ? void 0 : _meeting$meetingInfo9.siteName;
      }
      if (mediaConnections) {
        var _mediaConnections$, _mediaConnections$2;
        identifiers.mediaAgentAlias = mediaConnections === null || mediaConnections === void 0 ? void 0 : (_mediaConnections$ = mediaConnections[0]) === null || _mediaConnections$ === void 0 ? void 0 : _mediaConnections$.mediaAgentAlias;
        identifiers.mediaAgentGroupId = mediaConnections === null || mediaConnections === void 0 ? void 0 : (_mediaConnections$2 = mediaConnections[0]) === null || _mediaConnections$2 === void 0 ? void 0 : _mediaConnections$2.mediaAgentGroupId;
      }
      if (!(identifiers !== null && identifiers !== void 0 && identifiers.webexConferenceIdStr) && webexConferenceIdStr) {
        identifiers.webexConferenceIdStr = "".concat(webexConferenceIdStr);
      }
      if (!(identifiers !== null && identifiers !== void 0 && identifiers.globalMeetingId) && globalMeetingId) {
        identifiers.globalMeetingId = globalMeetingId;
      }
      if (identifiers.correlationId === undefined) {
        throw new Error('Identifiers initialization failed.');
      }
      return identifiers;
    }

    /**
     * Create diagnostic event, which can hold client event, feature event or MQE event data.
     * This just initiates the shared properties that are required for all the 3 event categories.
     * @param eventData
     * @param options
     * @returns
     */
  }, {
    key: "prepareDiagnosticEvent",
    value: function prepareDiagnosticEvent(eventData, options) {
      var _this$webex$meetings$12;
      var meetingId = options.meetingId;
      var origin = this.getOrigin(options, meetingId);
      var event = {
        eventId: _uuid.default.v4(),
        version: 1,
        origin: origin,
        originTime: {
          triggered: new Date().toISOString(),
          // is overridden in prepareRequest batcher
          sent: 'not_defined_yet'
        },
        // @ts-ignore
        senderCountryCode: (_this$webex$meetings$12 = this.webex.meetings.geoHintInfo) === null || _this$webex$meetings$12 === void 0 ? void 0 : _this$webex$meetings$12.countryCode,
        event: eventData
      };

      // sanitize (remove empty properties, CA requires it)
      // but we don't want to sanitize MQE as most of the times
      // values will be 0, [] etc, and they are required.
      if (eventData.name !== 'client.mediaquality.event') {
        (0, _callDiagnosticMetrics.clearEmptyKeysRecursively)(event);
      }
      return event;
    }

    /**
     * TODO: NOT IMPLEMENTED
     * Submit Feature Event
     * @returns
     */
  }, {
    key: "submitFeatureEvent",
    value: function submitFeatureEvent() {
      throw Error('Not implemented');
    }

    /**
     * Submit Media Quality Event
     * @param args - submit params
     * @param arg.name - event key
     * @param arg.payload - additional payload to be merge with the default payload
     * @param arg.options - options
     */
  }, {
    key: "submitMQE",
    value: function submitMQE(_ref3) {
      var name = _ref3.name,
        payload = _ref3.payload,
        options = _ref3.options;
      var meetingId = options.meetingId,
        mediaConnections = options.mediaConnections,
        webexConferenceIdStr = options.webexConferenceIdStr,
        globalMeetingId = options.globalMeetingId;

      // events that will most likely happen in join phase
      if (meetingId) {
        // @ts-ignore
        var meeting = this.webex.meetings.meetingCollection.get(meetingId);
        if (!meeting) {
          console.warn('Attempt to send MQE but no meeting was found...', "event: ".concat(name, ", meetingId: ").concat(meetingId));
          // @ts-ignore
          this.webex.internal.metrics.submitClientMetrics(_config2.CALL_DIAGNOSTIC_EVENT_FAILED_TO_SEND, {
            fields: {
              meetingId: meetingId,
              name: name
            }
          });
          return;
        }

        // merge identifiers
        var identifiers = this.getIdentifiers({
          meeting: meeting,
          mediaConnections: meeting.mediaConnections || mediaConnections,
          webexConferenceIdStr: webexConferenceIdStr,
          globalMeetingId: globalMeetingId
        });

        // create media quality event object
        var clientEventObject = {
          name: name,
          canProceed: true,
          identifiers: identifiers,
          eventData: {
            webClientDomain: window.location.hostname
          },
          intervals: payload.intervals,
          callingServiceType: 'LOCUS',
          sourceMetadata: {
            applicationSoftwareType: _config.CLIENT_NAME,
            // @ts-ignore
            applicationSoftwareVersion: this.webex.version,
            mediaEngineSoftwareType: getBrowserName() || 'browser',
            mediaEngineSoftwareVersion: getOSVersion() || 'unknown',
            startTime: new Date().toISOString()
          }
        };

        // merge any new properties, or override existing ones
        clientEventObject = (0, _lodash.merge)(clientEventObject, payload);

        // append media quality event data to the call diagnostic event
        var diagnosticEvent = this.prepareDiagnosticEvent(clientEventObject, options);
        this.validator({
          type: 'mqe',
          event: diagnosticEvent
        });
        this.submitToCallDiagnostics(diagnosticEvent);
      } else {
        throw new Error('Media quality events cant be sent outside the context of a meeting. Meeting id is required.');
      }
    }

    /**
     * Return Client Event payload by client error code
     * @param arg - get error arg
     * @param arg.clientErrorCode
     * @param arg.serviceErrorCode
     * @param arg.payloadOverrides
     * @param arg.httpStatusCode
     * @returns
     */
  }, {
    key: "getErrorPayloadForClientErrorCode",
    value: function getErrorPayloadForClientErrorCode(_ref4) {
      var clientErrorCode = _ref4.clientErrorCode,
        serviceErrorCode = _ref4.serviceErrorCode,
        serviceErrorName = _ref4.serviceErrorName,
        rawErrorMessage = _ref4.rawErrorMessage,
        payloadOverrides = _ref4.payloadOverrides,
        httpStatusCode = _ref4.httpStatusCode;
      var error;
      if (clientErrorCode) {
        var partialParsedError = _config2.CLIENT_ERROR_CODE_TO_ERROR_PAYLOAD[clientErrorCode];
        if (partialParsedError) {
          error = (0, _lodash.merge)({
            fatal: true,
            shownToUser: false,
            name: 'other',
            category: 'other'
          },
          // default values
          {
            errorCode: clientErrorCode
          }, serviceErrorName ? {
            errorData: {
              errorName: serviceErrorName
            }
          } : {}, {
            serviceErrorCode: serviceErrorCode
          }, {
            rawErrorMessage: rawErrorMessage
          }, httpStatusCode === undefined ? {} : {
            httpStatusCode: httpStatusCode
          }, partialParsedError, payloadOverrides || {});
          return error;
        }
      }
      return undefined;
    }

    /**
     * Generate error payload for Client Event
     * @param rawError
     */
  }, {
    key: "generateClientEventErrorPayload",
    value: function generateClientEventErrorPayload(rawError) {
      var _rawError$error, _rawError$error$body, _rawError$body, _rawError$body2, _rawError$body3, _rawError$body3$reaso;
      var rawErrorMessage = rawError.message;
      var httpStatusCode = rawError.statusCode;
      if (rawError.name) {
        if ((0, _callDiagnosticMetrics.isBrowserMediaErrorName)(rawError.name)) {
          return this.getErrorPayloadForClientErrorCode({
            serviceErrorCode: undefined,
            clientErrorCode: _config2.BROWSER_MEDIA_ERROR_NAME_TO_CLIENT_ERROR_CODES_MAP[rawError.name],
            serviceErrorName: rawError.name,
            rawErrorMessage: rawErrorMessage,
            httpStatusCode: httpStatusCode
          });
        }
      }
      if ((0, _callDiagnosticMetrics.isSdpOfferCreationError)(rawError)) {
        var _rawError$cause;
        // error code is 30005, but that's not specific enough. we also need to check error.cause.type
        var causeType = (_rawError$cause = rawError.cause) === null || _rawError$cause === void 0 ? void 0 : _rawError$cause.type;
        return this.getErrorPayloadForClientErrorCode({
          serviceErrorCode: undefined,
          clientErrorCode: _config2.SDP_OFFER_CREATION_ERROR_MAP[causeType] || _config2.SDP_OFFER_CREATION_ERROR_MAP.GENERAL,
          serviceErrorName: rawError.name,
          rawErrorMessage: rawErrorMessage,
          httpStatusCode: httpStatusCode
        });
      }
      var serviceErrorCode = (rawError === null || rawError === void 0 ? void 0 : (_rawError$error = rawError.error) === null || _rawError$error === void 0 ? void 0 : (_rawError$error$body = _rawError$error.body) === null || _rawError$error$body === void 0 ? void 0 : _rawError$error$body.errorCode) || (rawError === null || rawError === void 0 ? void 0 : (_rawError$body = rawError.body) === null || _rawError$body === void 0 ? void 0 : _rawError$body.errorCode) || (rawError === null || rawError === void 0 ? void 0 : (_rawError$body2 = rawError.body) === null || _rawError$body2 === void 0 ? void 0 : _rawError$body2.code) || (rawError === null || rawError === void 0 ? void 0 : (_rawError$body3 = rawError.body) === null || _rawError$body3 === void 0 ? void 0 : (_rawError$body3$reaso = _rawError$body3.reason) === null || _rawError$body3$reaso === void 0 ? void 0 : _rawError$body3$reaso.reasonCode);
      if (serviceErrorCode) {
        var clientErrorCode = _config2.SERVICE_ERROR_CODES_TO_CLIENT_ERROR_CODES_MAP[serviceErrorCode];
        if (clientErrorCode) {
          return this.getErrorPayloadForClientErrorCode({
            clientErrorCode: clientErrorCode,
            serviceErrorCode: serviceErrorCode,
            rawErrorMessage: rawErrorMessage,
            httpStatusCode: httpStatusCode
          });
        }

        // by default, if it is locus error, return new locus err
        if ((0, _callDiagnosticMetrics.isLocusServiceErrorCode)(serviceErrorCode)) {
          return this.getErrorPayloadForClientErrorCode({
            clientErrorCode: _config2.NEW_LOCUS_ERROR_CLIENT_CODE,
            serviceErrorCode: serviceErrorCode,
            rawErrorMessage: rawErrorMessage,
            httpStatusCode: httpStatusCode
          });
        }
      }
      if ((0, _callDiagnosticMetrics.isMeetingInfoServiceError)(rawError)) {
        return this.getErrorPayloadForClientErrorCode({
          clientErrorCode: _config2.MEETING_INFO_LOOKUP_ERROR_CLIENT_CODE,
          serviceErrorCode: serviceErrorCode,
          rawErrorMessage: rawErrorMessage,
          httpStatusCode: httpStatusCode
        });
      }
      if ((0, _callDiagnosticMetrics.isNetworkError)(rawError)) {
        return this.getErrorPayloadForClientErrorCode({
          clientErrorCode: _config2.NETWORK_ERROR,
          serviceErrorCode: serviceErrorCode,
          payloadOverrides: rawError.payloadOverrides,
          rawErrorMessage: rawErrorMessage,
          httpStatusCode: httpStatusCode
        });
      }
      if ((0, _callDiagnosticMetrics.isUnauthorizedError)(rawError)) {
        return this.getErrorPayloadForClientErrorCode({
          clientErrorCode: _config2.AUTHENTICATION_FAILED_CODE,
          serviceErrorCode: serviceErrorCode,
          payloadOverrides: rawError.payloadOverrides,
          rawErrorMessage: rawErrorMessage,
          httpStatusCode: httpStatusCode
        });
      }

      // otherwise return unkown error
      return this.getErrorPayloadForClientErrorCode({
        clientErrorCode: _config2.UNKNOWN_ERROR,
        serviceErrorCode: _config2.UNKNOWN_ERROR,
        payloadOverrides: rawError.payloadOverrides,
        rawErrorMessage: rawErrorMessage,
        httpStatusCode: httpStatusCode
      });
    }

    /**
     * Create client event object for in meeting events
     * @param arg - create args
     * @param arg.event - event key
     * @param arg.options - options
     * @returns object
     */
  }, {
    key: "createClientEventObjectInMeeting",
    value: function createClientEventObjectInMeeting(_ref5) {
      var name = _ref5.name,
        options = _ref5.options,
        errors = _ref5.errors;
      var meetingId = options.meetingId,
        mediaConnections = options.mediaConnections,
        globalMeetingId = options.globalMeetingId,
        webexConferenceIdStr = options.webexConferenceIdStr;

      // @ts-ignore
      var meeting = this.webex.meetings.meetingCollection.get(meetingId);
      if (!meeting) {
        console.warn('Attempt to send client event but no meeting was found...', "name: ".concat(name, ", meetingId: ").concat(meetingId));
        // @ts-ignore
        this.webex.internal.metrics.submitClientMetrics(_config2.CALL_DIAGNOSTIC_EVENT_FAILED_TO_SEND, {
          fields: {
            meetingId: meetingId,
            name: name
          }
        });
        return undefined;
      }

      // grab identifiers
      var identifiers = this.getIdentifiers({
        meeting: meeting,
        mediaConnections: (meeting === null || meeting === void 0 ? void 0 : meeting.mediaConnections) || mediaConnections,
        webexConferenceIdStr: webexConferenceIdStr,
        globalMeetingId: globalMeetingId
      });

      // create client event object
      var clientEventObject = {
        name: name,
        canProceed: true,
        identifiers: identifiers,
        errors: errors,
        eventData: {
          webClientDomain: window.location.hostname
        },
        userType: meeting.getCurUserType(),
        loginType: 'loginType' in meeting.callStateForMetrics ? meeting.callStateForMetrics.loginType : this.getCurLoginType(),
        isConvergedArchitectureEnabled: this.getIsConvergedArchitectureEnabled({
          meetingId: meetingId
        }),
        webexSubServiceType: this.getSubServiceType(meeting)
      };
      return clientEventObject;
    }

    /**
     * Create client event object for pre meeting events
     * @param arg - create args
     * @param arg.event - event key
     * @param arg.options - payload
     * @returns object
     */
  }, {
    key: "createClientEventObjectPreMeeting",
    value: function createClientEventObjectPreMeeting(_ref6) {
      var name = _ref6.name,
        options = _ref6.options,
        errors = _ref6.errors;
      var correlationId = options.correlationId,
        globalMeetingId = options.globalMeetingId,
        webexConferenceIdStr = options.webexConferenceIdStr,
        preLoginId = options.preLoginId;

      // grab identifiers
      var identifiers = this.getIdentifiers({
        correlationId: correlationId,
        preLoginId: preLoginId,
        globalMeetingId: globalMeetingId,
        webexConferenceIdStr: webexConferenceIdStr
      });

      // create client event object
      var clientEventObject = {
        name: name,
        errors: errors,
        canProceed: true,
        identifiers: identifiers,
        eventData: {
          webClientDomain: window.location.hostname
        },
        loginType: this.getCurLoginType()
      };
      return clientEventObject;
    }

    /**
     * Prepare Client Event CA event.
     * @param arg - submit params
     * @param arg.event - event key
     * @param arg.payload - additional payload to be merged with default payload
     * @param arg.options - payload
     * @returns {any} options to be with fetch
     * @throws
     */
  }, {
    key: "prepareClientEvent",
    value: function prepareClientEvent(_ref7) {
      var name = _ref7.name,
        payload = _ref7.payload,
        options = _ref7.options;
      var meetingId = options.meetingId,
        correlationId = options.correlationId,
        rawError = options.rawError;
      var clientEventObject;

      // check if we need to generate errors
      var errors = [];
      if (rawError) {
        var generatedError = this.generateClientEventErrorPayload(rawError);
        if (generatedError) {
          errors.push(generatedError);
        }
        this.logger.log(_config2.CALL_DIAGNOSTIC_LOG_IDENTIFIER, 'CallDiagnosticMetrics: @prepareClientEvent. Generated errors:', "generatedError: ".concat((0, _stringify.default)(generatedError)));
      }

      // events that will most likely happen in join phase
      if (meetingId) {
        clientEventObject = this.createClientEventObjectInMeeting({
          name: name,
          options: options,
          errors: errors
        });
      } else if (correlationId) {
        // any pre join events or events that are outside the meeting.
        clientEventObject = this.createClientEventObjectPreMeeting({
          name: name,
          options: options,
          errors: errors
        });
      } else {
        throw new Error('Not implemented');
      }

      // merge any new properties, or override existing ones
      clientEventObject = (0, _lodash.merge)(clientEventObject, payload);

      // append client event data to the call diagnostic event
      var diagnosticEvent = this.prepareDiagnosticEvent(clientEventObject, options);
      return diagnosticEvent;
    }

    /**
     * Submit Client Event CA event.
     * @param arg - submit params
     * @param arg.event - event key
     * @param arg.payload - additional payload to be merged with default payload
     * @param arg.options - payload
     * @throws
     */
  }, {
    key: "submitClientEvent",
    value: function submitClientEvent(_ref8) {
      var name = _ref8.name,
        payload = _ref8.payload,
        options = _ref8.options;
      this.logger.log(_config2.CALL_DIAGNOSTIC_LOG_IDENTIFIER, 'CallDiagnosticMetrics: @submitClientEvent. Submit Client Event CA event.', "name: ".concat(name));
      var diagnosticEvent = this.prepareClientEvent({
        name: name,
        payload: payload,
        options: options
      });
      if (options !== null && options !== void 0 && options.preLoginId) {
        return this.submitToCallDiagnosticsPreLogin(diagnosticEvent, options === null || options === void 0 ? void 0 : options.preLoginId);
      }
      this.validator({
        type: 'ce',
        event: diagnosticEvent
      });
      return this.submitToCallDiagnostics(diagnosticEvent);
    }

    /**
     * Prepare the event and send the request to metrics-a service.
     * @param event
     * @returns promise
     */
  }, {
    key: "submitToCallDiagnostics",
    value: function submitToCallDiagnostics(event) {
      // build metrics-a event type
      var finalEvent = {
        eventPayload: event,
        type: ['diagnostic-event']
      };
      return this.callDiagnosticEventsBatcher.request(finalEvent);
    }
  }, {
    key: "buildClientEventFetchRequestOptions",
    value: (
    /**
     * Builds a request options object to later be passed to fetch().
     * @param arg - submit params
     * @param arg.event - event key
     * @param arg.payload - additional payload to be merged with default payload
     * @param arg.options - client event options
     * @returns {Promise<any>}
     * @throws
     */
    function () {
      var _buildClientEventFetchRequestOptions = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref9) {
        var name, payload, options, clientEvent, diagnosticEvent, request;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              name = _ref9.name, payload = _ref9.payload, options = _ref9.options;
              this.logger.log(_config2.CALL_DIAGNOSTIC_LOG_IDENTIFIER, 'CallDiagnosticMetrics: @buildClientEventFetchRequestOptions. Building request options object for fetch()...', "name: ".concat(name));
              clientEvent = this.prepareClientEvent({
                name: name,
                payload: payload,
                options: options
              }); // build metrics-a event type
              // @ts-ignore
              diagnosticEvent = (0, _callDiagnosticMetrics.prepareDiagnosticMetricItem)(this.webex, {
                eventPayload: clientEvent,
                type: ['diagnostic-event']
              });
              request = {
                method: 'POST',
                service: 'metrics',
                resource: 'clientmetrics',
                body: {
                  metrics: [diagnosticEvent]
                },
                headers: {},
                // @ts-ignore
                waitForServiceTimeout: this.webex.internal.metrics.config.waitForServiceTimeout
              };
              if (options.preLoginId) {
                request.headers = {
                  authorization: false,
                  'x-prelogin-userid': options.preLoginId
                };
                request.resource = 'clientmetrics-prelogin';
              }

              // @ts-ignore
              return _context.abrupt("return", this.webex.prepareFetchOptions(request));
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function buildClientEventFetchRequestOptions(_x) {
        return _buildClientEventFetchRequestOptions.apply(this, arguments);
      }
      return buildClientEventFetchRequestOptions;
    }()
    /**
     * Returns true if the specified serviceErrorCode maps to an expected error.
     * @param {number} serviceErrorCode the service error code
     * @returns {boolean}
     */
    )
  }, {
    key: "isServiceErrorExpected",
    value: function isServiceErrorExpected(serviceErrorCode) {
      var clientErrorCode = _config2.SERVICE_ERROR_CODES_TO_CLIENT_ERROR_CODES_MAP[serviceErrorCode];
      var clientErrorPayload = _config2.CLIENT_ERROR_CODE_TO_ERROR_PAYLOAD[clientErrorCode];
      return (clientErrorPayload === null || clientErrorPayload === void 0 ? void 0 : clientErrorPayload.category) === 'expected';
    }

    /**
     * This method is used to set the device information by internal-plugin-device
     * @param {device} object The webex.internal.device object
     * @returns {undefined}
     */
  }, {
    key: "setDeviceInfo",
    value: function setDeviceInfo(device) {
      // This was created to fix the circular dependency between internal-plugin-device and internal-plugin-metrics
      this.logger.log('CallDiagnosticMetrics: @setDeviceInfo called', device);
      this.device = device;
    }
  }]);
  return CallDiagnosticMetrics;
}(_webexCore.StatelessWebexPlugin);
//# sourceMappingURL=call-diagnostic-metrics.js.map
