"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getOSNameInternal = getOSNameInternal;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _webexCore = require("@webex/webex-core");
var _common = require("@webex/common");
var _config = require("./config");
var _batcher = _interopRequireDefault(require("./batcher"));
var _clientMetricsBatcher = _interopRequireDefault(require("./client-metrics-batcher"));
var _clientMetricsPreloginBatcher = _interopRequireDefault(require("./client-metrics-prelogin-batcher"));
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable default-param-last */ /*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
var _BrowserDetection = (0, _common.BrowserDetection)(),
  getOSName = _BrowserDetection.getOSName,
  getOSVersion = _BrowserDetection.getOSVersion,
  getBrowserName = _BrowserDetection.getBrowserName,
  getBrowserVersion = _BrowserDetection.getBrowserVersion;
function getOSNameInternal() {
  var _OSMap$getOSName;
  return (_OSMap$getOSName = _config.OSMap[getOSName()]) !== null && _OSMap$getOSName !== void 0 ? _OSMap$getOSName : _config.OS_NAME.OTHERS;
}
function getSparkUserAgent(webex) {
  var _webex$config;
  var _ref = (_webex$config = webex === null || webex === void 0 ? void 0 : webex.config) !== null && _webex$config !== void 0 ? _webex$config : {},
    appName = _ref.appName,
    appVersion = _ref.appVersion,
    appPlatform = _ref.appPlatform;
  var sparkUserAgent = _config.CLIENT_NAME;
  if (appName) {
    sparkUserAgent += " ".concat(appName, "/").concat(appVersion !== null && appVersion !== void 0 ? appVersion : '0.0');
  }
  if (appPlatform) {
    sparkUserAgent += " ".concat(appPlatform);
  }
  return sparkUserAgent;
}
var Metrics = _webexCore.WebexPlugin.extend({
  children: {
    batcher: _batcher.default,
    clientMetricsBatcher: _clientMetricsBatcher.default,
    clientMetricsPreloginBatcher: _clientMetricsPreloginBatcher.default
  },
  namespace: 'Metrics',
  submit: function submit(key, value) {
    return this.batcher.request(_objectSpread({
      key: key
    }, value));
  },
  /**
   * Returns the payload for submitting client metrics.
   * @param {string} eventName
   * @param {any} props
   * @returns {any} - the payload
   */
  getClientMetricsPayload: function getClientMetricsPayload(eventName, props) {
    var _this$webex$meetings, _this$webex$meetings$, _this$webex$meetings$2;
    if (!eventName) {
      throw Error('Missing behavioral metric name. Please provide one');
    }
    var payload = {
      metricName: eventName
    };
    // @ts-ignore
    var providedClientVersion = (_this$webex$meetings = this.webex.meetings) === null || _this$webex$meetings === void 0 ? void 0 : (_this$webex$meetings$ = _this$webex$meetings.config) === null || _this$webex$meetings$ === void 0 ? void 0 : (_this$webex$meetings$2 = _this$webex$meetings$.metrics) === null || _this$webex$meetings$2 === void 0 ? void 0 : _this$webex$meetings$2.clientVersion;
    payload.tags = _objectSpread(_objectSpread({}, props.tags), {}, {
      browser: getBrowserName(),
      os: getOSNameInternal(),
      appVersion: providedClientVersion,
      // Node does not like this so we need to check if it exists or not
      // eslint-disable-next-line no-undef
      domain: typeof window !== 'undefined' ? window.location.hostname || 'non-browser' : 'non-browser' // Check what else we could measure
    });

    payload.fields = _objectSpread(_objectSpread({}, props.fields), {}, {
      browser_version: getBrowserVersion(),
      os_version: getOSVersion(),
      sdk_version: this.webex.version,
      platform: 'Web',
      spark_user_agent: getSparkUserAgent(this.webex),
      client_id: this.webex.credentials.config.client_id
    });
    payload.type = props.type || this.webex.config.metrics.type;
    payload.context = _objectSpread(_objectSpread({}, props.context), {}, {
      app: {
        version: this.webex.version
      },
      locale: 'en-US',
      os: {
        name: getOSNameInternal(),
        version: getOSVersion()
      }
    });
    if (props.eventPayload) {
      payload.eventPayload = props.eventPayload;
    }

    // Mocking the time in tests when running in node
    // is impossible so unable to use Date.now()
    payload.timestamp = new Date().valueOf();
    return payload;
  },
  /**
   * This corresponds to #sendSemiStructured() in the deprecated metrics handler
   * @param {string} eventName
   * @param {Object} props
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  submitClientMetrics: function submitClientMetrics(eventName) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var preLoginId = arguments.length > 2 ? arguments[2] : undefined;
    var payload = this.getClientMetricsPayload(eventName, props);
    if (preLoginId) {
      this.clientMetricsPreloginBatcher.savePreLoginId(preLoginId);
      return this.clientMetricsPreloginBatcher.request(payload);
    }
    return this.clientMetricsBatcher.request(payload);
  },
  /**
   * Issue request to alias a user's pre-login ID with their CI UUID
   * @param {string} preLoginId
   * @returns {Object} HttpResponse object
   */
  aliasUser: function aliasUser(preLoginId) {
    return this.request({
      method: 'POST',
      api: 'metrics',
      resource: 'clientmetrics',
      headers: {
        'x-prelogin-userid': preLoginId
      },
      body: {},
      qs: {
        alias: true
      }
    });
  },
  version: "3.3.1"
});
var _default = exports.default = Metrics;
//# sourceMappingURL=metrics.js.map
