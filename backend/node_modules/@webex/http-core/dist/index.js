"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
_Object$defineProperty(exports, "HttpError", {
  enumerable: true,
  get: function get() {
    return _httpError.default;
  }
});
_Object$defineProperty(exports, "HttpStatusInterceptor", {
  enumerable: true,
  get: function get() {
    return _httpStatus.default;
  }
});
_Object$defineProperty(exports, "Interceptor", {
  enumerable: true,
  get: function get() {
    return _interceptor.default;
  }
});
_Object$defineProperty(exports, "ProgressEvent", {
  enumerable: true,
  get: function get() {
    return _progressEvent.default;
  }
});
exports.defaults = void 0;
_Object$defineProperty(exports, "detect", {
  enumerable: true,
  get: function get() {
    return _detect.default;
  }
});
exports.setTimingsAndFetch = exports.request = exports.protoprepareFetchOptions = void 0;
var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/get-own-property-descriptor"));
var _defineProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/define-property"));
var _deleteProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/delete-property"));
var _lodash = require("lodash");
var _httpStatus = _interopRequireDefault(require("./interceptors/http-status"));
var _request2 = _interopRequireDefault(require("./request"));
var _utils = require("./request/utils");
var _progressEvent = _interopRequireDefault(require("./progress-event"));
var _interceptor = _interopRequireDefault(require("./lib/interceptor"));
var _httpError = _interopRequireDefault(require("./http-error"));
var _detect = _interopRequireDefault(require("./lib/detect"));
/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

// Curry protorequest so we generate a function with default options built in.
var protorequest = (0, _lodash.curry)(function protorequest(defaultOptions, options) {
  // allow for options to be a string (and therefore expect options in the third
  // position) to match request's api.
  if ((0, _lodash.isString)(options)) {
    var uri = options;

    /* eslint prefer-rest-params: [0] */
    options = arguments[2] || {};
    options.uri = uri;
  }

  // Hide useless elements from logs
  ['download', 'interceptors', 'logger', 'upload'].forEach(function (prop) {
    var descriptor = (0, _getOwnPropertyDescriptor.default)(options, prop);
    descriptor = (0, _lodash.assign)({}, descriptor, {
      enumerable: false,
      writable: true
    });
    (0, _defineProperty.default)(options, prop, descriptor);
  });
  (0, _lodash.defaults)(options, defaultOptions);
  if (!options.json && options.json !== false) {
    (0, _deleteProperty.default)(options, 'json');
  }
  options.logger = options.logger || this.logger || console;
  return (0, _request2.default)(options);
});
var protoprepareFetchOptions = exports.protoprepareFetchOptions = (0, _lodash.curry)(function protoprepareFetchOptions(defaultOptions, options) {
  // Hide useless elements from logs
  ['download', 'interceptors', 'logger', 'upload'].forEach(function (prop) {
    var descriptor = (0, _getOwnPropertyDescriptor.default)(options, prop);
    descriptor = (0, _lodash.assign)({}, descriptor, {
      enumerable: false,
      writable: true
    });
    (0, _defineProperty.default)(options, prop, descriptor);
  });
  (0, _lodash.defaults)(options, defaultOptions);
  options.logger = options.logger || this.logger || console;
  return (0, _utils.prepareFetchOptions)(options);
});

/**
 * Sets the $timings value(s) before the request/fetch.
 * This function is only useful if you are about to send a request
 * using prepared fetch options; normally it is done in webex.request();
 *
 * @param {any} options
 * @returns {any} the updated options object
 */
var setRequestTimings = function setRequestTimings(options) {
  var now = new Date().getTime();
  options.$timings = options.$timings || {};
  options.$timings.requestStart = now;
  options.$timings.networkStart = now;
  return options;
};

/**
 * Submits a metric from pre-built request options via the fetch API. Updates
 * the "$timings" values to Date.now() since the existing times were set when
 * the options were built (not submitted).
 *
 * @param {any} options - the pre-built request options for submitting a metric
 * @returns {Promise} promise that resolves to a response object
 */
var setTimingsAndFetch = exports.setTimingsAndFetch = function setTimingsAndFetch(options) {
  var opts = setRequestTimings(options);

  // call the fetch API
  return fetch(opts.uri, opts);
};
var defaultOptions = {
  json: true,
  interceptors: [
  // Reminder: this is supposed to be an instantiated interceptor.
  _httpStatus.default.create()]
};
var defaults = exports.defaults = protorequest;
var request = exports.request = protorequest(defaultOptions);
//# sourceMappingURL=index.js.map
