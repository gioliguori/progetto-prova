'use strict';

var fs = require('fs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  var f = n.default;
	if (typeof f == "function") {
		var a = function () {
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));

String.prototype.hashCode = function () {
    const key = this.toString();
    let h1b, k1;

    const remainder = key.length & 3; // key.length % 4
    const bytes = key.length - remainder;
    let h1 = String.prototype.seed;
    const c1 = 0xcc9e2d51;
    const c2 = 0x1b873593;
    let i = 0;

    while (i < bytes) {
        k1 =
            ((key.charCodeAt(i) & 0xff)) |
            ((key.charCodeAt(++i) & 0xff) << 8) |
            ((key.charCodeAt(++i) & 0xff) << 16) |
            ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;

        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

        h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }

    k1 = 0;

    switch (remainder) {
        case 3:
            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
        // no-break
        case 2:
            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
        // no-break
        case 1:
            k1 ^= (key.charCodeAt(i) & 0xff);
            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
            h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
};

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/*! https://mths.be/codepointat v0.2.0 by @mathias */
if (!String.prototype.codePointAt) {
	(function() {
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			let result;
			try {
				const object = {};
				const $defineProperty = Object.defineProperty;
				result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {
				/* eslint no-empty: [ "off" ] */
			}
			return result;
		}());
		const codePointAt = function(position) {
			if (this == null) {
				throw TypeError();
			}
			const string = String(this);
			const size = string.length;
			// `ToInteger`
			let index = position ? Number(position) : 0;
			if (index !== index) { // better `isNaN`
				index = 0;
			}
			// Account for out-of-bounds indices:
			if (index < 0 || index >= size) {
				return undefined;
			}
			// Get the first code unit
			const first = string.charCodeAt(index);
			let second;
			if ( // check if itâ€™s the start of a surrogate pair
				first >= 0xD800 && first <= 0xDBFF && // high surrogate
				size > index + 1 // there is a next code unit
			) {
				second = string.charCodeAt(index + 1);
				if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
				}
			}
			return first;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'codePointAt', {
				'value': codePointAt,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.codePointAt = codePointAt;
		}
	}());
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
if (!String.fromCodePoint) {
	(function() {
		const defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			let result;
			try {
				const object = {};
				const $defineProperty = Object.defineProperty;
				result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {
				/* eslint no-empty: [ "off" ] */
			}
			return result;
		}());
		const stringFromCharCode = String.fromCharCode;
		const floor = Math.floor;
		const fromCodePoint = function(_) {
			const MAX_SIZE = 0x4000;
			const codeUnits = [];
			let highSurrogate;
			let lowSurrogate;
			let index = -1;
			const length = arguments.length;
			if (!length) {
				return '';
			}
			let result = '';
			while (++index < length) {
				let codePoint = Number(arguments[index]);
				if (
					!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
					codePoint < 0 || // not a valid Unicode code point
					codePoint > 0x10FFFF || // not a valid Unicode code point
					floor(codePoint) !== codePoint // not an integer
				) {
					throw RangeError('Invalid code point: ' + codePoint);
				}
				if (codePoint <= 0xFFFF) { // BMP code point
					codeUnits.push(codePoint);
				} else { // Astral code point; split in surrogate halves
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					codePoint -= 0x10000;
					highSurrogate = (codePoint >> 10) + 0xD800;
					lowSurrogate = (codePoint % 0x400) + 0xDC00;
					codeUnits.push(highSurrogate, lowSurrogate);
				}
				if (index + 1 === length || codeUnits.length > MAX_SIZE) {
					result += stringFromCharCode.apply(null, codeUnits);
					codeUnits.length = 0;
				}
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String, 'fromCodePoint', {
				'value': fromCodePoint,
				'configurable': true,
				'writable': true
			});
		} else {
			String.fromCodePoint = fromCodePoint;
		}
	}());
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * A token has properties: text, type, line, character position in the line
 * (so we can ignore tabs), token channel, index, and source from which
 * we obtained this token.
 */
class Token {
	constructor() {
		this.source = null;
		this.type = null; // token type of the token
		this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL
		this.start = null; // optional; return -1 if not implemented.
		this.stop = null; // optional; return -1 if not implemented.
		this.tokenIndex = null; // from 0..n-1 of the token object in the input stream
		this.line = null; // line=1..n of the 1st character
		this.column = null; // beginning of the line at which it occurs, 0..n-1
		this._text = null; // text of the token.
	}

	getTokenSource() {
		return this.source[0];
	}

	getInputStream() {
		return this.source[1];
	}

	get text(){
		return this._text;
	}

	set text(text) {
		this._text = text;
	}
}

Token.INVALID_TYPE = 0;

/**
 * During lookahead operations, this "token" signifies we hit rule end ATN state
 * and did not follow it despite needing to.
 */
Token.EPSILON = -2;

Token.MIN_USER_TOKEN_TYPE = 1;

Token.EOF = -1;

/**
 * All tokens go to the parser (unless skip() is called in that rule)
 * on a particular "channel". The parser tunes to a particular channel
 * so that whitespace etc... can go to the parser on a "hidden" channel.
 */
Token.DEFAULT_CHANNEL = 0;

/**
 * Anything on different channel than DEFAULT_CHANNEL is not parsed
 * by parser.
 */
Token.HIDDEN_CHANNEL = 1;

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function equalArrays(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b))
        return false;
    if (a === b)
        return true;
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] === b[i])
            continue;
        if (!a[i].equals || !a[i].equals(b[i]))
            return false;
    }
    return true;
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class HashCode {

    constructor() {
        this.count = 0;
        this.hash = 0;
    }

    update() {
        for(let i=0;i<arguments.length;i++) {
            const value = arguments[i];
            if (value == null)
                continue;
            if(Array.isArray(value))
                this.update.apply(this, value);
            else {
                let k = 0;
                switch (typeof(value)) {
                    case 'undefined':
                    case 'function':
                        continue;
                    case 'number':
                    case 'boolean':
                        k = value;
                        break;
                    case 'string':
                        k = value.hashCode();
                        break;
                    default:
                        if(value.updateHashCode)
                            value.updateHashCode(this);
                        else
                            console.log("No updateHashCode for " + value.toString());
                        continue;
                }
                k = k * 0xCC9E2D51;
                k = (k << 15) | (k >>> (32 - 15));
                k = k * 0x1B873593;
                this.count = this.count + 1;
                let hash = this.hash ^ k;
                hash = (hash << 13) | (hash >>> (32 - 13));
                hash = hash * 5 + 0xE6546B64;
                this.hash = hash;
            }
        }
    }

    finish() {
        let hash = this.hash ^ (this.count * 4);
        hash = hash ^ (hash >>> 16);
        hash = hash * 0x85EBCA6B;
        hash = hash ^ (hash >>> 13);
        hash = hash * 0xC2B2AE35;
        hash = hash ^ (hash >>> 16);
        return hash;
    }

    static hashStuff() {
        const hash = new HashCode();
        hash.update.apply(hash, arguments);
        return hash.finish();
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function standardHashCodeFunction(a) {
    return a ? a.hashCode() : -1;
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function standardEqualsFunction(a, b) {
    return a ? a.equals(b) : a===b;
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function valueToString(v) {
    return v === null ? "null" : v;
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function arrayToString(a) {
    return Array.isArray(a) ? ("[" + a.map(valueToString).join(", ") + "]") : "null";
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const HASH_KEY_PREFIX$1 = "h-";

class HashSet {

    constructor(hashFunction, equalsFunction) {
        this.data = {};
        this.hashFunction = hashFunction || standardHashCodeFunction;
        this.equalsFunction = equalsFunction || standardEqualsFunction;
    }

    add(value) {
        const key = HASH_KEY_PREFIX$1 + this.hashFunction(value);
        if (key in this.data) {
            const values = this.data[key];
            for (let i = 0; i < values.length; i++) {
                if (this.equalsFunction(value, values[i])) {
                    return values[i];
                }
            }
            values.push(value);
            return value;
        } else {
            this.data[key] = [value];
            return value;
        }
    }

    has(value) {
        return this.get(value) != null;
    }

    get(value) {
        const key = HASH_KEY_PREFIX$1 + this.hashFunction(value);
        if (key in this.data) {
            const values = this.data[key];
            for (let i = 0; i < values.length; i++) {
                if (this.equalsFunction(value, values[i])) {
                    return values[i];
                }
            }
        }
        return null;
    }

    values() {
        return Object.keys(this.data).filter(key => key.startsWith(HASH_KEY_PREFIX$1)).flatMap(key => this.data[key], this);
    }

    toString() {
        return arrayToString(this.values());
    }

    get length() {
        return Object.keys(this.data).filter(key => key.startsWith(HASH_KEY_PREFIX$1)).map(key => this.data[key].length, this).reduce((accum, item) => accum + item, 0);
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * A tree structure used to record the semantic context in which
 * an ATN configuration is valid.  It's either a single predicate,
 * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
 *
 * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
 * {@link SemanticContext} within the scope of this outer class.</p>
 */
class SemanticContext {

	hashCode() {
		const hash = new HashCode();
		this.updateHashCode(hash);
		return hash.finish();
	}

	/**
	 * For context independent predicates, we evaluate them without a local
	 * context (i.e., null context). That way, we can evaluate them without
	 * having to create proper rule-specific context during prediction (as
	 * opposed to the parser, which creates them naturally). In a practical
	 * sense, this avoids a cast exception from RuleContext to myruleContext.
	 *
	 * <p>For context dependent predicates, we must pass in a local context so that
	 * references such as $arg evaluate properly as _localctx.arg. We only
	 * capture context dependent predicates in the context in which we begin
	 * prediction, so we passed in the outer context here in case of context
	 * dependent predicate evaluation.</p>
	 */
	evaluate(parser, outerContext) {}

	/**
	 * Evaluate the precedence predicates for the context and reduce the result.
	 *
	 * @param parser The parser instance.
	 * @param outerContext The current parser context object.
	 * @return The simplified semantic context after precedence predicates are
	 * evaluated, which will be one of the following values.
	 * <ul>
	 * <li>{@link //NONE}: if the predicate simplifies to {@code true} after
	 * precedence predicates are evaluated.</li>
	 * <li>{@code null}: if the predicate simplifies to {@code false} after
	 * precedence predicates are evaluated.</li>
	 * <li>{@code this}: if the semantic context is not changed as a result of
	 * precedence predicate evaluation.</li>
	 * <li>A non-{@code null} {@link SemanticContext}: the new simplified
	 * semantic context after precedence predicates are evaluated.</li>
	 * </ul>
	 */
	evalPrecedence(parser, outerContext) {
		return this;
	}

	static andContext(a, b) {
		if (a === null || a === SemanticContext.NONE) {
			return b;
		}
		if (b === null || b === SemanticContext.NONE) {
			return a;
		}
		const result = new AND(a, b);
		if (result.opnds.length === 1) {
			return result.opnds[0];
		} else {
			return result;
		}
	}

	static orContext(a, b) {
		if (a === null) {
			return b;
		}
		if (b === null) {
			return a;
		}
		if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
			return SemanticContext.NONE;
		}
		const result = new OR(a, b);
		if (result.opnds.length === 1) {
			return result.opnds[0];
		} else {
			return result;
		}
	}
}



class AND extends SemanticContext {
	/**
	 * A semantic context which is true whenever none of the contained contexts
	 * is false
	 */
	constructor(a, b) {
		super();
		const operands = new HashSet();
		if (a instanceof AND) {
			a.opnds.map(function(o) {
				operands.add(o);
			});
		} else {
			operands.add(a);
		}
		if (b instanceof AND) {
			b.opnds.map(function(o) {
				operands.add(o);
			});
		} else {
			operands.add(b);
		}
		const precedencePredicates = filterPrecedencePredicates(operands);
		if (precedencePredicates.length > 0) {
			// interested in the transition with the lowest precedence
			let reduced = null;
			precedencePredicates.map( function(p) {
				if(reduced===null || p.precedence<reduced.precedence) {
					reduced = p;
				}
			});
			operands.add(reduced);
		}
		this.opnds = Array.from(operands.values());
	}

	equals(other) {
		if (this === other) {
			return true;
		} else if (!(other instanceof AND)) {
			return false;
		} else {
			return equalArrays(this.opnds, other.opnds);
		}
	}

	updateHashCode(hash) {
		hash.update(this.opnds, "AND");
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>
	 * The evaluation of predicates by this context is short-circuiting, but
	 * unordered.</p>
	 */
	evaluate(parser, outerContext) {
		for (let i = 0; i < this.opnds.length; i++) {
			if (!this.opnds[i].evaluate(parser, outerContext)) {
				return false;
			}
		}
		return true;
	}

	evalPrecedence(parser, outerContext) {
		let differs = false;
		const operands = [];
		for (let i = 0; i < this.opnds.length; i++) {
			const context = this.opnds[i];
			const evaluated = context.evalPrecedence(parser, outerContext);
			differs |= (evaluated !== context);
			if (evaluated === null) {
				// The AND context is false if any element is false
				return null;
			} else if (evaluated !== SemanticContext.NONE) {
				// Reduce the result by skipping true elements
				operands.push(evaluated);
			}
		}
		if (!differs) {
			return this;
		}
		if (operands.length === 0) {
			// all elements were true, so the AND context is true
			return SemanticContext.NONE;
		}
		let result = null;
		operands.map(function(o) {
			result = result === null ? o : SemanticContext.andContext(result, o);
		});
		return result;
	}

	toString() {
		const s = this.opnds.map(o => o.toString());
		return (s.length > 3 ? s.slice(3) : s).join("&&");
	}
}


class OR extends SemanticContext {
	/**
	 * A semantic context which is true whenever at least one of the contained
	 * contexts is true
	 */
	constructor(a, b) {
		super();
		const operands = new HashSet();
		if (a instanceof OR) {
			a.opnds.map(function(o) {
				operands.add(o);
			});
		} else {
			operands.add(a);
		}
		if (b instanceof OR) {
			b.opnds.map(function(o) {
				operands.add(o);
			});
		} else {
			operands.add(b);
		}

		const precedencePredicates = filterPrecedencePredicates(operands);
		if (precedencePredicates.length > 0) {
			// interested in the transition with the highest precedence
			const s = precedencePredicates.sort(function(a, b) {
				return a.compareTo(b);
			});
			const reduced = s[s.length-1];
			operands.add(reduced);
		}
		this.opnds = Array.from(operands.values());
	}

	equals(other) {
		if (this === other) {
			return true;
		} else if (!(other instanceof OR)) {
			return false;
		} else {
			return equalArrays(this.opnds, other.opnds);
		}
	}

	updateHashCode(hash) {
		hash.update(this.opnds, "OR");
	}

	/**
	 * <p>
	 * The evaluation of predicates by this context is short-circuiting, but
	 * unordered.</p>
	 */
	evaluate(parser, outerContext) {
		for (let i = 0; i < this.opnds.length; i++) {
			if (this.opnds[i].evaluate(parser, outerContext)) {
				return true;
			}
		}
		return false;
	}

	evalPrecedence(parser, outerContext) {
		let differs = false;
		const operands = [];
		for (let i = 0; i < this.opnds.length; i++) {
			const context = this.opnds[i];
			const evaluated = context.evalPrecedence(parser, outerContext);
			differs |= (evaluated !== context);
			if (evaluated === SemanticContext.NONE) {
				// The OR context is true if any element is true
				return SemanticContext.NONE;
			} else if (evaluated !== null) {
				// Reduce the result by skipping false elements
				operands.push(evaluated);
			}
		}
		if (!differs) {
			return this;
		}
		if (operands.length === 0) {
			// all elements were false, so the OR context is false
			return null;
		}
		const result = null;
		return result;
	}

	toString() {
		const s = this.opnds.map(o => o.toString());
		return (s.length > 3 ? s.slice(3) : s).join("||");
	}
}

function filterPrecedencePredicates(set) {
	const result = [];
	set.values().map( function(context) {
		if (context instanceof SemanticContext.PrecedencePredicate) {
			result.push(context);
		}
	});
	return result;
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function checkParams(params, isCfg) {
	if(params===null) {
		const result = { state:null, alt:null, context:null, semanticContext:null };
		if(isCfg) {
			result.reachesIntoOuterContext = 0;
		}
		return result;
	} else {
		const props = {};
		props.state = params.state || null;
		props.alt = (params.alt === undefined) ? null : params.alt;
		props.context = params.context || null;
		props.semanticContext = params.semanticContext || null;
		if(isCfg) {
			props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
			props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
		}
		return props;
	}
}

class ATNConfig {
    /**
     * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).
     * The syntactic context is a graph-structured stack node whose
     * path(s) to the root is the rule invocation(s)
     * chain used to arrive at the state.  The semantic context is
     * the tree of semantic predicates encountered before reaching
     * an ATN state
     */
    constructor(params, config) {
        this.checkContext(params, config);
        params = checkParams(params);
        config = checkParams(config, true);
        // The ATN state associated with this configuration///
        this.state = params.state!==null ? params.state : config.state;
        // What alt (or lexer rule) is predicted by this configuration///
        this.alt = params.alt!==null ? params.alt : config.alt;
        /**
         * The stack of invoking states leading to the rule/states associated
         * with this config.  We track only those contexts pushed during
         * execution of the ATN simulator
         */
        this.context = params.context!==null ? params.context : config.context;
        this.semanticContext = params.semanticContext!==null ? params.semanticContext :
            (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);
        // TODO: make it a boolean then
        /**
         * We cannot execute predicates dependent upon local context unless
         * we know for sure we are in the correct context. Because there is
         * no way to do this efficiently, we simply cannot evaluate
         * dependent predicates unless we are in the rule that initially
         * invokes the ATN simulator.
         * closure() tracks the depth of how far we dip into the
         * outer context: depth &gt; 0.  Note that it may not be totally
         * accurate depth since I don't ever decrement
         */
        this.reachesIntoOuterContext = config.reachesIntoOuterContext;
        this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
    }

    checkContext(params, config) {
        if((params.context===null || params.context===undefined) &&
                (config===null || config.context===null || config.context===undefined)) {
            this.context = null;
        }
    }

    hashCode() {
        const hash = new HashCode();
        this.updateHashCode(hash);
        return hash.finish();
    }

    updateHashCode(hash) {
        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
    }

    /**
     * An ATN configuration is equal to another if both have
     * the same state, they predict the same alternative, and
     * syntactic/semantic contexts are the same
     */
    equals(other) {
        if (this === other) {
            return true;
        } else if (! (other instanceof ATNConfig)) {
            return false;
        } else {
            return this.state.stateNumber===other.state.stateNumber &&
                this.alt===other.alt &&
                (this.context===null ? other.context===null : this.context.equals(other.context)) &&
                this.semanticContext.equals(other.semanticContext) &&
                this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;
        }
    }

    hashCodeForConfigSet() {
        const hash = new HashCode();
        hash.update(this.state.stateNumber, this.alt, this.semanticContext);
        return hash.finish();
    }

    equalsForConfigSet(other) {
        if (this === other) {
            return true;
        } else if (! (other instanceof ATNConfig)) {
            return false;
        } else {
            return this.state.stateNumber===other.state.stateNumber &&
                this.alt===other.alt &&
                this.semanticContext.equals(other.semanticContext);
        }
    }

    toString() {
        return "(" + this.state + "," + this.alt +
            (this.context!==null ? ",[" + this.context.toString() + "]" : "") +
            (this.semanticContext !== SemanticContext.NONE ?
                    ("," + this.semanticContext.toString())
                    : "") +
            (this.reachesIntoOuterContext>0 ?
                    (",up=" + this.reachesIntoOuterContext)
                    : "") + ")";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/* stop is not included! */
class Interval {

    constructor(start, stop) {
        this.start = start;
        this.stop = stop;
    }

    clone() {
        return new Interval(this.start, this.stop);
    }

    contains(item) {
        return item >= this.start && item < this.stop;
    }

    toString() {
        if(this.start===this.stop-1) {
            return this.start.toString();
        } else {
            return this.start.toString() + ".." + (this.stop-1).toString();
        }
    }

    get length(){
        return this.stop - this.start;
    }
}

Interval.INVALID_INTERVAL = new Interval(-1, -2);

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class IntervalSet {
	constructor() {
		this.intervals = null;
		this.readOnly = false;
	}

	first(v) {
		if (this.intervals === null || this.intervals.length===0) {
			return Token.INVALID_TYPE;
		} else {
			return this.intervals[0].start;
		}
	}

	addOne(v) {
		this.addInterval(new Interval(v, v + 1));
	}

	addRange(l, h) {
		this.addInterval(new Interval(l, h + 1));
	}

	addInterval(toAdd) {
		if (this.intervals === null) {
			this.intervals = [];
			this.intervals.push(toAdd.clone());
		} else {
			// find insert pos
			for (let pos = 0; pos < this.intervals.length; pos++) {
				const existing = this.intervals[pos];
				// distinct range -> insert
				if (toAdd.stop < existing.start) {
					this.intervals.splice(pos, 0, toAdd);
					return;
				}
				// contiguous range -> adjust
				else if (toAdd.stop === existing.start) {
					this.intervals[pos] = new Interval(toAdd.start, existing.stop);
					return;
				}
				// overlapping range -> adjust and reduce
				else if (toAdd.start <= existing.stop) {
					this.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));
					this.reduce(pos);
					return;
				}
			}
			// greater than any existing
			this.intervals.push(toAdd.clone());
		}
	}

	addSet(other) {
		if (other.intervals !== null) {
			other.intervals.forEach( toAdd => this.addInterval(toAdd), this);
		}
		return this;
	}

	reduce(pos) {
		// only need to reduce if pos is not the last
		if (pos < this.intervals.length - 1) {
			const current = this.intervals[pos];
			const next = this.intervals[pos + 1];
			// if next contained in current
			if (current.stop >= next.stop) {
				this.intervals.splice(pos + 1, 1);
				this.reduce(pos);
			} else if (current.stop >= next.start) {
				this.intervals[pos] = new Interval(current.start, next.stop);
				this.intervals.splice(pos + 1, 1);
			}
		}
	}

	complement(start, stop) {
		const result = new IntervalSet();
		result.addInterval(new Interval(start, stop + 1));
		if(this.intervals !== null)
			this.intervals.forEach(toRemove => result.removeRange(toRemove));
		return result;
	}

	contains(item) {
		if (this.intervals === null) {
			return false;
		} else {
			for (let k = 0; k < this.intervals.length; k++) {
				if(this.intervals[k].contains(item)) {
					return true;
				}
			}
			return false;
		}
	}

	removeRange(toRemove) {
		if(toRemove.start===toRemove.stop-1) {
			this.removeOne(toRemove.start);
		} else if (this.intervals !== null) {
			let pos = 0;
			for(let n=0; n<this.intervals.length; n++) {
				const existing = this.intervals[pos];
				// intervals are ordered
				if (toRemove.stop<=existing.start) {
					return;
				}
				// check for including range, split it
				else if(toRemove.start>existing.start && toRemove.stop<existing.stop) {
					this.intervals[pos] = new Interval(existing.start, toRemove.start);
					const x = new Interval(toRemove.stop, existing.stop);
					this.intervals.splice(pos, 0, x);
					return;
				}
				// check for included range, remove it
				else if(toRemove.start<=existing.start && toRemove.stop>=existing.stop) {
					this.intervals.splice(pos, 1);
					pos = pos - 1; // need another pass
				}
				// check for lower boundary
				else if(toRemove.start<existing.stop) {
					this.intervals[pos] = new Interval(existing.start, toRemove.start);
				}
				// check for upper boundary
				else if(toRemove.stop<existing.stop) {
					this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
				}
				pos += 1;
			}
		}
	}

	removeOne(value) {
		if (this.intervals !== null) {
			for (let i = 0; i < this.intervals.length; i++) {
				const existing = this.intervals[i];
				// intervals are ordered
				if (value < existing.start) {
					return;
				}
				// check for single value range
				else if (value === existing.start && value === existing.stop - 1) {
					this.intervals.splice(i, 1);
					return;
				}
				// check for lower boundary
				else if (value === existing.start) {
					this.intervals[i] = new Interval(existing.start + 1, existing.stop);
					return;
				}
				// check for upper boundary
				else if (value === existing.stop - 1) {
					this.intervals[i] = new Interval(existing.start, existing.stop - 1);
					return;
				}
				// split existing range
				else if (value < existing.stop - 1) {
					const replace = new Interval(existing.start, value);
					existing.start = value + 1;
					this.intervals.splice(i, 0, replace);
					return;
				}
			}
		}
	}

	toString(literalNames, symbolicNames, elemsAreChar) {
		literalNames = literalNames || null;
		symbolicNames = symbolicNames || null;
		elemsAreChar = elemsAreChar || false;
		if (this.intervals === null) {
			return "{}";
		} else if(literalNames!==null || symbolicNames!==null) {
			return this.toTokenString(literalNames, symbolicNames);
		} else if(elemsAreChar) {
			return this.toCharString();
		} else {
			return this.toIndexString();
		}
	}

	toCharString() {
		const names = [];
		for (let i = 0; i < this.intervals.length; i++) {
			const existing = this.intervals[i];
			if(existing.stop===existing.start+1) {
				if ( existing.start===Token.EOF ) {
					names.push("<EOF>");
				} else {
					names.push("'" + String.fromCharCode(existing.start) + "'");
				}
			} else {
				names.push("'" + String.fromCharCode(existing.start) + "'..'" + String.fromCharCode(existing.stop-1) + "'");
			}
		}
		if (names.length > 1) {
			return "{" + names.join(", ") + "}";
		} else {
			return names[0];
		}
	}

	toIndexString() {
		const names = [];
		for (let i = 0; i < this.intervals.length; i++) {
			const existing = this.intervals[i];
			if(existing.stop===existing.start+1) {
				if ( existing.start===Token.EOF ) {
					names.push("<EOF>");
				} else {
					names.push(existing.start.toString());
				}
			} else {
				names.push(existing.start.toString() + ".." + (existing.stop-1).toString());
			}
		}
		if (names.length > 1) {
			return "{" + names.join(", ") + "}";
		} else {
			return names[0];
		}
	}

	toTokenString(literalNames, symbolicNames) {
		const names = [];
		for (let i = 0; i < this.intervals.length; i++) {
			const existing = this.intervals[i];
			for (let j = existing.start; j < existing.stop; j++) {
				names.push(this.elementName(literalNames, symbolicNames, j));
			}
		}
		if (names.length > 1) {
			return "{" + names.join(", ") + "}";
		} else {
			return names[0];
		}
	}

	elementName(literalNames, symbolicNames, token) {
		if (token === Token.EOF) {
			return "<EOF>";
		} else if (token === Token.EPSILON) {
			return "<EPSILON>";
		} else {
			return literalNames[token] || symbolicNames[token];
		}
	}

	get length(){
		return this.intervals.map( interval => interval.length ).reduce((acc, val) => acc + val);
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The following images show the relation of states and
 * {@link ATNState//transitions} for various grammar constructs.
 *
 * <ul>
 *
 * <li>Solid edges marked with an &//0949; indicate a required
 * {@link EpsilonTransition}.</li>
 *
 * <li>Dashed edges indicate locations where any transition derived from
 * {@link Transition} might appear.</li>
 *
 * <li>Dashed nodes are place holders for either a sequence of linked
 * {@link BasicState} states or the inclusion of a block representing a nested
 * construct in one of the forms below.</li>
 *
 * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support
 * any number of alternatives (one or more). Nodes without the {@code ...} only
 * support the exact number of alternatives shown in the diagram.</li>
 *
 * </ul>
 *
 * <h2>Basic Blocks</h2>
 *
 * <h3>Rule</h3>
 *
 * <embed src="images/Rule.svg" type="image/svg+xml"/>
 *
 * <h3>Block of 1 or more alternatives</h3>
 *
 * <embed src="images/Block.svg" type="image/svg+xml"/>
 *
 * <h2>Greedy Loops</h2>
 *
 * <h3>Greedy Closure: {@code (...)*}</h3>
 *
 * <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Positive Closure: {@code (...)+}</h3>
 *
 * <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Optional: {@code (...)?}</h3>
 *
 * <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
 *
 * <h2>Non-Greedy Loops</h2>
 *
 * <h3>Non-Greedy Closure: {@code (...)*?}</h3>
 *
 * <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>
 *
 * <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Optional: {@code (...)??}</h3>
 *
 * <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
 */
class ATNState {
    constructor() {
        // Which ATN are we in?
        this.atn = null;
        this.stateNumber = ATNState.INVALID_STATE_NUMBER;
        this.stateType = null;
        this.ruleIndex = 0; // at runtime, we don't have Rule objects
        this.epsilonOnlyTransitions = false;
        // Track the transitions emanating from this ATN state.
        this.transitions = [];
        // Used to cache lookahead during parsing, not used during construction
        this.nextTokenWithinRule = null;
    }

    toString() {
        return this.stateNumber;
    }

    equals(other) {
        if (other instanceof ATNState) {
            return this.stateNumber===other.stateNumber;
        } else {
            return false;
        }
    }

    isNonGreedyExitState() {
        return false;
    }

    addTransition(trans, index) {
        if(index===undefined) {
            index = -1;
        }
        if (this.transitions.length===0) {
            this.epsilonOnlyTransitions = trans.isEpsilon;
        } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {
            this.epsilonOnlyTransitions = false;
        }
        if (index===-1) {
            this.transitions.push(trans);
        } else {
            this.transitions.splice(index, 1, trans);
        }
    }
}

// constants for serialization
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;

ATNState.serializationNames = [
            "INVALID",
            "BASIC",
            "RULE_START",
            "BLOCK_START",
            "PLUS_BLOCK_START",
            "STAR_BLOCK_START",
            "TOKEN_START",
            "RULE_STOP",
            "BLOCK_END",
            "STAR_LOOP_BACK",
            "STAR_LOOP_ENTRY",
            "PLUS_LOOP_BACK",
            "LOOP_END" ];

ATNState.INVALID_STATE_NUMBER = -1;

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The last node in the ATN for a rule, unless that rule is the start symbol.
 * In that case, there is one transition to EOF. Later, we might encode
 * references to all calls to this rule to compute FOLLOW sets for
 * error handling
 */
class RuleStopState extends ATNState {
    constructor() {
        super();
        this.stateType = ATNState.RULE_STOP;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * An ATN transition between any two ATN states.  Subclasses define
 * atom, set, epsilon, action, predicate, rule transitions.
 *
 * <p>This is a one way link.  It emanates from a state (usually via a list of
 * transitions) and has a target state.</p>
 *
 * <p>Since we never have to change the ATN transitions once we construct it,
 * we can fix these transitions as specific classes. The DFA transitions
 * on the other hand need to update the labels as it adds transitions to
 * the states. We'll use the term Edge for the DFA to distinguish them from
 * ATN transitions.</p>
 */
class Transition {
    constructor(target) {
        // The target of this transition.
        if (target===undefined || target===null) {
            throw "target cannot be null.";
        }
        this.target = target;
        // Are we epsilon, action, sempred?
        this.isEpsilon = false;
        this.label = null;
    }
}

// constants for serialization

Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
// e.g., {isType(input.LT(1))}?
Transition.PREDICATE = 4;
Transition.ATOM = 5;
Transition.ACTION = 6;
// ~(A|B) or ~atom, wildcard, which convert to next 2
Transition.SET = 7;
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;

Transition.serializationNames = [
            "INVALID",
            "EPSILON",
            "RANGE",
            "RULE",
            "PREDICATE",
            "ATOM",
            "ACTION",
            "SET",
            "NOT_SET",
            "WILDCARD",
            "PRECEDENCE"
        ];

Transition.serializationTypes = {
        EpsilonTransition: Transition.EPSILON,
        RangeTransition: Transition.RANGE,
        RuleTransition: Transition.RULE,
        PredicateTransition: Transition.PREDICATE,
        AtomTransition: Transition.ATOM,
        ActionTransition: Transition.ACTION,
        SetTransition: Transition.SET,
        NotSetTransition: Transition.NOT_SET,
        WildcardTransition: Transition.WILDCARD,
        PrecedencePredicateTransition: Transition.PRECEDENCE
    };

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class RuleTransition extends Transition {
    constructor(ruleStart, ruleIndex, precedence, followState) {
        super(ruleStart);
        // ptr to the rule definition object for this rule ref
        this.ruleIndex = ruleIndex;
        this.precedence = precedence;
        // what node to begin computations following ref to rule
        this.followState = followState;
        this.serializationType = Transition.RULE;
        this.isEpsilon = true;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class SetTransition extends Transition {
    constructor(target, set) {
        super(target);
        this.serializationType = Transition.SET;
        if (set !==undefined && set !==null) {
            this.label = set;
        } else {
            this.label = new IntervalSet();
            this.label.addOne(Token.INVALID_TYPE);
        }
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this.label.contains(symbol);
    }

    toString() {
        return this.label.toString();
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class NotSetTransition extends SetTransition {
    constructor(target, set) {
        super(target, set);
        this.serializationType = Transition.NOT_SET;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&
            !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
    }

    toString() {
        return '~' + super.toString();
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class WildcardTransition extends Transition {
    constructor(target) {
        super(target);
        this.serializationType = Transition.WILDCARD;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
    }

    toString() {
        return ".";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class AbstractPredicateTransition extends Transition {
    constructor(target) {
        super(target);
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The basic notion of a tree has a parent, a payload, and a list of children.
 * It is the most abstract interface for all the trees used by ANTLR.
 */
class Tree {}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class SyntaxTree extends Tree {
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ParseTree extends SyntaxTree {
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class RuleNode extends ParseTree {

    getRuleContext(){
        throw new Error("missing interface implementation")
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class TerminalNode extends ParseTree {
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ErrorNode extends TerminalNode {
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function escapeWhitespace(s, escapeSpaces) {
    s = s.replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r");
    if (escapeSpaces) {
        s = s.replace(/ /g, "\u00B7");
    }
    return s;
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/** A set of utility routines useful for all kinds of ANTLR trees. */
const Trees = {
    /**
     * Print out a whole tree in LISP form. {@link //getNodeText} is used on the
     *  node payloads to get the text for the nodes.  Detect
     *  parse trees and extract data appropriately.
     */
    toStringTree: function(tree, ruleNames, recog) {
        ruleNames = ruleNames || null;
        recog = recog || null;
        if(recog!==null) {
            ruleNames = recog.ruleNames;
        }
        let s = Trees.getNodeText(tree, ruleNames);
        s = escapeWhitespace(s, false);
        const c = tree.getChildCount();
        if(c===0) {
            return s;
        }
        let res = "(" + s + ' ';
        if(c>0) {
            s = Trees.toStringTree(tree.getChild(0), ruleNames);
            res = res.concat(s);
        }
        for(let i=1;i<c;i++) {
            s = Trees.toStringTree(tree.getChild(i), ruleNames);
            res = res.concat(' ' + s);
        }
        res = res.concat(")");
        return res;
    },

    getNodeText: function(t, ruleNames, recog) {
        ruleNames = ruleNames || null;
        recog = recog || null;
        if(recog!==null) {
            ruleNames = recog.ruleNames;
        }
        if(ruleNames!==null) {
            if (t instanceof RuleNode) {
                const context = t.getRuleContext();
                const altNumber = context.getAltNumber();
                // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency
                if ( altNumber != 0 ) {
                    return ruleNames[t.ruleIndex]+":"+altNumber;
                }
                return ruleNames[t.ruleIndex];
            } else if ( t instanceof ErrorNode) {
                return t.toString();
            } else if(t instanceof TerminalNode) {
                if(t.symbol!==null) {
                    return t.symbol.text;
                }
            }
        }
        // no recog for rule names
        const payload = t.getPayload();
        if (payload instanceof Token ) {
            return payload.text;
        }
        return t.getPayload().toString();
    },

    /**
     * Return ordered list of all children of this node
     */
    getChildren: function(t) {
        const list = [];
        for(let i=0;i<t.getChildCount();i++) {
            list.push(t.getChild(i));
        }
        return list;
    },

    /**
     * Return a list of all ancestors of this node.  The first node of
     * list is the root and the last is the parent of this node.
     */
    getAncestors: function(t) {
        let ancestors = [];
        t = t.getParent();
        while(t!==null) {
            ancestors = [t].concat(ancestors);
            t = t.getParent();
        }
        return ancestors;
    },

    findAllTokenNodes: function(t, ttype) {
        return Trees.findAllNodes(t, ttype, true);
    },

    findAllRuleNodes: function(t, ruleIndex) {
        return Trees.findAllNodes(t, ruleIndex, false);
    },

    findAllNodes: function(t, index, findTokens) {
        const nodes = [];
        Trees._findAllNodes(t, index, findTokens, nodes);
        return nodes;
    },

    _findAllNodes: function(t, index, findTokens, nodes) {
        // check this node (the root) first
        if(findTokens && (t instanceof TerminalNode)) {
            if(t.symbol.type===index) {
                nodes.push(t);
            }
        } else if(!findTokens && (t instanceof RuleNode)) {
            if(t.ruleIndex===index) {
                nodes.push(t);
            }
        }
        // check children
        for(let i=0;i<t.getChildCount();i++) {
            Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
        }
    },

    descendants: function(t) {
        let nodes = [t];
        for(let i=0;i<t.getChildCount();i++) {
            nodes = nodes.concat(Trees.descendants(t.getChild(i)));
        }
        return nodes;
    }
};

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class RuleContext extends RuleNode {
    /** A rule context is a record of a single rule invocation. It knows
     * which context invoked it, if any. If there is no parent context, then
     * naturally the invoking state is not valid.  The parent link
     * provides a chain upwards from the current rule invocation to the root
     * of the invocation tree, forming a stack. We actually carry no
     * information about the rule associated with this context (except
     * when parsing). We keep only the state number of the invoking state from
     * the ATN submachine that invoked this. Contrast this with the s
     * pointer inside ParserRuleContext that tracks the current state
     * being "executed" for the current rule.
     *
     * The parent contexts are useful for computing lookahead sets and
     * getting error information.
     *
     * These objects are used during parsing and prediction.
     * For the special case of parsers, we use the subclass
     * ParserRuleContext.
     *
     * @see ParserRuleContext
     */
    constructor(parent, invokingState) {
        // What context invoked this rule?
        super();
        this.parentCtx = parent || null;
        /**
         * What state invoked the rule associated with this context?
         * The "return address" is the followState of invokingState
         * If parent is null, this should be -1.
         */
        this.invokingState = invokingState || -1;
    }

    depth() {
        let n = 0;
        let p = this;
        while (p !== null) {
            p = p.parentCtx;
            n += 1;
        }
        return n;
    }

    /**
     * A context is empty if there is no invoking state; meaning nobody call
     * current context.
     */
    isEmpty() {
        return this.invokingState === -1;
    }

// satisfy the ParseTree / SyntaxTree interface
    getSourceInterval() {
        return Interval.INVALID_INTERVAL;
    }

    getRuleContext() {
        return this;
    }

    getPayload() {
        return this;
    }

    /**
     * Return the combined text of all child nodes. This method only considers
     * tokens which have been added to the parse tree.
     * <p>
     * Since tokens on hidden channels (e.g. whitespace or comments) are not
     * added to the parse trees, they will not appear in the output of this
     * method.
     */
    getText() {
        if (this.getChildCount() === 0) {
            return "";
        } else {
            return this.children.map(function (child) {
                return child.getText();
            }).join("");
        }
    }

    /**
     * For rule associated with this parse tree internal node, return
     * the outer alternative number used to match the input. Default
     * implementation does not compute nor store this alt num. Create
     * a subclass of ParserRuleContext with backing field and set
     * option contextSuperClass.
     * to set it.
     */
    getAltNumber() {
        // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency
        return 0;
    }

    /**
     * Set the outer alternative number for this context node. Default
     * implementation does nothing to avoid backing field overhead for
     * trees that don't need it.  Create
     * a subclass of ParserRuleContext with backing field and set
     * option contextSuperClass.
     */
    setAltNumber(altNumber) {
    }

    getChild(i) {
        return null;
    }

    getChildCount() {
        return 0;
    }

    accept(visitor) {
        return visitor.visitChildren(this);
    }

    /**
     * Print out a whole tree, not just a node, in LISP format
     * (root child1 .. childN). Print just a node if this is a leaf.
     */
    toStringTree(ruleNames, recog) {
        return Trees.toStringTree(this, ruleNames, recog);
    }

    toString(ruleNames, stop) {
        ruleNames = ruleNames || null;
        stop = stop || null;
        let p = this;
        let s = "[";
        while (p !== null && p !== stop) {
            if (ruleNames === null) {
                if (!p.isEmpty()) {
                    s += p.invokingState;
                }
            } else {
                const ri = p.ruleIndex;
                const ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]
                    : "" + ri;
                s += ruleName;
            }
            if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
                s += " ";
            }
            p = p.parentCtx;
        }
        s += "]";
        return s;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class PredictionContext {

	constructor(cachedHashCode) {
		this.cachedHashCode = cachedHashCode;
	}

	/**
	 * Stores the computed hash code of this {@link PredictionContext}. The hash
	 * code is computed in parts to match the following reference algorithm.
	 *
	 * <pre>
	 * private int referenceHashCode() {
	 * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
	 * //INITIAL_HASH});
	 *
	 * for (int i = 0; i &lt; {@link //size()}; i++) {
	 * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
	 * getParent}(i));
	 * }
	 *
	 * for (int i = 0; i &lt; {@link //size()}; i++) {
	 * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
	 * //getReturnState getReturnState}(i));
	 * }
	 *
	 * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
	 * //size()});
	 * return hash;
	 * }
	 * </pre>
	 * This means only the {@link //EMPTY} context is in set.
	 */
	isEmpty() {
		return this === PredictionContext.EMPTY;
	}

	hasEmptyPath() {
		return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
	}

	hashCode() {
		return this.cachedHashCode;
	}

	updateHashCode(hash) {
		hash.update(this.cachedHashCode);
	}
}

/**
 * Represents {@code $} in local context prediction, which means wildcard.
 * {@code//+x =//}.
 */
PredictionContext.EMPTY = null;

/**
 * Represents {@code $} in an array in full context mode, when {@code $}
 * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
 * {@code $} = {@link //EMPTY_RETURN_STATE}.
 */
PredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;

PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ArrayPredictionContext extends PredictionContext {

    constructor(parents, returnStates) {
        /**
         * Parent can be null only if full ctx mode and we make an array
         * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
         * null parent and
         * returnState == {@link //EMPTY_RETURN_STATE}.
         */
        const h = new HashCode();
        h.update(parents, returnStates);
        const hashCode = h.finish();
        super(hashCode);
        this.parents = parents;
        this.returnStates = returnStates;
        return this;
    }

    isEmpty() {
        // since EMPTY_RETURN_STATE can only appear in the last position, we
        // don't need to verify that size==1
        return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
    }

    getParent(index) {
        return this.parents[index];
    }

    getReturnState(index) {
        return this.returnStates[index];
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (!(other instanceof ArrayPredictionContext)) {
            return false;
        } else if (this.hashCode() !== other.hashCode()) {
            return false; // can't be same if hash is different
        } else {
            return equalArrays(this.returnStates, other.returnStates) &&
                equalArrays(this.parents, other.parents);
        }
    }

    toString() {
        if (this.isEmpty()) {
            return "[]";
        } else {
            let s = "[";
            for (let i = 0; i < this.returnStates.length; i++) {
                if (i > 0) {
                    s = s + ", ";
                }
                if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
                    s = s + "$";
                    continue;
                }
                s = s + this.returnStates[i];
                if (this.parents[i] !== null) {
                    s = s + " " + this.parents[i];
                } else {
                    s = s + "null";
                }
            }
            return s + "]";
        }
    }

    get length(){
        return this.returnStates.length;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class SingletonPredictionContext extends PredictionContext {

    constructor(parent, returnState) {
        let hashCode = 0;
        const hash = new HashCode();
        if(parent !== null) {
            hash.update(parent, returnState);
        } else {
            hash.update(1);
        }
        hashCode = hash.finish();
        super(hashCode);
        this.parentCtx = parent;
        this.returnState = returnState;
    }

    getParent(index) {
        return this.parentCtx;
    }

    getReturnState(index) {
        return this.returnState;
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (!(other instanceof SingletonPredictionContext)) {
            return false;
        } else if (this.hashCode() !== other.hashCode()) {
            return false; // can't be same if hash is different
        } else {
            if(this.returnState !== other.returnState)
                return false;
            else if(this.parentCtx==null)
                return other.parentCtx==null
            else
                return this.parentCtx.equals(other.parentCtx);
        }
    }

    toString() {
        const up = this.parentCtx === null ? "" : this.parentCtx.toString();
        if (up.length === 0) {
            if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
                return "$";
            } else {
                return "" + this.returnState;
            }
        } else {
            return "" + this.returnState + " " + up;
        }
    }

    get length(){
        return 1;
    }

    static create(parent, returnState) {
        if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
            // someone can pass in the bits of an array ctx that mean $
            return PredictionContext.EMPTY;
        } else {
            return new SingletonPredictionContext(parent, returnState);
        }
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class EmptyPredictionContext extends SingletonPredictionContext {

    constructor() {
        super(null, PredictionContext.EMPTY_RETURN_STATE);
    }

    isEmpty() {
        return true;
    }

    getParent(index) {
        return null;
    }

    getReturnState(index) {
        return this.returnState;
    }

    equals(other) {
        return this === other;
    }

    toString() {
        return "$";
    }
}


PredictionContext.EMPTY = new EmptyPredictionContext();

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const HASH_KEY_PREFIX = "h-";

class HashMap {

    constructor(hashFunction, equalsFunction) {
        this.data = {};
        this.hashFunction = hashFunction || standardHashCodeFunction;
        this.equalsFunction = equalsFunction || standardEqualsFunction;
    }

    set(key, value) {
        const hashKey = HASH_KEY_PREFIX + this.hashFunction(key);
        if (hashKey in this.data) {
            const entries = this.data[hashKey];
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                if (this.equalsFunction(key, entry.key)) {
                    const oldValue = entry.value;
                    entry.value = value;
                    return oldValue;
                }
            }
            entries.push({key:key, value:value});
            return value;
        } else {
            this.data[hashKey] = [{key:key, value:value}];
            return value;
        }
    }

    containsKey(key) {
        const hashKey = HASH_KEY_PREFIX + this.hashFunction(key);
        if(hashKey in this.data) {
            const entries = this.data[hashKey];
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                if (this.equalsFunction(key, entry.key))
                    return true;
            }
        }
        return false;
    }

    get(key) {
        const hashKey = HASH_KEY_PREFIX + this.hashFunction(key);
        if(hashKey in this.data) {
            const entries = this.data[hashKey];
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                if (this.equalsFunction(key, entry.key))
                    return entry.value;
            }
        }
        return null;
    }

    entries() {
        return Object.keys(this.data).filter(key => key.startsWith(HASH_KEY_PREFIX)).flatMap(key => this.data[key], this);
    }

    getKeys() {
        return this.entries().map(e => e.key);
    }

    getValues() {
        return this.entries().map(e => e.value);
    }

    toString() {
        const ss = this.entries().map(e => '{' + e.key + ':' + e.value + '}');
        return '[' + ss.join(", ") + ']';
    }

    get length() {
        return Object.keys(this.data).filter(key => key.startsWith(HASH_KEY_PREFIX)).map(key => this.data[key].length, this).reduce((accum, item) => accum + item, 0);
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
 * Return {@link //EMPTY} if {@code outerContext} is empty or null.
 */
function predictionContextFromRuleContext(atn, outerContext) {
    if (outerContext === undefined || outerContext === null) {
        outerContext = RuleContext.EMPTY;
    }
    // if we are in RuleContext of start rule, s, then PredictionContext
    // is EMPTY. Nobody called us. (if we are empty, return empty)
    if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
        return PredictionContext.EMPTY;
    }
    // If we have a parent, convert it to a PredictionContext graph
    const parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
    const state = atn.states[outerContext.invokingState];
    const transition = state.transitions[0];
    return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}


function getCachedPredictionContext(context, contextCache, visited) {
    if (context.isEmpty()) {
        return context;
    }
    let existing = visited.get(context) || null;
    if (existing !== null) {
        return existing;
    }
    existing = contextCache.get(context);
    if (existing !== null) {
        visited.set(context, existing);
        return existing;
    }
    let changed = false;
    let parents = [];
    for (let i = 0; i < parents.length; i++) {
        const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
        if (changed || parent !== context.getParent(i)) {
            if (!changed) {
                parents = [];
                for (let j = 0; j < context.length; j++) {
                    parents[j] = context.getParent(j);
                }
                changed = true;
            }
            parents[i] = parent;
        }
    }
    if (!changed) {
        contextCache.add(context);
        visited.set(context, context);
        return context;
    }
    let updated = null;
    if (parents.length === 0) {
        updated = PredictionContext.EMPTY;
    } else if (parents.length === 1) {
        updated = SingletonPredictionContext.create(parents[0], context
            .getReturnState(0));
    } else {
        updated = new ArrayPredictionContext(parents, context.returnStates);
    }
    contextCache.add(updated);
    visited.set(updated, updated);
    visited.set(context, updated);

    return updated;
}

function merge(a, b, rootIsWildcard, mergeCache) {
    // share same graph if both same
    if (a === b) {
        return a;
    }
    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
        return mergeSingletons(a, b, rootIsWildcard, mergeCache);
    }
    // At least one of a or b is array
    // If one is $ and rootIsWildcard, return $ as// wildcard
    if (rootIsWildcard) {
        if (a instanceof EmptyPredictionContext) {
            return a;
        }
        if (b instanceof EmptyPredictionContext) {
            return b;
        }
    }
    // convert singleton so both are arrays to normalize
    if (a instanceof SingletonPredictionContext) {
        a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
    }
    if (b instanceof SingletonPredictionContext) {
        b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
    }
    return mergeArrays(a, b, rootIsWildcard, mergeCache);
}


/**
 * Merge two {@link ArrayPredictionContext} instances.
 *
 * <p>Different tops, different parents.<br>
 * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, same parents.<br>
 * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, different parents.<br>
 * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, all shared parents.<br>
 * <embed src="images/ArrayMerge_ShareTopSharePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Equal tops, merge parents and reduce top to
 * {@link SingletonPredictionContext}.<br>
 * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
 */
function mergeArrays(a, b, rootIsWildcard, mergeCache) {
    if (mergeCache !== null) {
        let previous = mergeCache.get(a, b);
        if (previous !== null) {
            return previous;
        }
        previous = mergeCache.get(b, a);
        if (previous !== null) {
            return previous;
        }
    }
    // merge sorted payloads a + b => M
    let i = 0; // walks a
    let j = 0; // walks b
    let k = 0; // walks target M array

    let mergedReturnStates = [];
    let mergedParents = [];
    // walk and merge to yield mergedParents, mergedReturnStates
    while (i < a.returnStates.length && j < b.returnStates.length) {
        const a_parent = a.parents[i];
        const b_parent = b.parents[j];
        if (a.returnStates[i] === b.returnStates[j]) {
            // same payload (stack tops are equal), must yield merged singleton
            const payload = a.returnStates[i];
            // $+$ = $
            const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&
                a_parent === null && b_parent === null;
            const ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax
            // ->
            // ax
            if (bothDollars || ax_ax) {
                mergedParents[k] = a_parent; // choose left
                mergedReturnStates[k] = payload;
            } else { // ax+ay -> a'[x,y]
                mergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                mergedReturnStates[k] = payload;
            }
            i += 1; // hop over left one as usual
            j += 1; // but also skip one in right side since we merge
        } else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M
            mergedParents[k] = a_parent;
            mergedReturnStates[k] = a.returnStates[i];
            i += 1;
        } else { // b > a, copy b[j] to M
            mergedParents[k] = b_parent;
            mergedReturnStates[k] = b.returnStates[j];
            j += 1;
        }
        k += 1;
    }
    // copy over any payloads remaining in either array
    if (i < a.returnStates.length) {
        for (let p = i; p < a.returnStates.length; p++) {
            mergedParents[k] = a.parents[p];
            mergedReturnStates[k] = a.returnStates[p];
            k += 1;
        }
    } else {
        for (let p = j; p < b.returnStates.length; p++) {
            mergedParents[k] = b.parents[p];
            mergedReturnStates[k] = b.returnStates[p];
            k += 1;
        }
    }
    // trim merged if we combined a few that had same stack tops
    if (k < mergedParents.length) { // write index < last position; trim
        if (k === 1) { // for just one merged element, return singleton top
            const a_ = SingletonPredictionContext.create(mergedParents[0],
                mergedReturnStates[0]);
            if (mergeCache !== null) {
                mergeCache.set(a, b, a_);
            }
            return a_;
        }
        mergedParents = mergedParents.slice(0, k);
        mergedReturnStates = mergedReturnStates.slice(0, k);
    }

    const M = new ArrayPredictionContext(mergedParents, mergedReturnStates);

    // if we created same array as a or b, return that instead
    // TODO: track whether this is possible above during merge sort for speed
    if (M === a) {
        if (mergeCache !== null) {
            mergeCache.set(a, b, a);
        }
        return a;
    }
    if (M === b) {
        if (mergeCache !== null) {
            mergeCache.set(a, b, b);
        }
        return b;
    }
    combineCommonParents(mergedParents);

    if (mergeCache !== null) {
        mergeCache.set(a, b, M);
    }
    return M;
}


/**
 * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
 * ones.
 */
function combineCommonParents(parents) {
    const uniqueParents = new HashMap();

    for (let p = 0; p < parents.length; p++) {
        const parent = parents[p];
        if (!(uniqueParents.containsKey(parent))) {
            uniqueParents.set(parent, parent);
        }
    }
    for (let q = 0; q < parents.length; q++) {
        parents[q] = uniqueParents.get(parents[q]);
    }
}


/**
 * Merge two {@link SingletonPredictionContext} instances.
 *
 * <p>Stack tops equal, parents merge is same; return left graph.<br>
 * <embed src="images/SingletonMerge_SameRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Same stack top, parents differ; merge parents giving array node, then
 * remainders of those graphs. A new root node is created to point to the
 * merged parents.<br>
 * <embed src="images/SingletonMerge_SameRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to same parent. Make array node for the
 * root where both element in the root point to the same (original)
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to different parents. Make array node for
 * the root where each element points to the corresponding original
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 * @param mergeCache
 */
function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
    if (mergeCache !== null) {
        let previous = mergeCache.get(a, b);
        if (previous !== null) {
            return previous;
        }
        previous = mergeCache.get(b, a);
        if (previous !== null) {
            return previous;
        }
    }

    const rootMerge = mergeRoot(a, b, rootIsWildcard);
    if (rootMerge !== null) {
        if (mergeCache !== null) {
            mergeCache.set(a, b, rootMerge);
        }
        return rootMerge;
    }
    if (a.returnState === b.returnState) {
        const parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
        // if parent is same as existing a or b parent or reduced to a parent,
        // return it
        if (parent === a.parentCtx) {
            return a; // ax + bx = ax, if a=b
        }
        if (parent === b.parentCtx) {
            return b; // ax + bx = bx, if a=b
        }
        // else: ax + ay = a'[x,y]
        // merge parents x and y, giving array node with x,y then remainders
        // of those graphs. dup a, a' points at merged array
        // new joined parent so create new singleton pointing to it, a'
        const spc = SingletonPredictionContext.create(parent, a.returnState);
        if (mergeCache !== null) {
            mergeCache.set(a, b, spc);
        }
        return spc;
    } else { // a != b payloads differ
        // see if we can collapse parents due to $+x parents if local ctx
        let singleParent = null;
        if (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +
            // bx =
            // [a,b]x
            singleParent = a.parentCtx;
        }
        if (singleParent !== null) { // parents are same
            // sort payloads and use same parent
            const payloads = [ a.returnState, b.returnState ];
            if (a.returnState > b.returnState) {
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
            }
            const parents = [ singleParent, singleParent ];
            const apc = new ArrayPredictionContext(parents, payloads);
            if (mergeCache !== null) {
                mergeCache.set(a, b, apc);
            }
            return apc;
        }
        // parents differ and can't merge them. Just pack together
        // into array; can't merge.
        // ax + by = [ax,by]
        const payloads = [ a.returnState, b.returnState ];
        let parents = [ a.parentCtx, b.parentCtx ];
        if (a.returnState > b.returnState) { // sort by payload
            payloads[0] = b.returnState;
            payloads[1] = a.returnState;
            parents = [ b.parentCtx, a.parentCtx ];
        }
        const a_ = new ArrayPredictionContext(parents, payloads);
        if (mergeCache !== null) {
            mergeCache.set(a, b, a_);
        }
        return a_;
    }
}


/**
 * Handle case where at least one of {@code a} or {@code b} is
 * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
 * to represent {@link //EMPTY}.
 *
 * <h2>Local-Context Merges</h2>
 *
 * <p>These local-context merge operations are used when {@code rootIsWildcard}
 * is true.</p>
 *
 * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>
 * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
 * {@code //EMPTY}; return left graph.<br>
 * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
 *
 * <p>Special case of last merge if local context.<br>
 * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
 *
 * <h2>Full-Context Merges</h2>
 *
 * <p>These full-context merge operations are used when {@code rootIsWildcard}
 * is false.</p>
 *
 * <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
 *
 * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and
 * null parent).<br>
 * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 */
function mergeRoot(a, b, rootIsWildcard) {
    if (rootIsWildcard) {
        if (a === PredictionContext.EMPTY) {
            return PredictionContext.EMPTY; // // + b =//
        }
        if (b === PredictionContext.EMPTY) {
            return PredictionContext.EMPTY; // a +// =//
        }
    } else {
        if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
            return PredictionContext.EMPTY; // $ + $ = $
        } else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]
            const payloads = [ b.returnState,
                PredictionContext.EMPTY_RETURN_STATE ];
            const parents = [ b.parentCtx, null ];
            return new ArrayPredictionContext(parents, payloads);
        } else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)
            const payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];
            const parents = [ a.parentCtx, null ];
            return new ArrayPredictionContext(parents, payloads);
        }
    }
    return null;
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class BitSet {

    constructor() {
        this.data = [];
    }

    add(value) {
        this.data[value] = true;
    }

    or(set) {
        Object.keys(set.data).map(alt => this.add(alt), this);
    }

    remove(value) {
        delete this.data[value];
    }

    has(value) {
        return this.data[value] === true;
    }

    values() {
        return Object.keys(this.data);
    }

    minValue() {
        return Math.min.apply(null, this.values());
    }

    hashCode() {
        return HashCode.hashStuff(this.values());
    }

    equals(other) {
        return other instanceof BitSet && equalArrays(this.data, other.data);
    }

    toString() {
        return "{" + this.values().join(", ") + "}";
    }

    get length(){
        return this.values().length;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class LL1Analyzer {
    constructor(atn) {
        this.atn = atn;
    }

    /**
     * Calculates the SLL(1) expected lookahead set for each outgoing transition
     * of an {@link ATNState}. The returned array has one element for each
     * outgoing transition in {@code s}. If the closure from transition
     * <em>i</em> leads to a semantic predicate before matching a symbol, the
     * element at index <em>i</em> of the result will be {@code null}.
     *
     * @param s the ATN state
     * @return the expected symbols for each outgoing transition of {@code s}.
     */
    getDecisionLookahead(s) {
        if (s === null) {
            return null;
        }
        const count = s.transitions.length;
        const look = [];
        for(let alt=0; alt< count; alt++) {
            look[alt] = new IntervalSet();
            const lookBusy = new HashSet();
            const seeThruPreds = false; // fail to get lookahead upon pred
            this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,
                  look[alt], lookBusy, new BitSet(), seeThruPreds, false);
            // Wipe out lookahead for this alternative if we found nothing
            // or we had a predicate when we !seeThruPreds
            if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
                look[alt] = null;
            }
        }
        return look;
    }

    /**
     * Compute set of tokens that can follow {@code s} in the ATN in the
     * specified {@code ctx}.
     *
     * <p>If {@code ctx} is {@code null} and the end of the rule containing
     * {@code s} is reached, {@link Token//EPSILON} is added to the result set.
     * If {@code ctx} is not {@code null} and the end of the outermost rule is
     * reached, {@link Token//EOF} is added to the result set.</p>
     *
     * @param s the ATN state
     * @param stopState the ATN state to stop at. This can be a
     * {@link BlockEndState} to detect epsilon paths through a closure.
     * @param ctx the complete parser context, or {@code null} if the context
     * should be ignored
     *
     * @return The set of tokens that can follow {@code s} in the ATN in the
     * specified {@code ctx}.
     */
    LOOK(s, stopState, ctx) {
        const r = new IntervalSet();
        const seeThruPreds = true; // ignore preds; get all lookahead
        ctx = ctx || null;
        const lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;
        this._LOOK(s, stopState, lookContext, r, new HashSet(), new BitSet(), seeThruPreds, true);
        return r;
    }

    /**
     * Compute set of tokens that can follow {@code s} in the ATN in the
     * specified {@code ctx}.
     *
     * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
     * rule containing {@code s} is reached, {@link Token//EPSILON} is added to
     * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
     * {@code true} and {@code stopState} or the end of the outermost rule is
     * reached, {@link Token//EOF} is added to the result set.</p>
     *
     * @param s the ATN state.
     * @param stopState the ATN state to stop at. This can be a
     * {@link BlockEndState} to detect epsilon paths through a closure.
     * @param ctx The outer context, or {@code null} if the outer context should
     * not be used.
     * @param look The result lookahead set.
     * @param lookBusy A set used for preventing epsilon closures in the ATN
     * from causing a stack overflow. Outside code should pass
     * {@code new CustomizedSet<ATNConfig>} for this argument.
     * @param calledRuleStack A set used for preventing left recursion in the
     * ATN from causing a stack overflow. Outside code should pass
     * {@code new BitSet()} for this argument.
     * @param seeThruPreds {@code true} to true semantic predicates as
     * implicitly {@code true} and "see through them", otherwise {@code false}
     * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
     * result if one is encountered.
     * @param addEOF Add {@link Token//EOF} to the result if the end of the
     * outermost context is reached. This parameter has no effect if {@code ctx}
     * is {@code null}.
     */
    _LOOK(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
        const c = new ATNConfig({state:s, alt:0, context: ctx}, null);
        if (lookBusy.has(c)) {
            return;
        }
        lookBusy.add(c);
        if (s === stopState) {
            if (ctx ===null) {
                look.addOne(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
                look.addOne(Token.EOF);
                return;
            }
        }
        if (s instanceof RuleStopState ) {
            if (ctx ===null) {
                look.addOne(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
                look.addOne(Token.EOF);
                return;
            }
            if (ctx !== PredictionContext.EMPTY) {
                const removed = calledRuleStack.has(s.ruleIndex);
                try {
                    calledRuleStack.remove(s.ruleIndex);
                    // run thru all possible stack tops in ctx
                    for (let i = 0; i < ctx.length; i++) {
                        const returnState = this.atn.states[ctx.getReturnState(i)];
                        this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                    }
                }finally {
                    if (removed) {
                        calledRuleStack.add(s.ruleIndex);
                    }
                }
                return;
            }
        }
        for(let j=0; j<s.transitions.length; j++) {
            const t = s.transitions[j];
            if (t.constructor === RuleTransition) {
                if (calledRuleStack.has(t.target.ruleIndex)) {
                    continue;
                }
                const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);
                try {
                    calledRuleStack.add(t.target.ruleIndex);
                    this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                } finally {
                    calledRuleStack.remove(t.target.ruleIndex);
                }
            } else if (t instanceof AbstractPredicateTransition ) {
                if (seeThruPreds) {
                    this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                } else {
                    look.addOne(LL1Analyzer.HIT_PRED);
                }
            } else if( t.isEpsilon) {
                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else if (t.constructor === WildcardTransition) {
                look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );
            } else {
                let set = t.label;
                if (set !== null) {
                    if (t instanceof NotSetTransition) {
                        set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                    }
                    look.addSet(set);
                }
            }
        }
    }
}

/**
 * Special value added to the lookahead sets to indicate that we hit
 * a predicate during analysis if {@code seeThruPreds==false}.
 */
LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ATN {

    constructor(grammarType , maxTokenType) {
        /**
         * Used for runtime deserialization of ATNs from strings
         * The type of the ATN.
        */
        this.grammarType = grammarType;
        // The maximum value for any symbol recognized by a transition in the ATN.
        this.maxTokenType = maxTokenType;
        this.states = [];
        /**
         * Each subrule/rule is a decision point and we must track them so we
         * can go back later and build DFA predictors for them.  This includes
         * all the rules, subrules, optional blocks, ()+, ()* etc...
         */
        this.decisionToState = [];
        // Maps from rule index to starting state number.
        this.ruleToStartState = [];
        // Maps from rule index to stop state number.
        this.ruleToStopState = null;
        this.modeNameToStartState = {};
        /**
         * For lexer ATNs, this maps the rule index to the resulting token type.
         * For parser ATNs, this maps the rule index to the generated bypass token
         * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
         * deserialization option was specified; otherwise, this is {@code null}
         */
        this.ruleToTokenType = null;
        /**
         * For lexer ATNs, this is an array of {@link LexerAction} objects which may
         * be referenced by action transitions in the ATN
         */
        this.lexerActions = null;
        this.modeToStartState = [];
    }

    /**
     * Compute the set of valid tokens that can occur starting in state {@code s}.
     * If {@code ctx} is null, the set of tokens will not include what can follow
     * the rule surrounding {@code s}. In other words, the set will be
     * restricted to tokens reachable staying within {@code s}'s rule
     */
    nextTokensInContext(s, ctx) {
        const anal = new LL1Analyzer(this);
        return anal.LOOK(s, null, ctx);
    }

    /**
     * Compute the set of valid tokens that can occur starting in {@code s} and
     * staying in same rule. {@link Token//EPSILON} is in set if we reach end of
     * rule
     */
    nextTokensNoContext(s) {
        if (s.nextTokenWithinRule !== null ) {
            return s.nextTokenWithinRule;
        }
        s.nextTokenWithinRule = this.nextTokensInContext(s, null);
        s.nextTokenWithinRule.readOnly = true;
        return s.nextTokenWithinRule;
    }

    nextTokens(s, ctx) {
        if ( ctx===undefined ) {
            return this.nextTokensNoContext(s);
        } else {
            return this.nextTokensInContext(s, ctx);
        }
    }

    addState(state) {
        if ( state !== null ) {
            state.atn = this;
            state.stateNumber = this.states.length;
        }
        this.states.push(state);
    }

    removeState(state) {
        this.states[state.stateNumber] = null; // just free mem, don't shift states in list
    }

    defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.decisionToState.length-1;
        return s.decision;
    }

    getDecisionState(decision) {
        if (this.decisionToState.length===0) {
            return null;
        } else {
            return this.decisionToState[decision];
        }
    }

    /**
     * Computes the set of input symbols which could follow ATN state number
     * {@code stateNumber} in the specified full {@code context}. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token//EOF} is added to the returned set.
     *
     * <p>If {@code context} is {@code null}, it is treated as
     * {@link ParserRuleContext//EMPTY}.</p>
     *
     * @param stateNumber the ATN state number
     * @param ctx the full parse context
     *
     * @return {IntervalSet} The set of potentially valid input symbols which could follow the
     * specified state in the specified context.
     *
     * @throws IllegalArgumentException if the ATN does not contain a state with
     * number {@code stateNumber}
     */
    getExpectedTokens(stateNumber, ctx ) {
        if ( stateNumber < 0 || stateNumber >= this.states.length ) {
            throw("Invalid state number.");
        }
        const s = this.states[stateNumber];
        let following = this.nextTokens(s);
        if (!following.contains(Token.EPSILON)) {
            return following;
        }
        const expected = new IntervalSet();
        expected.addSet(following);
        expected.removeOne(Token.EPSILON);
        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
            const invokingState = this.states[ctx.invokingState];
            const rt = invokingState.transitions[0];
            following = this.nextTokens(rt.followState);
            expected.addSet(following);
            expected.removeOne(Token.EPSILON);
            ctx = ctx.parentCtx;
        }
        if (following.contains(Token.EPSILON)) {
            expected.addOne(Token.EOF);
        }
        return expected;
    }
}

ATN.INVALID_ALT_NUMBER = 0;

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Represents the type of recognizer an ATN applies to
 */
var ATNType = {
    LEXER: 0,
    PARSER: 1
};

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class BasicState extends ATNState {
    constructor() {
        super();
        this.stateType = ATNState.BASIC;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class DecisionState extends ATNState {
    constructor() {
        super();
        this.decision = -1;
        this.nonGreedy = false;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 *  The start of a regular {@code (...)} block
 */
class BlockStartState extends DecisionState {
    constructor() {
        super();
        this.endState = null;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Terminal node of a simple {@code (a|b|c)} block
 */
class BlockEndState extends ATNState {
    constructor() {
        super();
        this.stateType = ATNState.BLOCK_END;
        this.startState = null;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Mark the end of a * or + loop
 */
class LoopEndState extends ATNState {
    constructor() {
        super();
        this.stateType = ATNState.LOOP_END;
        this.loopBackState = null;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class RuleStartState extends ATNState {
    constructor() {
        super();
        this.stateType = ATNState.RULE_START;
        this.stopState = null;
        this.isPrecedenceRule = false;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The Tokens rule start state linking to each lexer rule start state
 */
class TokensStartState extends DecisionState {
    constructor() {
        super();
        this.stateType = ATNState.TOKEN_START;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:
 * one to the loop back to start of the block and one to exit.
 */
class PlusLoopbackState extends DecisionState {
    constructor() {
        super();
        this.stateType = ATNState.PLUS_LOOP_BACK;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class StarLoopbackState extends ATNState {
    constructor() {
        super();
        this.stateType = ATNState.STAR_LOOP_BACK;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class StarLoopEntryState extends DecisionState {
    constructor() {
        super();
        this.stateType = ATNState.STAR_LOOP_ENTRY;
        this.loopBackState = null;
        // Indicates whether this state can benefit from a precedence DFA during SLL decision making.
        this.isPrecedenceDecision = null;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Start of {@code (A|B|...)+} loop. Technically a decision state, but
 * we don't use for code generation; somebody might need it, so I'm defining
 * it for completeness. In reality, the {@link PlusLoopbackState} node is the
 * real decision-making note for {@code A+}
 */
class PlusBlockStartState extends BlockStartState {
    constructor() {
        super();
        this.stateType = ATNState.PLUS_BLOCK_START;
        this.loopBackState = null;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The block that begins a closure loop
 */
class StarBlockStartState extends BlockStartState {
    constructor() {
        super();
        this.stateType = ATNState.STAR_BLOCK_START;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class BasicBlockStartState extends BlockStartState {
    constructor() {
        super();
        this.stateType = ATNState.BLOCK_START;
        return this;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class AtomTransition extends Transition {
    constructor(target, label) {
        super(target);
        // The token type or character value; or, signifies special label.
        this.label_ = label;
        this.label = this.makeLabel();
        this.serializationType = Transition.ATOM;
    }

    makeLabel() {
        const s = new IntervalSet();
        s.addOne(this.label_);
        return s;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this.label_ === symbol;
    }

    toString() {
        return this.label_;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class RangeTransition extends Transition {
    constructor(target, start, stop) {
        super(target);
        this.serializationType = Transition.RANGE;
        this.start = start;
        this.stop = stop;
        this.label = this.makeLabel();
    }

    makeLabel() {
        const s = new IntervalSet();
        s.addRange(this.start, this.stop);
        return s;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= this.start && symbol <= this.stop;
    }

    toString() {
        return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ActionTransition extends Transition {
    constructor(target, ruleIndex, actionIndex, isCtxDependent) {
        super(target);
        this.serializationType = Transition.ACTION;
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex===undefined ? -1 : actionIndex;
        this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred
        this.isEpsilon = true;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }

    toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class EpsilonTransition extends Transition {
    constructor(target, outermostPrecedenceReturn) {
        super(target);
        this.serializationType = Transition.EPSILON;
        this.isEpsilon = true;
        this.outermostPrecedenceReturn = outermostPrecedenceReturn;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }

    toString() {
        return "epsilon";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class Predicate extends SemanticContext {

    constructor(ruleIndex, predIndex, isCtxDependent) {
        super();
        this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;
        this.predIndex = predIndex === undefined ? -1 : predIndex;
        this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
    }

    evaluate(parser, outerContext) {
        const localctx = this.isCtxDependent ? outerContext : null;
        return parser.sempred(localctx, this.ruleIndex, this.predIndex);
    }

    updateHashCode(hash) {
        hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (!(other instanceof Predicate)) {
            return false;
        } else {
            return this.ruleIndex === other.ruleIndex &&
                this.predIndex === other.predIndex &&
                this.isCtxDependent === other.isCtxDependent;
        }
    }

    toString() {
        return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
    }
}

/**
 * The default {@link SemanticContext}, which is semantically equivalent to
 * a predicate of the form {@code {true}?}
 */
SemanticContext.NONE = new Predicate();

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class PredicateTransition extends AbstractPredicateTransition {
    constructor(target, ruleIndex, predIndex, isCtxDependent) {
        super(target);
        this.serializationType = Transition.PREDICATE;
        this.ruleIndex = ruleIndex;
        this.predIndex = predIndex;
        this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred
        this.isEpsilon = true;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }

    getPredicate() {
        return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }

    toString() {
        return "pred_" + this.ruleIndex + ":" + this.predIndex;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class PrecedencePredicate extends SemanticContext {

    constructor(precedence) {
        super();
        this.precedence = precedence === undefined ? 0 : precedence;
    }

    evaluate(parser, outerContext) {
        return parser.precpred(outerContext, this.precedence);
    }

    evalPrecedence(parser, outerContext) {
        if (parser.precpred(outerContext, this.precedence)) {
            return SemanticContext.NONE;
        } else {
            return null;
        }
    }

    compareTo(other) {
        return this.precedence - other.precedence;
    }

    updateHashCode(hash) {
        hash.update(this.precedence);
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (!(other instanceof PrecedencePredicate)) {
            return false;
        } else {
            return this.precedence === other.precedence;
        }
    }

    toString() {
        return "{" + this.precedence + ">=prec}?";
    }

}

// HORRIBLE workaround circular import, avoiding dynamic import
SemanticContext.PrecedencePredicate = PrecedencePredicate;

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class PrecedencePredicateTransition extends AbstractPredicateTransition {
    constructor(target, precedence) {
        super(target);
        this.serializationType = Transition.PRECEDENCE;
        this.precedence = precedence;
        this.isEpsilon = true;
    }

    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }

    getPredicate() {
        return new PrecedencePredicate(this.precedence);
    }

    toString() {
        return this.precedence + " >= _p";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ATNDeserializationOptions {
	constructor(copyFrom) {
		if(copyFrom===undefined) {
			copyFrom = null;
		}
		this.readOnly = false;
		this.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;
		this.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;
	}
}

ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var LexerActionType = {
    // The type of a {@link LexerChannelAction} action.
    CHANNEL: 0,
    // The type of a {@link LexerCustomAction} action
    CUSTOM: 1,
    // The type of a {@link LexerModeAction} action.
    MODE: 2,
    //The type of a {@link LexerMoreAction} action.
    MORE: 3,
    //The type of a {@link LexerPopModeAction} action.
    POP_MODE: 4,
    //The type of a {@link LexerPushModeAction} action.
    PUSH_MODE: 5,
    //The type of a {@link LexerSkipAction} action.
    SKIP: 6,
    //The type of a {@link LexerTypeAction} action.
    TYPE: 7
};

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */


class LexerAction {
    constructor(action) {
        this.actionType = action;
        this.isPositionDependent = false;
    }

    hashCode() {
        const hash = new HashCode();
        this.updateHashCode(hash);
        return hash.finish()
    }

    updateHashCode(hash) {
        hash.update(this.actionType);
    }

    equals(other) {
        return this === other;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.
 *
 * <p>The {@code skip} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerSkipAction extends LexerAction {
    constructor() {
        super(LexerActionType.SKIP);
    }

    execute(lexer) {
        lexer.skip();
    }

    toString() {
        return "skip";
    }
}

// Provides a singleton instance of this parameterless lexer action.
LexerSkipAction.INSTANCE = new LexerSkipAction();

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Implements the {@code channel} lexer action by calling
 * {@link Lexer//setChannel} with the assigned channel.
 * Constructs a new {@code channel} action with the specified channel value.
 * @param channel The channel value to pass to {@link Lexer//setChannel}
 */
class LexerChannelAction extends LexerAction {
    constructor(channel) {
        super(LexerActionType.CHANNEL);
        this.channel = channel;
    }

    /**
     * <p>This action is implemented by calling {@link Lexer//setChannel} with the
     * value provided by {@link //getChannel}.</p>
     */
    execute(lexer) {
        lexer._channel = this.channel;
    }

    updateHashCode(hash) {
        hash.update(this.actionType, this.channel);
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (! (other instanceof LexerChannelAction)) {
            return false;
        } else {
            return this.channel === other.channel;
        }
    }

    toString() {
        return "channel(" + this.channel + ")";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Executes a custom lexer action by calling {@link Recognizer//action} with the
 * rule and action indexes assigned to the custom action. The implementation of
 * a custom action is added to the generated code for the lexer in an override
 * of {@link Recognizer//action} when the grammar is compiled.
 *
 * <p>This class may represent embedded actions created with the <code>{...}</code>
 * syntax in ANTLR 4, as well as actions created for lexer commands where the
 * command argument could not be evaluated when the grammar was compiled.</p>
 */
class LexerCustomAction extends LexerAction {
    /**
     * Constructs a custom lexer action with the specified rule and action
     * indexes.
     *
     * @param ruleIndex The rule index to use for calls to
     * {@link Recognizer//action}.
     * @param actionIndex The action index to use for calls to
     * {@link Recognizer//action}.
     */
    constructor(ruleIndex, actionIndex) {
        super(LexerActionType.CUSTOM);
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex;
        this.isPositionDependent = true;
    }

    /**
     * <p>Custom actions are implemented by calling {@link Lexer//action} with the
     * appropriate rule and action indexes.</p>
     */
    execute(lexer) {
        lexer.action(null, this.ruleIndex, this.actionIndex);
    }

    updateHashCode(hash) {
        hash.update(this.actionType, this.ruleIndex, this.actionIndex);
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (! (other instanceof LexerCustomAction)) {
            return false;
        } else {
            return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
        }
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Implements the {@code more} lexer action by calling {@link Lexer//more}.
 *
 * <p>The {@code more} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerMoreAction extends LexerAction {
    constructor() {
        super(LexerActionType.MORE);
    }

    /**
     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
     */
    execute(lexer) {
        lexer.more();
    }

    toString() {
        return "more";
    }
}

LexerMoreAction.INSTANCE = new LexerMoreAction();

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Implements the {@code type} lexer action by calling {@link Lexer//setType}
 * with the assigned type
 */

class LexerTypeAction extends LexerAction {
    constructor(type) {
        super(LexerActionType.TYPE);
        this.type = type;
    }

    execute(lexer) {
        lexer.type = this.type;
    }

    updateHashCode(hash) {
        hash.update(this.actionType, this.type);
    }

    equals(other) {
        if(this === other) {
            return true;
        } else if (! (other instanceof LexerTypeAction)) {
            return false;
        } else {
            return this.type === other.type;
        }
    }

    toString() {
        return "type(" + this.type + ")";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Implements the {@code pushMode} lexer action by calling
 * {@link Lexer//pushMode} with the assigned mode
 */
class LexerPushModeAction extends LexerAction {
    constructor(mode) {
        super(LexerActionType.PUSH_MODE);
        this.mode = mode;
    }

    /**
     * <p>This action is implemented by calling {@link Lexer//pushMode} with the
     * value provided by {@link //getMode}.</p>
     */
    execute(lexer) {
        lexer.pushMode(this.mode);
    }

    updateHashCode(hash) {
        hash.update(this.actionType, this.mode);
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (! (other instanceof LexerPushModeAction)) {
            return false;
        } else {
            return this.mode === other.mode;
        }
    }

    toString() {
        return "pushMode(" + this.mode + ")";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
 *
 * <p>The {@code popMode} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerPopModeAction extends LexerAction {
    constructor() {
        super(LexerActionType.POP_MODE);
    }

    /**
     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
     */
    execute(lexer) {
        lexer.popMode();
    }

    toString() {
        return "popMode";
    }
}

LexerPopModeAction.INSTANCE = new LexerPopModeAction();

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
 * the assigned mode
 */
class LexerModeAction extends LexerAction {
    constructor(mode) {
        super(LexerActionType.MODE);
        this.mode = mode;
    }

    /**
     * <p>This action is implemented by calling {@link Lexer//mode} with the
     * value provided by {@link //getMode}.</p>
     */
    execute(lexer) {
        lexer.mode(this.mode);
    }

    updateHashCode(hash) {
        hash.update(this.actionType, this.mode);
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (! (other instanceof LexerModeAction)) {
            return false;
        } else {
            return this.mode === other.mode;
        }
    }

    toString() {
        return "mode(" + this.mode + ")";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const SERIALIZED_VERSION = 4;

function initArray( length, value) {
	const tmp = [];
	tmp[length-1] = value;
	return tmp.map(function(i) {return value;});
}

class ATNDeserializer {
    constructor(options) {

        if ( options=== undefined || options === null ) {
            options = ATNDeserializationOptions.defaultOptions;
        }
        this.deserializationOptions = options;
        this.stateFactories = null;
        this.actionFactories = null;
    }

    deserialize(data) {
        const legacy = this.reset(data);
        this.checkVersion(legacy);
        if(legacy)
            this.skipUUID();
        const atn = this.readATN();
        this.readStates(atn, legacy);
        this.readRules(atn, legacy);
        this.readModes(atn);
        const sets = [];
        this.readSets(atn, sets, this.readInt.bind(this));
        if(legacy)
            this.readSets(atn, sets, this.readInt32.bind(this));
        this.readEdges(atn, sets);
        this.readDecisions(atn);
        this.readLexerActions(atn, legacy);
        this.markPrecedenceDecisions(atn);
        this.verifyATN(atn);
        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {
            this.generateRuleBypassTransitions(atn);
            // re-verify after modification
            this.verifyATN(atn);
        }
        return atn;
    }

    reset(data) {
        const version = data.charCodeAt ? data.charCodeAt(0) : data[0];
        if(version === SERIALIZED_VERSION - 1) {
            const adjust = function (c) {
                const v = c.charCodeAt(0);
                return v > 1 ? v - 2 : v + 65534;
            };
            const temp = data.split("").map(adjust);
            // don't adjust the first value since that's the version number
            temp[0] = data.charCodeAt(0);
            this.data = temp;
            this.pos = 0;
            return true;
        } else {
            this.data = data;
            this.pos = 0;
            return false;
        }
    }

    skipUUID() {
        let count = 0;
        while(count++ < 8)
            this.readInt();
    }

    checkVersion(legacy) {
        const version = this.readInt();
        if ( !legacy && version !== SERIALIZED_VERSION ) {
            throw ("Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").");
        }
    }

    readATN() {
        const grammarType = this.readInt();
        const maxTokenType = this.readInt();
        return new ATN(grammarType, maxTokenType);
    }

    readStates(atn, legacy) {
        let j, pair, stateNumber;
        const  loopBackStateNumbers = [];
        const  endStateNumbers = [];
        const  nstates = this.readInt();
        for(let i=0; i<nstates; i++) {
            const  stype = this.readInt();
            // ignore bad type of states
            if (stype===ATNState.INVALID_TYPE) {
                atn.addState(null);
                continue;
            }
            let ruleIndex = this.readInt();
            if (legacy && ruleIndex === 0xFFFF) {
                ruleIndex = -1;
            }
            const  s = this.stateFactory(stype, ruleIndex);
            if (stype === ATNState.LOOP_END) { // special case
                const  loopBackStateNumber = this.readInt();
                loopBackStateNumbers.push([s, loopBackStateNumber]);
            } else if(s instanceof BlockStartState) {
                const  endStateNumber = this.readInt();
                endStateNumbers.push([s, endStateNumber]);
            }
            atn.addState(s);
        }
        // delay the assignment of loop back and end states until we know all the
        // state instances have been initialized
        for (j=0; j<loopBackStateNumbers.length; j++) {
            pair = loopBackStateNumbers[j];
            pair[0].loopBackState = atn.states[pair[1]];
        }

        for (j=0; j<endStateNumbers.length; j++) {
            pair = endStateNumbers[j];
            pair[0].endState = atn.states[pair[1]];
        }

        let numNonGreedyStates = this.readInt();
        for (j=0; j<numNonGreedyStates; j++) {
            stateNumber = this.readInt();
            atn.states[stateNumber].nonGreedy = true;
        }

        let numPrecedenceStates = this.readInt();
        for (j=0; j<numPrecedenceStates; j++) {
            stateNumber = this.readInt();
            atn.states[stateNumber].isPrecedenceRule = true;
        }
    }

    readRules(atn, legacy) {
        let i;
        const nrules = this.readInt();
        if (atn.grammarType === ATNType.LEXER ) {
            atn.ruleToTokenType = initArray(nrules, 0);
        }
        atn.ruleToStartState = initArray(nrules, 0);
        for (i=0; i<nrules; i++) {
            const s = this.readInt();
            atn.ruleToStartState[i] = atn.states[s];
            if ( atn.grammarType === ATNType.LEXER ) {
                let tokenType = this.readInt();
                if (legacy && tokenType === 0xFFFF) {
                    tokenType = Token.EOF;
                }
                atn.ruleToTokenType[i] = tokenType;
            }
        }
        atn.ruleToStopState = initArray(nrules, 0);
        for (i=0; i<atn.states.length; i++) {
            const state = atn.states[i];
            if (!(state instanceof RuleStopState)) {
                continue;
            }
            atn.ruleToStopState[state.ruleIndex] = state;
            atn.ruleToStartState[state.ruleIndex].stopState = state;
        }
    }

    readModes(atn) {
        const nmodes = this.readInt();
        for (let i=0; i<nmodes; i++) {
            let s = this.readInt();
            atn.modeToStartState.push(atn.states[s]);
        }
    }

    readSets(atn, sets, reader) {
        const m = this.readInt();
        for (let i=0; i<m; i++) {
            const iset = new IntervalSet();
            sets.push(iset);
            const n = this.readInt();
            const containsEof = this.readInt();
            if (containsEof!==0) {
                iset.addOne(-1);
            }
            for (let j=0; j<n; j++) {
                const i1 = reader();
                const i2 = reader();
                iset.addRange(i1, i2);
            }
        }
    }

    readEdges(atn, sets) {
        let i, j, state, trans, target;
        const nedges = this.readInt();
        for (i=0; i<nedges; i++) {
            const src = this.readInt();
            const trg = this.readInt();
            const ttype = this.readInt();
            const arg1 = this.readInt();
            const arg2 = this.readInt();
            const arg3 = this.readInt();
            trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
            const srcState = atn.states[src];
            srcState.addTransition(trans);
        }
        // edges for rule stop states can be derived, so they aren't serialized
        for (i=0; i<atn.states.length; i++) {
            state = atn.states[i];
            for (j=0; j<state.transitions.length; j++) {
                const t = state.transitions[j];
                if (!(t instanceof RuleTransition)) {
                    continue;
                }
                let outermostPrecedenceReturn = -1;
                if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
                    if (t.precedence === 0) {
                        outermostPrecedenceReturn = t.target.ruleIndex;
                    }
                }

                trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
                atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
            }
        }

        for (i=0; i<atn.states.length; i++) {
            state = atn.states[i];
            if (state instanceof BlockStartState) {
                // we need to know the end state to set its start state
                if (state.endState === null) {
                    throw ("IllegalState");
                }
                // block end states can only be associated to a single block start
                // state
                if ( state.endState.startState !== null) {
                    throw ("IllegalState");
                }
                state.endState.startState = state;
            }
            if (state instanceof PlusLoopbackState) {
                for (j=0; j<state.transitions.length; j++) {
                    target = state.transitions[j].target;
                    if (target instanceof PlusBlockStartState) {
                        target.loopBackState = state;
                    }
                }
            } else if (state instanceof StarLoopbackState) {
                for (j=0; j<state.transitions.length; j++) {
                    target = state.transitions[j].target;
                    if (target instanceof StarLoopEntryState) {
                        target.loopBackState = state;
                    }
                }
            }
        }
    }

    readDecisions(atn) {
        const ndecisions = this.readInt();
        for (let i=0; i<ndecisions; i++) {
            const s = this.readInt();
            const decState = atn.states[s];
            atn.decisionToState.push(decState);
            decState.decision = i;
        }
    }

    readLexerActions(atn, legacy) {
        if (atn.grammarType === ATNType.LEXER) {
            const count = this.readInt();
            atn.lexerActions = initArray(count, null);
            for (let i=0; i<count; i++) {
                const actionType = this.readInt();
                let data1 = this.readInt();
                if (legacy && data1 === 0xFFFF) {
                    data1 = -1;
                }
                let data2 = this.readInt();
                if (legacy && data2 === 0xFFFF) {
                    data2 = -1;
                }
                atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);
            }
        }
    }

    generateRuleBypassTransitions(atn) {
        let i;
        const count = atn.ruleToStartState.length;
        for(i=0; i<count; i++) {
            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
        }
        for(i=0; i<count; i++) {
            this.generateRuleBypassTransition(atn, i);
        }
    }

    generateRuleBypassTransition(atn, idx) {
        let i, state;
        const bypassStart = new BasicBlockStartState();
        bypassStart.ruleIndex = idx;
        atn.addState(bypassStart);

        const bypassStop = new BlockEndState();
        bypassStop.ruleIndex = idx;
        atn.addState(bypassStop);

        bypassStart.endState = bypassStop;
        atn.defineDecisionState(bypassStart);

        bypassStop.startState = bypassStart;

        let excludeTransition = null;
        let endState = null;

        if (atn.ruleToStartState[idx].isPrecedenceRule) {
            // wrap from the beginning of the rule to the StarLoopEntryState
            endState = null;
            for(i=0; i<atn.states.length; i++) {
                state = atn.states[i];
                if (this.stateIsEndStateFor(state, idx)) {
                    endState = state;
                    excludeTransition = state.loopBackState.transitions[0];
                    break;
                }
            }
            if (excludeTransition === null) {
                throw ("Couldn't identify final state of the precedence rule prefix section.");
            }
        } else {
            endState = atn.ruleToStopState[idx];
        }

        // all non-excluded transitions that currently target end state need to
        // target blockEnd instead
        for(i=0; i<atn.states.length; i++) {
            state = atn.states[i];
            for(let j=0; j<state.transitions.length; j++) {
                const transition = state.transitions[j];
                if (transition === excludeTransition) {
                    continue;
                }
                if (transition.target === endState) {
                    transition.target = bypassStop;
                }
            }
        }

        // all transitions leaving the rule start state need to leave blockStart
        // instead
        const ruleToStartState = atn.ruleToStartState[idx];
        const count = ruleToStartState.transitions.length;
        while ( count > 0) {
            bypassStart.addTransition(ruleToStartState.transitions[count-1]);
            ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
        }
        // link the new states
        atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
        bypassStop.addTransition(new EpsilonTransition(endState));

        const matchState = new BasicState();
        atn.addState(matchState);
        matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
        bypassStart.addTransition(new EpsilonTransition(matchState));
    }

    stateIsEndStateFor(state, idx) {
        if ( state.ruleIndex !== idx) {
            return null;
        }
        if (!( state instanceof StarLoopEntryState)) {
            return null;
        }
        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
        if (!( maybeLoopEndState instanceof LoopEndState)) {
            return null;
        }
        if (maybeLoopEndState.epsilonOnlyTransitions &&
            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
            return state;
        } else {
            return null;
        }
    }

    /**
     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
     * the {@link StarLoopEntryState//isPrecedenceDecision} field to the
     * correct value.
     * @param atn The ATN.
     */
    markPrecedenceDecisions(atn) {
        for(let i=0; i<atn.states.length; i++) {
            const state = atn.states[i];
            if (!( state instanceof StarLoopEntryState)) {
                continue;
            }
            // We analyze the ATN to determine if this ATN decision state is the
            // decision for the closure block that determines whether a
            // precedence rule should continue or complete.
            if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
                const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
                if (maybeLoopEndState instanceof LoopEndState) {
                    if ( maybeLoopEndState.epsilonOnlyTransitions &&
                            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
                        state.isPrecedenceDecision = true;
                    }
                }
            }
        }
    }

    verifyATN(atn) {
        if (!this.deserializationOptions.verifyATN) {
            return;
        }
        // verify assumptions
        for(let i=0; i<atn.states.length; i++) {
            const state = atn.states[i];
            if (state === null) {
                continue;
            }
            this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
            if (state instanceof PlusBlockStartState) {
                this.checkCondition(state.loopBackState !== null);
            } else  if (state instanceof StarLoopEntryState) {
                this.checkCondition(state.loopBackState !== null);
                this.checkCondition(state.transitions.length === 2);
                if (state.transitions[0].target instanceof StarBlockStartState) {
                    this.checkCondition(state.transitions[1].target instanceof LoopEndState);
                    this.checkCondition(!state.nonGreedy);
                } else if (state.transitions[0].target instanceof LoopEndState) {
                    this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
                    this.checkCondition(state.nonGreedy);
                } else {
                    throw("IllegalState");
                }
            } else if (state instanceof StarLoopbackState) {
                this.checkCondition(state.transitions.length === 1);
                this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
            } else if (state instanceof LoopEndState) {
                this.checkCondition(state.loopBackState !== null);
            } else if (state instanceof RuleStartState) {
                this.checkCondition(state.stopState !== null);
            } else if (state instanceof BlockStartState) {
                this.checkCondition(state.endState !== null);
            } else if (state instanceof BlockEndState) {
                this.checkCondition(state.startState !== null);
            } else if (state instanceof DecisionState) {
                this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
            } else {
                this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));
            }
        }
    }

    checkCondition(condition, message) {
        if (!condition) {
            if (message === undefined || message===null) {
                message = "IllegalState";
            }
            throw (message);
        }
    }

    readInt() {
        return this.data[this.pos++];
    }

    readInt32() {
        const low = this.readInt();
        const high = this.readInt();
        return low | (high << 16);
    }

    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
        const target = atn.states[trg];
        switch(type) {
        case Transition.EPSILON:
            return new EpsilonTransition(target);
        case Transition.RANGE:
            return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
        case Transition.RULE:
            return new RuleTransition(atn.states[arg1], arg2, arg3, target);
        case Transition.PREDICATE:
            return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
        case Transition.PRECEDENCE:
            return new PrecedencePredicateTransition(target, arg1);
        case Transition.ATOM:
            return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
        case Transition.ACTION:
            return new ActionTransition(target, arg1, arg2, arg3 !== 0);
        case Transition.SET:
            return new SetTransition(target, sets[arg1]);
        case Transition.NOT_SET:
            return new NotSetTransition(target, sets[arg1]);
        case Transition.WILDCARD:
            return new WildcardTransition(target);
        default:
            throw "The specified transition type: " + type + " is not valid.";
        }
    }

    stateFactory(type, ruleIndex) {
        if (this.stateFactories === null) {
            const sf = [];
            sf[ATNState.INVALID_TYPE] = null;
            sf[ATNState.BASIC] = () => new BasicState();
            sf[ATNState.RULE_START] = () => new RuleStartState();
            sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();
            sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();
            sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();
            sf[ATNState.TOKEN_START] = () => new TokensStartState();
            sf[ATNState.RULE_STOP] = () => new RuleStopState();
            sf[ATNState.BLOCK_END] = () => new BlockEndState();
            sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();
            sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();
            sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();
            sf[ATNState.LOOP_END] = () => new LoopEndState();
            this.stateFactories = sf;
        }
        if (type>this.stateFactories.length || this.stateFactories[type] === null) {
            throw("The specified state type " + type + " is not valid.");
        } else {
            const s = this.stateFactories[type]();
            if (s!==null) {
                s.ruleIndex = ruleIndex;
                return s;
            }
        }
    }

    lexerActionFactory(type, data1, data2) {
        if (this.actionFactories === null) {
            const af = [];
            af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);
            af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);
            af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);
            af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;
            af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;
            af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);
            af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;
            af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);
            this.actionFactories = af;
        }
        if (type>this.actionFactories.length || this.actionFactories[type] === null) {
            throw("The specified lexer action type " + type + " is not valid.");
        } else {
            return this.actionFactories[type](data1, data2);
        }
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Provides an empty default implementation of {@link ANTLRErrorListener}. The
 * default implementation of each method does nothing, but can be overridden as
 * necessary.
 */
class ErrorListener {
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    }

    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    }

    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    }

    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * {@inheritDoc}
 *
 * <p>
 * This implementation prints messages to {@link System//err} containing the
 * values of {@code line}, {@code charPositionInLine}, and {@code msg} using
 * the following format.</p>
 *
 * <pre>
 * line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
 * </pre>
 *
 */
class ConsoleErrorListener extends ErrorListener {
    constructor() {
        super();
    }

    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
        console.error("line " + line + ":" + column + " " + msg);
    }
}


/**
 * Provides a default instance of {@link ConsoleErrorListener}.
 */
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ProxyErrorListener extends ErrorListener {
    constructor(delegates) {
        super();
        if (delegates===null) {
            throw "delegates";
        }
        this.delegates = delegates;
        return this;
    }

    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
        this.delegates.map(d => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));
    }

    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        this.delegates.map(d => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));
    }

    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
        this.delegates.map(d => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));
    }

    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
        this.delegates.map(d => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class Recognizer {
    constructor() {
        this._listeners = [ ConsoleErrorListener.INSTANCE ];
        this._interp = null;
        this._stateNumber = -1;
    }

    checkVersion(toolVersion) {
        const runtimeVersion = "4.10.1";
        if (runtimeVersion!==toolVersion) {
            console.log("ANTLR runtime and generated code versions disagree: "+runtimeVersion+"!="+toolVersion);
        }
    }

    addErrorListener(listener) {
        this._listeners.push(listener);
    }

    removeErrorListeners() {
        this._listeners = [];
    }

    getLiteralNames() {
        return Object.getPrototypeOf(this).constructor.literalNames || [];
    }

    getSymbolicNames() {
        return Object.getPrototypeOf(this).constructor.symbolicNames || [];
    }

    getTokenNames() {
        if(!this.tokenNames) {
            const literalNames = this.getLiteralNames();
            const symbolicNames = this.getSymbolicNames();
            const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;
            this.tokenNames = [];
            for(let i=0; i<length; i++) {
                this.tokenNames[i] = literalNames[i] || symbolicNames[i] || "<INVALID";
            }
        }
        return this.tokenNames;
    }

    getTokenTypeMap() {
        const tokenNames = this.getTokenNames();
        if (tokenNames===null) {
            throw("The current recognizer does not provide a list of token names.");
        }
        let result = this.tokenTypeMapCache[tokenNames];
        if(result===undefined) {
            result = tokenNames.reduce(function(o, k, i) { o[k] = i; });
            result.EOF = Token.EOF;
            this.tokenTypeMapCache[tokenNames] = result;
        }
        return result;
    }

    /**
     * Get a map from rule names to rule indexes.
     * <p>Used for XPath and tree pattern compilation.</p>
     */
    getRuleIndexMap() {
        const ruleNames = this.ruleNames;
        if (ruleNames===null) {
            throw("The current recognizer does not provide a list of rule names.");
        }
        let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?
        if(result===undefined) {
            result = ruleNames.reduce(function(o, k, i) { o[k] = i; });
            this.ruleIndexMapCache[ruleNames] = result;
        }
        return result;
    }

    getTokenType(tokenName) {
        const ttype = this.getTokenTypeMap()[tokenName];
        if (ttype !==undefined) {
            return ttype;
        } else {
            return Token.INVALID_TYPE;
        }
    }

    // What is the error header, normally line/character position information?
    getErrorHeader(e) {
        const line = e.getOffendingToken().line;
        const column = e.getOffendingToken().column;
        return "line " + line + ":" + column;
    }

    /**
     * How should a token be displayed in an error message? The default
     * is to display just the text, but during development you might
     * want to have a lot of information spit out.  Override in that case
     * to use t.toString() (which, for CommonToken, dumps everything about
     * the token). This is better than forcing you to override a method in
     * your token objects because you don't have to go modify your lexer
     * so that it creates a new Java type.
     *
     * @deprecated This method is not called by the ANTLR 4 Runtime. Specific
     * implementations of {@link ANTLRErrorStrategy} may provide a similar
     * feature when necessary. For example, see
     * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/
    getTokenErrorDisplay(t) {
        if (t===null) {
            return "<no token>";
        }
        let s = t.text;
        if (s===null) {
            if (t.type===Token.EOF) {
                s = "<EOF>";
            } else {
                s = "<" + t.type + ">";
            }
        }
        s = s.replace("\n","\\n").replace("\r","\\r").replace("\t","\\t");
        return "'" + s + "'";
    }

    getErrorListenerDispatch() {
        return new ProxyErrorListener(this._listeners);
    }

    /**
     * subclass needs to override these if there are sempreds or actions
     * that the ATN interp needs to execute
     */
    sempred(localctx, ruleIndex, actionIndex) {
        return true;
    }

    precpred(localctx , precedence) {
        return true;
    }

    get state(){
        return this._stateNumber;
    }

    set state(state) {
        this._stateNumber = state;
    }
}

Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};

class CommonToken extends Token {
    constructor(source, type, channel, start, stop) {
        super();
        this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;
        this.type = type !== undefined ? type : null;
        this.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;
        this.start = start !== undefined ? start : -1;
        this.stop = stop !== undefined ? stop : -1;
        this.tokenIndex = -1;
        if (this.source[0] !== null) {
            this.line = source[0].line;
            this.column = source[0].column;
        } else {
            this.column = -1;
        }
    }

    /**
     * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
     *
     * <p>
     * If {@code oldToken} is also a {@link CommonToken} instance, the newly
     * constructed token will share a reference to the {@link //text} field and
     * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
     * be assigned the result of calling {@link //getText}, and {@link //source}
     * will be constructed from the result of {@link Token//getTokenSource} and
     * {@link Token//getInputStream}.</p>
     *
     * @param oldToken The token to copy.
     */
    clone() {
        const t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);
        t.tokenIndex = this.tokenIndex;
        t.line = this.line;
        t.column = this.column;
        t.text = this.text;
        return t;
    }

    toString() {
        let txt = this.text;
        if (txt !== null) {
            txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
        } else {
            txt = "<no text>";
        }
        return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" +
            txt + "',<" + this.type + ">" +
            (this.channel > 0 ? ",channel=" + this.channel : "") + "," +
            this.line + ":" + this.column + "]";
    }

    get text(){
        if (this._text !== null) {
            return this._text;
        }
        const input = this.getInputStream();
        if (input === null) {
            return null;
        }
        const n = input.size;
        if (this.start < n && this.stop < n) {
            return input.getText(this.start, this.stop);
        } else {
            return "<EOF>";
        }
    }

    set text(text) {
        this._text = text;
    }
}

/**
 * An empty {@link Pair} which is used as the default value of
 * {@link //source} for tokens that do not have a source.
 */
CommonToken.EMPTY_SOURCE = [ null, null ];

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class TokenFactory {}

/**
 * This default implementation of {@link TokenFactory} creates
 * {@link CommonToken} objects.
 */
class CommonTokenFactory extends TokenFactory {
    constructor(copyText) {
        super();
        /**
         * Indicates whether {@link CommonToken//setText} should be called after
         * constructing tokens to explicitly set the text. This is useful for cases
         * where the input stream might not be able to provide arbitrary substrings
         * of text from the input after the lexer creates a token (e.g. the
         * implementation of {@link CharStream//getText} in
         * {@link UnbufferedCharStream} throws an
         * {@link UnsupportedOperationException}). Explicitly setting the token text
         * allows {@link Token//getText} to be called at any time regardless of the
         * input stream implementation.
         *
         * <p>
         * The default value is {@code false} to avoid the performance and memory
         * overhead of copying text for every token unless explicitly requested.</p>
         */
        this.copyText = copyText===undefined ? false : copyText;
    }

    create(source, type, text, channel, start, stop, line, column) {
        const t = new CommonToken(source, type, channel, start, stop);
        t.line = line;
        t.column = column;
        if (text !==null) {
            t.text = text;
        } else if (this.copyText && source[1] !==null) {
            t.text = source[1].getText(start,stop);
        }
        return t;
    }

    createThin(type, text) {
        const t = new CommonToken(null, type);
        t.text = text;
        return t;
    }
}

/**
 * The default {@link CommonTokenFactory} instance.
 *
 * <p>
 * This token factory does not explicitly copy token text when constructing
 * tokens.</p>
 */
CommonTokenFactory.DEFAULT = new CommonTokenFactory();

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
 *  3 kinds of errors: prediction errors, failed predicate errors, and
 *  mismatched input errors. In each case, the parser knows where it is
 *  in the input, where it is in the ATN, the rule invocation stack,
 *  and what kind of problem occurred.
 */

class RecognitionException extends Error {
    constructor(params) {
        super(params.message);
        if (Error.captureStackTrace)
            Error.captureStackTrace(this, RecognitionException);
        this.message = params.message;
        this.recognizer = params.recognizer;
        this.input = params.input;
        this.ctx = params.ctx;
        /**
         * The current {@link Token} when an error occurred. Since not all streams
         * support accessing symbols by index, we have to track the {@link Token}
         * instance itself
        */
        this.offendingToken = null;
        /**
         * Get the ATN state number the parser was in at the time the error
         * occurred. For {@link NoViableAltException} and
         * {@link LexerNoViableAltException} exceptions, this is the
         * {@link DecisionState} number. For others, it is the state whose outgoing
         * edge we couldn't match.
         */
        this.offendingState = -1;
        if (this.recognizer!==null) {
            this.offendingState = this.recognizer.state;
        }
    }

    /**
     * Gets the set of input symbols which could potentially follow the
     * previously matched symbol at the time this exception was thrown.
     *
     * <p>If the set of expected tokens is not known and could not be computed,
     * this method returns {@code null}.</p>
     *
     * @return The set of token types that could potentially follow the current
     * state in the ATN, or {@code null} if the information is not available.
     */
    getExpectedTokens() {
        if (this.recognizer!==null) {
            return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
        } else {
            return null;
        }
    }

    // <p>If the state number is not known, this method returns -1.</p>
    toString() {
        return this.message;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class LexerNoViableAltException extends RecognitionException {
    constructor(lexer, input, startIndex, deadEndConfigs) {
        super({message: "", recognizer: lexer, input: input, ctx: null});
        this.startIndex = startIndex;
        this.deadEndConfigs = deadEndConfigs;
    }

    toString() {
        let symbol = "";
        if (this.startIndex >= 0 && this.startIndex < this.input.size) {
            symbol = this.input.getText(new Interval(this.startIndex,this.startIndex));
        }
        return "LexerNoViableAltException" + symbol;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * A lexer is recognizer that draws input symbols from a character stream.
 * lexer grammars result in a subclass of this object. A Lexer object
 * uses simplified match() and error recovery mechanisms in the interest of speed.
 */
class Lexer extends Recognizer {
	constructor(input) {
		super();
		this._input = input;
		this._factory = CommonTokenFactory.DEFAULT;
		this._tokenFactorySourcePair = [ this, input ];

		this._interp = null; // child classes must populate this

		/**
		 * The goal of all lexer rules/methods is to create a token object.
		 * this is an instance variable as multiple rules may collaborate to
		 * create a single token. nextToken will return this object after
		 * matching lexer rule(s). If you subclass to allow multiple token
		 * emissions, then set this to the last token to be matched or
		 * something nonnull so that the auto token emit mechanism will not
		 * emit another token.
		 */
		this._token = null;

		/**
		 * What character index in the stream did the current token start at?
		 * Needed, for example, to get the text for current token. Set at
		 * the start of nextToken.
		 */
		this._tokenStartCharIndex = -1;

		// The line on which the first character of the token resides///
		this._tokenStartLine = -1;

		// The character position of first character within the line///
		this._tokenStartColumn = -1;

		// Once we see EOF on char stream, next token will be EOF.
		// If you have DONE : EOF ; then you see DONE EOF.
		this._hitEOF = false;

		// The channel number for the current token///
		this._channel = Token.DEFAULT_CHANNEL;

		// The token type for the current token///
		this._type = Token.INVALID_TYPE;

		this._modeStack = [];
		this._mode = Lexer.DEFAULT_MODE;

		/**
		 * You can set the text for the current token to override what is in
		 * the input char buffer. Use setText() or can set this instance var.
		 */
		this._text = null;
	}

	reset() {
		// wack Lexer state variables
		if (this._input !== null) {
			this._input.seek(0); // rewind the input
		}
		this._token = null;
		this._type = Token.INVALID_TYPE;
		this._channel = Token.DEFAULT_CHANNEL;
		this._tokenStartCharIndex = -1;
		this._tokenStartColumn = -1;
		this._tokenStartLine = -1;
		this._text = null;

		this._hitEOF = false;
		this._mode = Lexer.DEFAULT_MODE;
		this._modeStack = [];

		this._interp.reset();
	}

// Return a token from this source; i.e., match a token on the char stream.
	nextToken() {
		if (this._input === null) {
			throw "nextToken requires a non-null input stream.";
		}

		/**
		 * Mark start location in char stream so unbuffered streams are
		 * guaranteed at least have text of current token
		 */
		const tokenStartMarker = this._input.mark();
		try {
			for (;;) {
				if (this._hitEOF) {
					this.emitEOF();
					return this._token;
				}
				this._token = null;
				this._channel = Token.DEFAULT_CHANNEL;
				this._tokenStartCharIndex = this._input.index;
				this._tokenStartColumn = this._interp.column;
				this._tokenStartLine = this._interp.line;
				this._text = null;
				let continueOuter = false;
				for (;;) {
					this._type = Token.INVALID_TYPE;
					let ttype = Lexer.SKIP;
					try {
						ttype = this._interp.match(this._input, this._mode);
					} catch (e) {
						if(e instanceof RecognitionException) {
							this.notifyListeners(e); // report error
							this.recover(e);
						} else {
							console.log(e.stack);
							throw e;
						}
					}
					if (this._input.LA(1) === Token.EOF) {
						this._hitEOF = true;
					}
					if (this._type === Token.INVALID_TYPE) {
						this._type = ttype;
					}
					if (this._type === Lexer.SKIP) {
						continueOuter = true;
						break;
					}
					if (this._type !== Lexer.MORE) {
						break;
					}
				}
				if (continueOuter) {
					continue;
				}
				if (this._token === null) {
					this.emit();
				}
				return this._token;
			}
		} finally {
			// make sure we release marker after match or
			// unbuffered char stream will keep buffering
			this._input.release(tokenStartMarker);
		}
	}

	/**
	 * Instruct the lexer to skip creating a token for current lexer rule
	 * and look for another token. nextToken() knows to keep looking when
	 * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
	 * if token==null at end of any token rule, it creates one for you
	 * and emits it.
	 */
	skip() {
		this._type = Lexer.SKIP;
	}

	more() {
		this._type = Lexer.MORE;
	}

	mode(m) {
		this._mode = m;
	}

	pushMode(m) {
		if (this._interp.debug) {
			console.log("pushMode " + m);
		}
		this._modeStack.push(this._mode);
		this.mode(m);
	}

	popMode() {
		if (this._modeStack.length === 0) {
			throw "Empty Stack";
		}
		if (this._interp.debug) {
			console.log("popMode back to " + this._modeStack.slice(0, -1));
		}
		this.mode(this._modeStack.pop());
		return this._mode;
	}

	/**
	 * By default does not support multiple emits per nextToken invocation
	 * for efficiency reasons. Subclass and override this method, nextToken,
	 * and getToken (to push tokens into a list and pull from that list
	 * rather than a single variable as this implementation does).
	 */
	emitToken(token) {
		this._token = token;
	}

	/**
	 * The standard method called to automatically emit a token at the
	 * outermost lexical rule. The token object should point into the
	 * char buffer start..stop. If there is a text override in 'text',
	 * use that to set the token's text. Override this method to emit
	 * custom Token objects or provide a new factory.
	 */
	emit() {
		const t = this._factory.create(this._tokenFactorySourcePair, this._type,
				this._text, this._channel, this._tokenStartCharIndex, this
						.getCharIndex() - 1, this._tokenStartLine,
				this._tokenStartColumn);
		this.emitToken(t);
		return t;
	}

	emitEOF() {
		const cpos = this.column;
		const lpos = this.line;
		const eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,
				null, Token.DEFAULT_CHANNEL, this._input.index,
				this._input.index - 1, lpos, cpos);
		this.emitToken(eof);
		return eof;
	}

// What is the index of the current character of lookahead?///
	getCharIndex() {
		return this._input.index;
	}

	/**
	 * Return a list of all Token objects in input char stream.
	 * Forces load of all tokens. Does not include EOF token.
	 */
	getAllTokens() {
		const tokens = [];
		let t = this.nextToken();
		while (t.type !== Token.EOF) {
			tokens.push(t);
			t = this.nextToken();
		}
		return tokens;
	}

	notifyListeners(e) {
		const start = this._tokenStartCharIndex;
		const stop = this._input.index;
		const text = this._input.getText(start, stop);
		const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
		const listener = this.getErrorListenerDispatch();
		listener.syntaxError(this, null, this._tokenStartLine,
				this._tokenStartColumn, msg, e);
	}

	getErrorDisplay(s) {
		const d = [];
		for (let i = 0; i < s.length; i++) {
			d.push(s[i]);
		}
		return d.join('');
	}

	getErrorDisplayForChar(c) {
		if (c.charCodeAt(0) === Token.EOF) {
			return "<EOF>";
		} else if (c === '\n') {
			return "\\n";
		} else if (c === '\t') {
			return "\\t";
		} else if (c === '\r') {
			return "\\r";
		} else {
			return c;
		}
	}

	getCharErrorDisplay(c) {
		return "'" + this.getErrorDisplayForChar(c) + "'";
	}

	/**
	 * Lexers can normally match any char in it's vocabulary after matching
	 * a token, so do the easy thing and just kill a character and hope
	 * it all works out. You can instead use the rule invocation stack
	 * to do sophisticated error recovery if you are in a fragment rule.
	 */
	recover(re) {
		if (this._input.LA(1) !== Token.EOF) {
			if (re instanceof LexerNoViableAltException) {
				// skip a char and try again
				this._interp.consume(this._input);
			} else {
				// TODO: Do we lose character or line position information?
				this._input.consume();
			}
		}
	}

	get inputStream(){
		return this._input;
	}

	set inputStream(input) {
		this._input = null;
		this._tokenFactorySourcePair = [ this, this._input ];
		this.reset();
		this._input = input;
		this._tokenFactorySourcePair = [ this, this._input ];
	}

	get sourceName(){
		return this._input.sourceName;
	}

	get type(){
		return this._type;
	}

	set type(type) {
		this._type = type;
	}

	get line(){
		return this._interp.line;
	}

	set line(line) {
		this._interp.line = line;
	}

	get column(){
		return this._interp.column;
	}

	set column(column) {
		this._interp.column = column;
	}

	get text(){
		if (this._text !== null) {
			return this._text;
		} else {
			return this._interp.getText(this._input);
		}
	}

	set text(text) {
		this._text = text;
	}
}




Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;

Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0x0000;
Lexer.MAX_CHAR_VALUE = 0x10FFFF;

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function hashATNConfig(c) {
	return c.hashCodeForConfigSet();
}

function equalATNConfigs(a, b) {
	if ( a===b ) {
		return true;
	} else if ( a===null || b===null ) {
		return false;
	} else
       return a.equalsForConfigSet(b);
 }

/**
 * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track
 * info about the set, with support for combining similar configurations using a
 * graph-structured stack
 */
class ATNConfigSet {
	constructor(fullCtx) {
		/**
		 * The reason that we need this is because we don't want the hash map to use
		 * the standard hash code and equals. We need all configurations with the
		 * same
		 * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively
		 * doubles
		 * the number of objects associated with ATNConfigs. The other solution is
		 * to
		 * use a hash table that lets us specify the equals/hashcode operation.
		 * All configs but hashed by (s, i, _, pi) not including context. Wiped out
		 * when we go readonly as this set becomes a DFA state
		 */
		this.configLookup = new HashSet(hashATNConfig, equalATNConfigs);
		/**
		 * Indicates that this configuration set is part of a full context
		 * LL prediction. It will be used to determine how to merge $. With SLL
		 * it's a wildcard whereas it is not for LL context merge
		 */
		this.fullCtx = fullCtx === undefined ? true : fullCtx;
		/**
		 * Indicates that the set of configurations is read-only. Do not
		 * allow any code to manipulate the set; DFA states will point at
		 * the sets and they must not change. This does not protect the other
		 * fields; in particular, conflictingAlts is set after
		 * we've made this readonly
		 */
		this.readOnly = false;
		// Track the elements as they are added to the set; supports get(i)///
		this.configs = [];

		// TODO: these fields make me pretty uncomfortable but nice to pack up info
		// together, saves recomputation
		// TODO: can we track conflicts as they are added to save scanning configs
		// later?
		this.uniqueAlt = 0;
		this.conflictingAlts = null;

		/**
		 * Used in parser and lexer. In lexer, it indicates we hit a pred
		 * while computing a closure operation. Don't make a DFA state from this
		 */
		this.hasSemanticContext = false;
		this.dipsIntoOuterContext = false;

		this.cachedHashCode = -1;
	}

	/**
	 * Adding a new config means merging contexts with existing configs for
	 * {@code (s, i, pi, _)}, where {@code s} is the
	 * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
	 * {@code pi} is the {@link ATNConfig//semanticContext}. We use
	 * {@code (s,i,pi)} as key.
	 *
	 * <p>This method updates {@link //dipsIntoOuterContext} and
	 * {@link //hasSemanticContext} when necessary.</p>
	 */
	add(config, mergeCache) {
		if (mergeCache === undefined) {
			mergeCache = null;
		}
		if (this.readOnly) {
			throw "This set is readonly";
		}
		if (config.semanticContext !== SemanticContext.NONE) {
			this.hasSemanticContext = true;
		}
		if (config.reachesIntoOuterContext > 0) {
			this.dipsIntoOuterContext = true;
		}
		const existing = this.configLookup.add(config);
		if (existing === config) {
			this.cachedHashCode = -1;
			this.configs.push(config); // track order here
			return true;
		}
		// a previous (s,i,pi,_), merge with it and save result
		const rootIsWildcard = !this.fullCtx;
		const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
		/**
		 * no need to check for existing.context, config.context in cache
		 * since only way to create new graphs is "call rule" and here. We
		 * cache at both places
		 */
		existing.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
		// make sure to preserve the precedence filter suppression during the merge
		if (config.precedenceFilterSuppressed) {
			existing.precedenceFilterSuppressed = true;
		}
		existing.context = merged; // replace context; no need to alt mapping
		return true;
	}

	getStates() {
		const states = new HashSet();
		for (let i = 0; i < this.configs.length; i++) {
			states.add(this.configs[i].state);
		}
		return states;
	}

	getPredicates() {
		const preds = [];
		for (let i = 0; i < this.configs.length; i++) {
			const c = this.configs[i].semanticContext;
			if (c !== SemanticContext.NONE) {
				preds.push(c.semanticContext);
			}
		}
		return preds;
	}

	optimizeConfigs(interpreter) {
		if (this.readOnly) {
			throw "This set is readonly";
		}
		if (this.configLookup.length === 0) {
			return;
		}
		for (let i = 0; i < this.configs.length; i++) {
			const config = this.configs[i];
			config.context = interpreter.getCachedContext(config.context);
		}
	}

	addAll(coll) {
		for (let i = 0; i < coll.length; i++) {
			this.add(coll[i]);
		}
		return false;
	}

	equals(other) {
		return this === other ||
			(other instanceof ATNConfigSet &&
			equalArrays(this.configs, other.configs) &&
			this.fullCtx === other.fullCtx &&
			this.uniqueAlt === other.uniqueAlt &&
			this.conflictingAlts === other.conflictingAlts &&
			this.hasSemanticContext === other.hasSemanticContext &&
			this.dipsIntoOuterContext === other.dipsIntoOuterContext);
	}

	hashCode() {
		const hash = new HashCode();
		hash.update(this.configs);
		return hash.finish();
	}

	updateHashCode(hash) {
		if (this.readOnly) {
			if (this.cachedHashCode === -1) {
				this.cachedHashCode = this.hashCode();
			}
			hash.update(this.cachedHashCode);
		} else {
			hash.update(this.hashCode());
		}
	}

	isEmpty() {
		return this.configs.length === 0;
	}

	contains(item) {
		if (this.configLookup === null) {
			throw "This method is not implemented for readonly sets.";
		}
		return this.configLookup.contains(item);
	}

	containsFast(item) {
		if (this.configLookup === null) {
			throw "This method is not implemented for readonly sets.";
		}
		return this.configLookup.containsFast(item);
	}

	clear() {
		if (this.readOnly) {
			throw "This set is readonly";
		}
		this.configs = [];
		this.cachedHashCode = -1;
		this.configLookup = new HashSet();
	}

	setReadonly(readOnly) {
		this.readOnly = readOnly;
		if (readOnly) {
			this.configLookup = null; // can't mod, no need for lookup cache
		}
	}

	toString() {
		return arrayToString(this.configs) +
			(this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") +
			(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") +
			(this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") +
			(this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
	}

	get items(){
		return this.configs;
	}

	get length(){
		return this.configs.length;
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */


/**
 * A DFA state represents a set of possible ATN configurations.
 * As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
 * to keep track of all possible states the ATN can be in after
 * reading each input symbol. That is to say, after reading
 * input a1a2..an, the DFA is in a state that represents the
 * subset T of the states of the ATN that are reachable from the
 * ATN's start state along some path labeled a1a2..an."
 * In conventional NFA&rarr;DFA conversion, therefore, the subset T
 * would be a bitset representing the set of states the
 * ATN could be in. We need to track the alt predicted by each
 * state as well, however. More importantly, we need to maintain
 * a stack of states, tracking the closure operations as they
 * jump from rule to rule, emulating rule invocations (method calls).
 * I have to add a stack to simulate the proper lookahead sequences for
 * the underlying LL grammar from which the ATN was derived.
 *
 * <p>I use a set of ATNConfig objects not simple states. An ATNConfig
 * is both a state (ala normal conversion) and a RuleContext describing
 * the chain of rules (if any) followed to arrive at that state.</p>
 *
 * <p>A DFA state may have multiple references to a particular state,
 * but with different ATN contexts (with same or different alts)
 * meaning that state was reached via a different set of rule invocations.</p>
 */
class DFAState {
	constructor(stateNumber, configs) {
		if (stateNumber === null) {
			stateNumber = -1;
		}
		if (configs === null) {
			configs = new ATNConfigSet();
		}
		this.stateNumber = stateNumber;
		this.configs = configs;
		/**
		 * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
		 * {@link Token//EOF} maps to {@code edges[0]}.
		 */
		this.edges = null;
		this.isAcceptState = false;
		/**
		 * if accept state, what ttype do we match or alt do we predict?
		 * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}
		 * {@code !=null} or {@link //requiresFullContext}.
		 */
		this.prediction = 0;
		this.lexerActionExecutor = null;
		/**
		 * Indicates that this state was created during SLL prediction that
		 * discovered a conflict between the configurations in the state. Future
		 * {@link ParserATNSimulator//execATN} invocations immediately jumped doing
		 * full context prediction if this field is true.
		 */
		this.requiresFullContext = false;
		/**
		 * During SLL parsing, this is a list of predicates associated with the
		 * ATN configurations of the DFA state. When we have predicates,
		 * {@link //requiresFullContext} is {@code false} since full context
		 * prediction evaluates predicates
		 * on-the-fly. If this is not null, then {@link //prediction} is
		 * {@link ATN//INVALID_ALT_NUMBER}.
		 *
		 * <p>We only use these for non-{@link //requiresFullContext} but
		 * conflicting states. That
		 * means we know from the context (it's $ or we don't dip into outer
		 * context) that it's an ambiguity not a conflict.</p>
		 *
		 * <p>This list is computed by {@link
		 * ParserATNSimulator//predicateDFAState}.</p>
		 */
		this.predicates = null;
		return this;
	}

	/**
	 * Get the set of all alts mentioned by all ATN configurations in this
	 * DFA state.
	 */
	getAltSet() {
		const alts = new HashSet();
		if (this.configs !== null) {
			for (let i = 0; i < this.configs.length; i++) {
				const c = this.configs[i];
				alts.add(c.alt);
			}
		}
		if (alts.length === 0) {
			return null;
		} else {
			return alts;
		}
	}

	/**
	 * Two {@link DFAState} instances are equal if their ATN configuration sets
	 * are the same. This method is used to see if a state already exists.
	 *
	 * <p>Because the number of alternatives and number of ATN configurations are
	 * finite, there is a finite number of DFA states that can be processed.
	 * This is necessary to show that the algorithm terminates.</p>
	 *
	 * <p>Cannot test the DFA state numbers here because in
	 * {@link ParserATNSimulator//addDFAState} we need to know if any other state
	 * exists that has this exact set of ATN configurations. The
	 * {@link //stateNumber} is irrelevant.</p>
	 */
	equals(other) {
		// compare set of ATN configurations in this set with other
		return this === other ||
				(other instanceof DFAState &&
					this.configs.equals(other.configs));
	}

	toString() {
		let s = "" + this.stateNumber + ":" + this.configs;
		if(this.isAcceptState) {
			s = s + "=>";
			if (this.predicates !== null)
				s = s + this.predicates;
			else
				s = s + this.prediction;
		}
		return s;
	}

	hashCode() {
		const hash = new HashCode();
		hash.update(this.configs);
		return hash.finish();
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ATNSimulator {
    constructor(atn, sharedContextCache) {
        /**
         * The context cache maps all PredictionContext objects that are ==
         * to a single cached copy. This cache is shared across all contexts
         * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
         * to use only cached nodes/graphs in addDFAState(). We don't want to
         * fill this during closure() since there are lots of contexts that
         * pop up but are not used ever again. It also greatly slows down closure().
         *
         * <p>This cache makes a huge difference in memory and a little bit in speed.
         * For the Java grammar on java.*, it dropped the memory requirements
         * at the end from 25M to 16M. We don't store any of the full context
         * graphs in the DFA because they are limited to local context only,
         * but apparently there's a lot of repetition there as well. We optimize
         * the config contexts before storing the config set in the DFA states
         * by literally rebuilding them with cached subgraphs only.</p>
         *
         * <p>I tried a cache for use during closure operations, that was
         * whacked after each adaptivePredict(). It cost a little bit
         * more time I think and doesn't save on the overall footprint
         * so it's not worth the complexity.</p>
         */
        this.atn = atn;
        this.sharedContextCache = sharedContextCache;
        return this;
    }

    getCachedContext(context) {
        if (this.sharedContextCache ===null) {
            return context;
        }
        const visited = new HashMap();
        return getCachedPredictionContext(context, this.sharedContextCache, visited);
    }
}

// Must distinguish between missing edge and edge we know leads nowhere///
ATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class OrderedATNConfigSet extends ATNConfigSet {
    constructor() {
        super();
        this.configLookup = new HashSet();
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class LexerATNConfig extends ATNConfig {
    constructor(params, config) {
        super(params, config);

        // This is the backing field for {@link //getLexerActionExecutor}.
        const lexerActionExecutor = params.lexerActionExecutor || null;
        this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);
        this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;
        this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;
        this.equalsForConfigSet = LexerATNConfig.prototype.equals;
        return this;
    }

    updateHashCode(hash) {
        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
    }

    equals(other) {
        return this === other ||
            (other instanceof LexerATNConfig &&
                this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision &&
                (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&
                super.equals(other));
    }

    checkNonGreedyDecision(source, target) {
        return source.passedThroughNonGreedyDecision ||
            (target instanceof DecisionState) && target.nonGreedy;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */


class LexerIndexedCustomAction extends LexerAction {
    constructor(offset, action) {
        super(action.actionType);
        this.offset = offset;
        this.action = action;
        this.isPositionDependent = true;
    }

    /**
     * <p>This method calls {@link //execute} on the result of {@link //getAction}
     * using the provided {@code lexer}.</p>
     */
    execute(lexer) {
        // assume the input stream position was properly set by the calling code
        this.action.execute(lexer);
    }

    updateHashCode(hash) {
        hash.update(this.actionType, this.offset, this.action);
    }

    equals(other) {
        if (this === other) {
            return true;
        } else if (! (other instanceof LexerIndexedCustomAction)) {
            return false;
        } else {
            return this.offset === other.offset && this.action === other.action;
        }
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class LexerActionExecutor {
	/**
	 * Represents an executor for a sequence of lexer actions which traversed during
	 * the matching operation of a lexer rule (token).
	 *
	 * <p>The executor tracks position information for position-dependent lexer actions
	 * efficiently, ensuring that actions appearing only at the end of the rule do
	 * not cause bloating of the {@link DFA} created for the lexer.</p>
	 */
	constructor(lexerActions) {
		this.lexerActions = lexerActions === null ? [] : lexerActions;
		/**
		 * Caches the result of {@link //hashCode} since the hash code is an element
		 * of the performance-critical {@link LexerATNConfig//hashCode} operation
		 */
		this.cachedHashCode = HashCode.hashStuff(lexerActions); // "".join([str(la) for la in
		// lexerActions]))
		return this;
	}

	/**
	 * Creates a {@link LexerActionExecutor} which encodes the current offset
	 * for position-dependent lexer actions.
	 *
	 * <p>Normally, when the executor encounters lexer actions where
	 * {@link LexerAction//isPositionDependent} returns {@code true}, it calls
	 * {@link IntStream//seek} on the input {@link CharStream} to set the input
	 * position to the <em>end</em> of the current token. This behavior provides
	 * for efficient DFA representation of lexer actions which appear at the end
	 * of a lexer rule, even when the lexer rule matches a variable number of
	 * characters.</p>
	 *
	 * <p>Prior to traversing a match transition in the ATN, the current offset
	 * from the token start index is assigned to all position-dependent lexer
	 * actions which have not already been assigned a fixed offset. By storing
	 * the offsets relative to the token start index, the DFA representation of
	 * lexer actions which appear in the middle of tokens remains efficient due
	 * to sharing among tokens of the same length, regardless of their absolute
	 * position in the input stream.</p>
	 *
	 * <p>If the current executor already has offsets assigned to all
	 * position-dependent lexer actions, the method returns {@code this}.</p>
	 *
	 * @param offset The current offset to assign to all position-dependent
	 * lexer actions which do not already have offsets assigned.
	 *
	 * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
	 * for all position-dependent lexer actions.
	 */
	fixOffsetBeforeMatch(offset) {
		let updatedLexerActions = null;
		for (let i = 0; i < this.lexerActions.length; i++) {
			if (this.lexerActions[i].isPositionDependent &&
					!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
				if (updatedLexerActions === null) {
					updatedLexerActions = this.lexerActions.concat([]);
				}
				updatedLexerActions[i] = new LexerIndexedCustomAction(offset,
						this.lexerActions[i]);
			}
		}
		if (updatedLexerActions === null) {
			return this;
		} else {
			return new LexerActionExecutor(updatedLexerActions);
		}
	}

	/**
	 * Execute the actions encapsulated by this executor within the context of a
	 * particular {@link Lexer}.
	 *
	 * <p>This method calls {@link IntStream//seek} to set the position of the
	 * {@code input} {@link CharStream} prior to calling
	 * {@link LexerAction//execute} on a position-dependent action. Before the
	 * method returns, the input position will be restored to the same position
	 * it was in when the method was invoked.</p>
	 *
	 * @param lexer The lexer instance.
	 * @param input The input stream which is the source for the current token.
	 * When this method is called, the current {@link IntStream//index} for
	 * {@code input} should be the start of the following token, i.e. 1
	 * character past the end of the current token.
	 * @param startIndex The token start index. This value may be passed to
	 * {@link IntStream//seek} to set the {@code input} position to the beginning
	 * of the token.
	 */
	execute(lexer, input, startIndex) {
		let requiresSeek = false;
		const stopIndex = input.index;
		try {
			for (let i = 0; i < this.lexerActions.length; i++) {
				let lexerAction = this.lexerActions[i];
				if (lexerAction instanceof LexerIndexedCustomAction) {
					const offset = lexerAction.offset;
					input.seek(startIndex + offset);
					lexerAction = lexerAction.action;
					requiresSeek = (startIndex + offset) !== stopIndex;
				} else if (lexerAction.isPositionDependent) {
					input.seek(stopIndex);
					requiresSeek = false;
				}
				lexerAction.execute(lexer);
			}
		} finally {
			if (requiresSeek) {
				input.seek(stopIndex);
			}
		}
	}

	hashCode() {
		return this.cachedHashCode;
	}

	updateHashCode(hash) {
		hash.update(this.cachedHashCode);
	}

	equals(other) {
		if (this === other) {
			return true;
		} else if (!(other instanceof LexerActionExecutor)) {
			return false;
		} else if (this.cachedHashCode != other.cachedHashCode) {
			return false;
		} else if (this.lexerActions.length != other.lexerActions.length) {
			return false;
		} else {
			const numActions = this.lexerActions.length;
			for (let idx = 0; idx < numActions; ++idx) {
				if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
					return false;
				}
			}
			return true;
		}
	}

	/**
	 * Creates a {@link LexerActionExecutor} which executes the actions for
	 * the input {@code lexerActionExecutor} followed by a specified
	 * {@code lexerAction}.
	 *
	 * @param lexerActionExecutor The executor for actions already traversed by
	 * the lexer while matching a token within a particular
	 * {@link LexerATNConfig}. If this is {@code null}, the method behaves as
	 * though it were an empty executor.
	 * @param lexerAction The lexer action to execute after the actions
	 * specified in {@code lexerActionExecutor}.
	 *
	 * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
	 * of {@code lexerActionExecutor} and {@code lexerAction}.
	 */
	static append(lexerActionExecutor, lexerAction) {
		if (lexerActionExecutor === null) {
			return new LexerActionExecutor([ lexerAction ]);
		}
		const lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);
		return new LexerActionExecutor(lexerActions);
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function resetSimState(sim) {
    sim.index = -1;
    sim.line = 0;
    sim.column = -1;
    sim.dfaState = null;
}

class SimState {
    constructor() {
        resetSimState(this);
    }

    reset() {
        resetSimState(this);
    }
}

class LexerATNSimulator extends ATNSimulator {
    /**
     * When we hit an accept state in either the DFA or the ATN, we
     * have to notify the character stream to start buffering characters
     * via {@link IntStream//mark} and record the current state. The current sim state
     * includes the current index into the input, the current line,
     * and current character position in that line. Note that the Lexer is
     * tracking the starting line and characterization of the token. These
     * variables track the "state" of the simulator when it hits an accept state.
     *
     * <p>We track these variables separately for the DFA and ATN simulation
     * because the DFA simulation often has to fail over to the ATN
     * simulation. If the ATN simulation fails, we need the DFA to fall
     * back to its previously accepted state, if any. If the ATN succeeds,
     * then the ATN does the accept and the DFA simulator that invoked it
     * can simply return the predicted token type.</p>
     */
    constructor(recog, atn, decisionToDFA, sharedContextCache) {
        super(atn, sharedContextCache);
        this.decisionToDFA = decisionToDFA;
        this.recog = recog;
        /**
         * The current token's starting index into the character stream.
         * Shared across DFA to ATN simulation in case the ATN fails and the
         * DFA did not have a previous accept state. In this case, we use the
         * ATN-generated exception object
         */
        this.startIndex = -1;
        // line number 1..n within the input///
        this.line = 1;
        /**
         * The index of the character relative to the beginning of the line
         * 0..n-1
         */
        this.column = 0;
        this.mode = Lexer.DEFAULT_MODE;
        /**
         * Used during DFA/ATN exec to record the most recent accept configuration
         * info
         */
        this.prevAccept = new SimState();
    }

    copyState(simulator) {
        this.column = simulator.column;
        this.line = simulator.line;
        this.mode = simulator.mode;
        this.startIndex = simulator.startIndex;
    }

    match(input, mode) {
        this.mode = mode;
        const mark = input.mark();
        try {
            this.startIndex = input.index;
            this.prevAccept.reset();
            const dfa = this.decisionToDFA[mode];
            if (dfa.s0 === null) {
                return this.matchATN(input);
            } else {
                return this.execATN(input, dfa.s0);
            }
        } finally {
            input.release(mark);
        }
    }

    reset() {
        this.prevAccept.reset();
        this.startIndex = -1;
        this.line = 1;
        this.column = 0;
        this.mode = Lexer.DEFAULT_MODE;
    }

    matchATN(input) {
        const startState = this.atn.modeToStartState[this.mode];

        if (LexerATNSimulator.debug) {
            console.log("matchATN mode " + this.mode + " start: " + startState);
        }
        const old_mode = this.mode;
        const s0_closure = this.computeStartState(input, startState);
        const suppressEdge = s0_closure.hasSemanticContext;
        s0_closure.hasSemanticContext = false;

        const next = this.addDFAState(s0_closure);
        if (!suppressEdge) {
            this.decisionToDFA[this.mode].s0 = next;
        }

        const predict = this.execATN(input, next);

        if (LexerATNSimulator.debug) {
            console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
        }
        return predict;
    }

    execATN(input, ds0) {
        if (LexerATNSimulator.debug) {
            console.log("start state closure=" + ds0.configs);
        }
        if (ds0.isAcceptState) {
            // allow zero-length tokens
            this.captureSimState(this.prevAccept, input, ds0);
        }
        let t = input.LA(1);
        let s = ds0; // s is current/from DFA state

        for (; ;) { // while more work
            if (LexerATNSimulator.debug) {
                console.log("execATN loop starting closure: " + s.configs);
            }

            /**
             * As we move src->trg, src->trg, we keep track of the previous trg to
             * avoid looking up the DFA state again, which is expensive.
             * If the previous target was already part of the DFA, we might
             * be able to avoid doing a reach operation upon t. If s!=null,
             * it means that semantic predicates didn't prevent us from
             * creating a DFA state. Once we know s!=null, we check to see if
             * the DFA state has an edge already for t. If so, we can just reuse
             * it's configuration set; there's no point in re-computing it.
             * This is kind of like doing DFA simulation within the ATN
             * simulation because DFA simulation is really just a way to avoid
             * computing reach/closure sets. Technically, once we know that
             * we have a previously added DFA state, we could jump over to
             * the DFA simulator. But, that would mean popping back and forth
             * a lot and making things more complicated algorithmically.
             * This optimization makes a lot of sense for loops within DFA.
             * A character will take us back to an existing DFA state
             * that already has lots of edges out of it. e.g., .* in comments.
             * print("Target for:" + str(s) + " and:" + str(t))
             */
            let target = this.getExistingTargetState(s, t);
            // print("Existing:" + str(target))
            if (target === null) {
                target = this.computeTargetState(input, s, t);
                // print("Computed:" + str(target))
            }
            if (target === ATNSimulator.ERROR) {
                break;
            }
            // If this is a consumable input element, make sure to consume before
            // capturing the accept state so the input index, line, and char
            // position accurately reflect the state of the interpreter at the
            // end of the token.
            if (t !== Token.EOF) {
                this.consume(input);
            }
            if (target.isAcceptState) {
                this.captureSimState(this.prevAccept, input, target);
                if (t === Token.EOF) {
                    break;
                }
            }
            t = input.LA(1);
            s = target; // flip; current DFA target becomes new src/from state
        }
        return this.failOrAccept(this.prevAccept, input, s.configs, t);
    }

    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns {@code null}.
     *
     * @param s The current DFA state
     * @param t The next input symbol
     * @return The existing target DFA state for the given input symbol
     * {@code t}, or {@code null} if the target state for this edge is not
     * already cached
     */
    getExistingTargetState(s, t) {
        if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
            return null;
        }

        let target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];
        if (target === undefined) {
            target = null;
        }
        if (LexerATNSimulator.debug && target !== null) {
            console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
        }
        return target;
    }

    /**
     * Compute a target state for an edge in the DFA, and attempt to add the
     * computed state and corresponding edge to the DFA.
     *
     * @param input The input stream
     * @param s The current DFA state
     * @param t The next input symbol
     *
     * @return The computed target DFA state for the given input symbol
     * {@code t}. If {@code t} does not lead to a valid DFA state, this method
     * returns {@link //ERROR}.
     */
    computeTargetState(input, s, t) {
        const reach = new OrderedATNConfigSet();
        // if we don't find an existing DFA state
        // Fill reach starting from closure, following t transitions
        this.getReachableConfigSet(input, s.configs, reach, t);

        if (reach.items.length === 0) { // we got nowhere on t from s
            if (!reach.hasSemanticContext) {
                // we got nowhere on t, don't throw out this knowledge; it'd
                // cause a failover from DFA later.
                this.addDFAEdge(s, t, ATNSimulator.ERROR);
            }
            // stop when we can't match any more char
            return ATNSimulator.ERROR;
        }
        // Add an edge from s to target DFA found/created for reach
        return this.addDFAEdge(s, t, null, reach);
    }

    failOrAccept(prevAccept, input, reach, t) {
        if (this.prevAccept.dfaState !== null) {
            const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
            this.accept(input, lexerActionExecutor, this.startIndex,
                prevAccept.index, prevAccept.line, prevAccept.column);
            return prevAccept.dfaState.prediction;
        } else {
            // if no accept and EOF is first char, return EOF
            if (t === Token.EOF && input.index === this.startIndex) {
                return Token.EOF;
            }
            throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
        }
    }

    /**
     * Given a starting configuration set, figure out all ATN configurations
     * we can reach upon input {@code t}. Parameter {@code reach} is a return
     * parameter.
     */
    getReachableConfigSet(input, closure, reach, t) {
        // this is used to skip processing for configs which have a lower priority
        // than a config that already reached an accept state for the same rule
        let skipAlt = ATN.INVALID_ALT_NUMBER;
        for (let i = 0; i < closure.items.length; i++) {
            const cfg = closure.items[i];
            const currentAltReachedAcceptState = (cfg.alt === skipAlt);
            if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
                continue;
            }
            if (LexerATNSimulator.debug) {
                console.log("testing %s at %s\n", this.getTokenName(t), cfg
                    .toString(this.recog, true));
            }
            for (let j = 0; j < cfg.state.transitions.length; j++) {
                const trans = cfg.state.transitions[j]; // for each transition
                const target = this.getReachableTarget(trans, t);
                if (target !== null) {
                    let lexerActionExecutor = cfg.lexerActionExecutor;
                    if (lexerActionExecutor !== null) {
                        lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                    }
                    const treatEofAsEpsilon = (t === Token.EOF);
                    const config = new LexerATNConfig({state: target, lexerActionExecutor: lexerActionExecutor}, cfg);
                    if (this.closure(input, config, reach,
                        currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                        // any remaining configs for this alt have a lower priority
                        // than the one that just reached an accept state.
                        skipAlt = cfg.alt;
                    }
                }
            }
        }
    }

    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
        if (LexerATNSimulator.debug) {
            console.log("ACTION %s\n", lexerActionExecutor);
        }
        // seek to after last char in token
        input.seek(index);
        this.line = line;
        this.column = charPos;
        if (lexerActionExecutor !== null && this.recog !== null) {
            lexerActionExecutor.execute(this.recog, input, startIndex);
        }
    }

    getReachableTarget(trans, t) {
        if (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {
            return trans.target;
        } else {
            return null;
        }
    }

    computeStartState(input, p) {
        const initialContext = PredictionContext.EMPTY;
        const configs = new OrderedATNConfigSet();
        for (let i = 0; i < p.transitions.length; i++) {
            const target = p.transitions[i].target;
            const cfg = new LexerATNConfig({state: target, alt: i + 1, context: initialContext}, null);
            this.closure(input, cfg, configs, false, false, false);
        }
        return configs;
    }

    /**
     * Since the alternatives within any lexer decision are ordered by
     * preference, this method stops pursuing the closure as soon as an accept
     * state is reached. After the first accept state is reached by depth-first
     * search from {@code config}, all other (potentially reachable) states for
     * this rule would have a lower priority.
     *
     * @return {Boolean} {@code true} if an accept state is reached, otherwise
     * {@code false}.
     */
    closure(input, config, configs,
            currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
        let cfg = null;
        if (LexerATNSimulator.debug) {
            console.log("closure(" + config.toString(this.recog, true) + ")");
        }
        if (config.state instanceof RuleStopState) {
            if (LexerATNSimulator.debug) {
                if (this.recog !== null) {
                    console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
                } else {
                    console.log("closure at rule stop %s\n", config);
                }
            }
            if (config.context === null || config.context.hasEmptyPath()) {
                if (config.context === null || config.context.isEmpty()) {
                    configs.add(config);
                    return true;
                } else {
                    configs.add(new LexerATNConfig({state: config.state, context: PredictionContext.EMPTY}, config));
                    currentAltReachedAcceptState = true;
                }
            }
            if (config.context !== null && !config.context.isEmpty()) {
                for (let i = 0; i < config.context.length; i++) {
                    if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
                        const newContext = config.context.getParent(i); // "pop" return state
                        const returnState = this.atn.states[config.context.getReturnState(i)];
                        cfg = new LexerATNConfig({state: returnState, context: newContext}, config);
                        currentAltReachedAcceptState = this.closure(input, cfg,
                            configs, currentAltReachedAcceptState, speculative,
                            treatEofAsEpsilon);
                    }
                }
            }
            return currentAltReachedAcceptState;
        }
        // optimization
        if (!config.state.epsilonOnlyTransitions) {
            if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
                configs.add(config);
            }
        }
        for (let j = 0; j < config.state.transitions.length; j++) {
            const trans = config.state.transitions[j];
            cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
            if (cfg !== null) {
                currentAltReachedAcceptState = this.closure(input, cfg, configs,
                    currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
            }
        }
        return currentAltReachedAcceptState;
    }

    // side-effect: can alter configs.hasSemanticContext
    getEpsilonTarget(input, config, trans,
                     configs, speculative, treatEofAsEpsilon) {
        let cfg = null;
        if (trans.serializationType === Transition.RULE) {
            const newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
            cfg = new LexerATNConfig({state: trans.target, context: newContext}, config);
        } else if (trans.serializationType === Transition.PRECEDENCE) {
            throw "Precedence predicates are not supported in lexers.";
        } else if (trans.serializationType === Transition.PREDICATE) {
            // Track traversing semantic predicates. If we traverse,
            // we cannot add a DFA state for this "reach" computation
            // because the DFA would not test the predicate again in the
            // future. Rather than creating collections of semantic predicates
            // like v3 and testing them on prediction, v4 will test them on the
            // fly all the time using the ATN not the DFA. This is slower but
            // semantically it's not used that often. One of the key elements to
            // this predicate mechanism is not adding DFA states that see
            // predicates immediately afterwards in the ATN. For example,

            // a : ID {p1}? | ID {p2}? ;

            // should create the start state for rule 'a' (to save start state
            // competition), but should not create target of ID state. The
            // collection of ATN states the following ID references includes
            // states reached by traversing predicates. Since this is when we
            // test them, we cannot cash the DFA state target of ID.

            if (LexerATNSimulator.debug) {
                console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
            }
            configs.hasSemanticContext = true;
            if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
                cfg = new LexerATNConfig({state: trans.target}, config);
            }
        } else if (trans.serializationType === Transition.ACTION) {
            if (config.context === null || config.context.hasEmptyPath()) {
                // execute actions anywhere in the start rule for a token.
                //
                // TODO: if the entry rule is invoked recursively, some
                // actions may be executed during the recursive call. The
                // problem can appear when hasEmptyPath() is true but
                // isEmpty() is false. In this case, the config needs to be
                // split into two contexts - one with just the empty path
                // and another with everything but the empty path.
                // Unfortunately, the current algorithm does not allow
                // getEpsilonTarget to return two configurations, so
                // additional modifications are needed before we can support
                // the split operation.
                const lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,
                    this.atn.lexerActions[trans.actionIndex]);
                cfg = new LexerATNConfig({state: trans.target, lexerActionExecutor: lexerActionExecutor}, config);
            } else {
                // ignore actions in referenced rules
                cfg = new LexerATNConfig({state: trans.target}, config);
            }
        } else if (trans.serializationType === Transition.EPSILON) {
            cfg = new LexerATNConfig({state: trans.target}, config);
        } else if (trans.serializationType === Transition.ATOM ||
            trans.serializationType === Transition.RANGE ||
            trans.serializationType === Transition.SET) {
            if (treatEofAsEpsilon) {
                if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {
                    cfg = new LexerATNConfig({state: trans.target}, config);
                }
            }
        }
        return cfg;
    }

    /**
     * Evaluate a predicate specified in the lexer.
     *
     * <p>If {@code speculative} is {@code true}, this method was called before
     * {@link //consume} for the matched character. This method should call
     * {@link //consume} before evaluating the predicate to ensure position
     * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
     * and {@link Lexer//getcolumn}, properly reflect the current
     * lexer state. This method should restore {@code input} and the simulator
     * to the original state before returning (i.e. undo the actions made by the
     * call to {@link //consume}.</p>
     *
     * @param input The input stream.
     * @param ruleIndex The rule containing the predicate.
     * @param predIndex The index of the predicate within the rule.
     * @param speculative {@code true} if the current index in {@code input} is
     * one character before the predicate's location.
     *
     * @return {@code true} if the specified predicate evaluates to
     * {@code true}.
     */
    evaluatePredicate(input, ruleIndex,
                      predIndex, speculative) {
        // assume true if no recognizer was provided
        if (this.recog === null) {
            return true;
        }
        if (!speculative) {
            return this.recog.sempred(null, ruleIndex, predIndex);
        }
        const savedcolumn = this.column;
        const savedLine = this.line;
        const index = input.index;
        const marker = input.mark();
        try {
            this.consume(input);
            return this.recog.sempred(null, ruleIndex, predIndex);
        } finally {
            this.column = savedcolumn;
            this.line = savedLine;
            input.seek(index);
            input.release(marker);
        }
    }

    captureSimState(settings, input, dfaState) {
        settings.index = input.index;
        settings.line = this.line;
        settings.column = this.column;
        settings.dfaState = dfaState;
    }

    addDFAEdge(from_, tk, to, cfgs) {
        if (to === undefined) {
            to = null;
        }
        if (cfgs === undefined) {
            cfgs = null;
        }
        if (to === null && cfgs !== null) {
            // leading to this call, ATNConfigSet.hasSemanticContext is used as a
            // marker indicating dynamic predicate evaluation makes this edge
            // dependent on the specific input sequence, so the static edge in the
            // DFA should be omitted. The target DFAState is still created since
            // execATN has the ability to resynchronize with the DFA state cache
            // following the predicate evaluation step.
            //
            // TJP notes: next time through the DFA, we see a pred again and eval.
            // If that gets us to a previously created (but dangling) DFA
            // state, we can continue in pure DFA mode from there.
            // /
            const suppressEdge = cfgs.hasSemanticContext;
            cfgs.hasSemanticContext = false;

            to = this.addDFAState(cfgs);

            if (suppressEdge) {
                return to;
            }
        }
        // add the edge
        if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
            // Only track edges within the DFA bounds
            return to;
        }
        if (LexerATNSimulator.debug) {
            console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
        }
        if (from_.edges === null) {
            // make room for tokens 1..n and -1 masquerading as index 0
            from_.edges = [];
        }
        from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect

        return to;
    }

    /**
     * Add a new DFA state if there isn't one with this set of
     * configurations already. This method also detects the first
     * configuration containing an ATN rule stop state. Later, when
     * traversing the DFA, we will know which rule to accept.
     */
    addDFAState(configs) {
        const proposed = new DFAState(null, configs);
        let firstConfigWithRuleStopState = null;
        for (let i = 0; i < configs.items.length; i++) {
            const cfg = configs.items[i];
            if (cfg.state instanceof RuleStopState) {
                firstConfigWithRuleStopState = cfg;
                break;
            }
        }
        if (firstConfigWithRuleStopState !== null) {
            proposed.isAcceptState = true;
            proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
            proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
        }
        const dfa = this.decisionToDFA[this.mode];
        const existing = dfa.states.get(proposed);
        if (existing !== null) {
            return existing;
        }
        const newState = proposed;
        newState.stateNumber = dfa.states.length;
        configs.setReadonly(true);
        newState.configs = configs;
        dfa.states.add(newState);
        return newState;
    }

    getDFA(mode) {
        return this.decisionToDFA[mode];
    }

// Get the text matched so far for the current token.
    getText(input) {
        // index is first lookahead char, don't include.
        return input.getText(this.startIndex, input.index - 1);
    }

    consume(input) {
        const curChar = input.LA(1);
        if (curChar === "\n".charCodeAt(0)) {
            this.line += 1;
            this.column = 0;
        } else {
            this.column += 1;
        }
        input.consume();
    }

    getTokenName(tt) {
        if (tt === -1) {
            return "EOF";
        } else {
            return "'" + String.fromCharCode(tt) + "'";
        }
    }
}

LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;

LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/**
 * Map a predicate to a predicted alternative.
 */
class PredPrediction {
    constructor(pred, alt) {
        this.alt = alt;
        this.pred = pred;
    }

    toString() {
        return "(" + this.pred + ", " + this.alt + ")";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class AltDict {

    constructor() {
        this.data = {};
    }

    get(key) {
        return this.data["k-" + key] || null;
    }

    set(key, value) {
        this.data["k-" + key] = value;
    }

    values() {
        return Object.keys(this.data).filter(key => key.startsWith("k-")).map(key => this.data[key], this);
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * This enumeration defines the prediction modes available in ANTLR 4 along with
 * utility methods for analyzing configuration sets for conflicts and/or
 * ambiguities.
 */
const PredictionMode = {
    /**
     * The SLL(*) prediction mode. This prediction mode ignores the current
     * parser context when making predictions. This is the fastest prediction
     * mode, and provides correct results for many grammars. This prediction
     * mode is more powerful than the prediction mode provided by ANTLR 3, but
     * may result in syntax errors for grammar and input combinations which are
     * not SLL.
     *
     * <p>
     * When using this prediction mode, the parser will either return a correct
     * parse tree (i.e. the same parse tree that would be returned with the
     * {@link //LL} prediction mode), or it will report a syntax error. If a
     * syntax error is encountered when using the {@link //SLL} prediction mode,
     * it may be due to either an actual syntax error in the input or indicate
     * that the particular combination of grammar and input requires the more
     * powerful {@link //LL} prediction abilities to complete successfully.</p>
     *
     * <p>
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.</p>
     */
    SLL: 0,

    /**
     * The LL(*) prediction mode. This prediction mode allows the current parser
     * context to be used for resolving SLL conflicts that occur during
     * prediction. This is the fastest prediction mode that guarantees correct
     * parse results for all combinations of grammars with syntactically correct
     * inputs.
     *
     * <p>
     * When using this prediction mode, the parser will make correct decisions
     * for all syntactically-correct grammar and input combinations. However, in
     * cases where the grammar is truly ambiguous this prediction mode might not
     * report a precise answer for <em>exactly which</em> alternatives are
     * ambiguous.</p>
     *
     * <p>
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.</p>
     */
    LL: 1,

    /**
     *
     * The LL(*) prediction mode with exact ambiguity detection. In addition to
     * the correctness guarantees provided by the {@link //LL} prediction mode,
     * this prediction mode instructs the prediction algorithm to determine the
     * complete and exact set of ambiguous alternatives for every ambiguous
     * decision encountered while parsing.
     *
     * <p>
     * This prediction mode may be used for diagnosing ambiguities during
     * grammar development. Due to the performance overhead of calculating sets
     * of ambiguous alternatives, this prediction mode should be avoided when
     * the exact results are not necessary.</p>
     *
     * <p>
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.</p>
     */
    LL_EXACT_AMBIG_DETECTION: 2,

    /**
     *
     * Computes the SLL prediction termination condition.
     *
     * <p>
     * This method computes the SLL prediction termination condition for both of
     * the following cases.</p>
     *
     * <ul>
     * <li>The usual SLL+LL fallback upon SLL conflict</li>
     * <li>Pure SLL without LL fallback</li>
     * </ul>
     *
     * <p><strong>COMBINED SLL+LL PARSING</strong></p>
     *
     * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
     * ensured regardless of how the termination condition is computed by this
     * method. Due to the substantially higher cost of LL prediction, the
     * prediction should only fall back to LL when the additional lookahead
     * cannot lead to a unique SLL prediction.</p>
     *
     * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
     * conflicting subsets should fall back to full LL, even if the
     * configuration sets don't resolve to the same alternative (e.g.
     * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
     * configuration, SLL could continue with the hopes that more lookahead will
     * resolve via one of those non-conflicting configurations.</p>
     *
     * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
     * stops when it sees only conflicting configuration subsets. In contrast,
     * full LL keeps going when there is uncertainty.</p>
     *
     * <p><strong>HEURISTIC</strong></p>
     *
     * <p>As a heuristic, we stop prediction when we see any conflicting subset
     * unless we see a state that only has one alternative associated with it.
     * The single-alt-state thing lets prediction continue upon rules like
     * (otherwise, it would admit defeat too soon):</p>
     *
     * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
     *
     * <p>When the ATN simulation reaches the state before {@code ';'}, it has a
     * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
     * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
     * processing this node because alternative to has another way to continue,
     * via {@code [6|2|[]]}.</p>
     *
     * <p>It also let's us continue for this rule:</p>
     *
     * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
     *
     * <p>After matching input A, we reach the stop state for rule A, state 1.
     * State 8 is the state right before B. Clearly alternatives 1 and 2
     * conflict and no amount of further lookahead will separate the two.
     * However, alternative 3 will be able to continue and so we do not stop
     * working on this state. In the previous example, we're concerned with
     * states associated with the conflicting alternatives. Here alt 3 is not
     * associated with the conflicting configs, but since we can continue
     * looking for input reasonably, don't declare the state done.</p>
     *
     * <p><strong>PURE SLL PARSING</strong></p>
     *
     * <p>To handle pure SLL parsing, all we have to do is make sure that we
     * combine stack contexts for configurations that differ only by semantic
     * predicate. From there, we can do the usual SLL termination heuristic.</p>
     *
     * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
     *
     * <p>SLL decisions don't evaluate predicates until after they reach DFA stop
     * states because they need to create the DFA cache that works in all
     * semantic situations. In contrast, full LL evaluates predicates collected
     * during start state computation so it can ignore predicates thereafter.
     * This means that SLL termination detection can totally ignore semantic
     * predicates.</p>
     *
     * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
     * semantic predicate contexts so we might see two configurations like the
     * following.</p>
     *
     * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
     *
     * <p>Before testing these configurations against others, we have to merge
     * {@code x} and {@code x'} (without modifying the existing configurations).
     * For example, we test {@code (x+x')==x''} when looking for conflicts in
     * the following configurations.</p>
     *
     * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
     *
     * <p>If the configuration set has predicates (as indicated by
     * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
     * the configurations to strip out all of the predicates so that a standard
     * {@link ATNConfigSet} will merge everything ignoring predicates.</p>
     */
    hasSLLConflictTerminatingPrediction: function( mode, configs) {
        // Configs in rule stop states indicate reaching the end of the decision
        // rule (local context) or end of start rule (full context). If all
        // configs meet this condition, then none of the configurations is able
        // to match additional input so we terminate prediction.
        //
        if (PredictionMode.allConfigsInRuleStopStates(configs)) {
            return true;
        }
        // pure SLL mode parsing
        if (mode === PredictionMode.SLL) {
            // Don't bother with combining configs from different semantic
            // contexts if we can fail over to full LL; costs more time
            // since we'll often fail over anyway.
            if (configs.hasSemanticContext) {
                // dup configs, tossing out semantic predicates
                const dup = new ATNConfigSet();
                for(let i=0;i<configs.items.length;i++) {
                    let c = configs.items[i];
                    c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);
                    dup.add(c);
                }
                configs = dup;
            }
            // now we have combined contexts for configs with dissimilar preds
        }
        // pure SLL or combined SLL+LL mode parsing
        const altsets = PredictionMode.getConflictingAltSubsets(configs);
        return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
    },

    /**
     * Checks if any configuration in {@code configs} is in a
     * {@link RuleStopState}. Configurations meeting this condition have reached
     * the end of the decision rule (local context) or end of start rule (full
     * context).
     *
     * @param configs the configuration set to test
     * @return {@code true} if any configuration in {@code configs} is in a
     * {@link RuleStopState}, otherwise {@code false}
     */
    hasConfigInRuleStopState: function(configs) {
        for(let i=0;i<configs.items.length;i++) {
            const c = configs.items[i];
            if (c.state instanceof RuleStopState) {
                return true;
            }
        }
        return false;
    },

    /**
     * Checks if all configurations in {@code configs} are in a
     * {@link RuleStopState}. Configurations meeting this condition have reached
     * the end of the decision rule (local context) or end of start rule (full
     * context).
     *
     * @param configs the configuration set to test
     * @return {@code true} if all configurations in {@code configs} are in a
     * {@link RuleStopState}, otherwise {@code false}
     */
    allConfigsInRuleStopStates: function(configs) {
        for(let i=0;i<configs.items.length;i++) {
            const c = configs.items[i];
            if (!(c.state instanceof RuleStopState)) {
                return false;
            }
        }
        return true;
    },

    /**
     *
     * Full LL prediction termination.
     *
     * <p>Can we stop looking ahead during ATN simulation or is there some
     * uncertainty as to which alternative we will ultimately pick, after
     * consuming more input? Even if there are partial conflicts, we might know
     * that everything is going to resolve to the same minimum alternative. That
     * means we can stop since no more lookahead will change that fact. On the
     * other hand, there might be multiple conflicts that resolve to different
     * minimums. That means we need more look ahead to decide which of those
     * alternatives we should predict.</p>
     *
     * <p>The basic idea is to split the set of configurations {@code C}, into
     * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
     * non-conflicting configurations. Two configurations conflict if they have
     * identical {@link ATNConfig//state} and {@link ATNConfig//context} values
     * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
     * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
     *
     * <p>Reduce these configuration subsets to the set of possible alternatives.
     * You can compute the alternative subsets in one pass as follows:</p>
     *
     * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
     * {@code C} holding {@code s} and {@code ctx} fixed.</p>
     *
     * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
     *
     * <pre>
     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
     * alt and not pred
     * </pre>
     *
     * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
     *
     * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
     * {@code s} and {@code ctx}.</p>
     *
     * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
     * the union of these alternative subsets is a singleton, then no amount of
     * more lookahead will help us. We will always pick that alternative. If,
     * however, there is more than one alternative, then we are uncertain which
     * alternative to predict and must continue looking for resolution. We may
     * or may not discover an ambiguity in the future, even if there are no
     * conflicting subsets this round.</p>
     *
     * <p>The biggest sin is to terminate early because it means we've made a
     * decision but were uncertain as to the eventual outcome. We haven't used
     * enough lookahead. On the other hand, announcing a conflict too late is no
     * big deal; you will still have the conflict. It's just inefficient. It
     * might even look until the end of file.</p>
     *
     * <p>No special consideration for semantic predicates is required because
     * predicates are evaluated on-the-fly for full LL prediction, ensuring that
     * no configuration contains a semantic context during the termination
     * check.</p>
     *
     * <p><strong>CONFLICTING CONFIGS</strong></p>
     *
     * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
     * when {@code i!=j} but {@code x=x'}. Because we merge all
     * {@code (s, i, _)} configurations together, that means that there are at
     * most {@code n} configurations associated with state {@code s} for
     * {@code n} possible alternatives in the decision. The merged stacks
     * complicate the comparison of configuration contexts {@code x} and
     * {@code x'}. Sam checks to see if one is a subset of the other by calling
     * merge and checking to see if the merged result is either {@code x} or
     * {@code x'}. If the {@code x} associated with lowest alternative {@code i}
     * is the superset, then {@code i} is the only possible prediction since the
     * others resolve to {@code min(i)} as well. However, if {@code x} is
     * associated with {@code j>i} then at least one stack configuration for
     * {@code j} is not in conflict with alternative {@code i}. The algorithm
     * should keep going, looking for more lookahead due to the uncertainty.</p>
     *
     * <p>For simplicity, I'm doing a equality check between {@code x} and
     * {@code x'} that lets the algorithm continue to consume lookahead longer
     * than necessary. The reason I like the equality is of course the
     * simplicity but also because that is the test you need to detect the
     * alternatives that are actually in conflict.</p>
     *
     * <p><strong>CONTINUE/STOP RULE</strong></p>
     *
     * <p>Continue if union of resolved alternative sets from non-conflicting and
     * conflicting alternative subsets has more than one alternative. We are
     * uncertain about which alternative to predict.</p>
     *
     * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
     * alternatives are still in the running for the amount of input we've
     * consumed at this point. The conflicting sets let us to strip away
     * configurations that won't lead to more states because we resolve
     * conflicts to the configuration with a minimum alternate for the
     * conflicting set.</p>
     *
     * <p><strong>CASES</strong></p>
     *
     * <ul>
     *
     * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
     *
     * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
     * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
     * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
     * {@code {1,3}} =&gt; continue
     * </li>
     *
     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
     * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
     * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
     * {@code {1}} =&gt; stop and predict 1</li>
     *
     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
     * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
     * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
     * ambiguity {@code {1,2}}</li>
     *
     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
     * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
     * {@code {2}} = {@code {1,2}} =&gt; continue</li>
     *
     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
     * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
     * {@code {3}} = {@code {1,3}} =&gt; continue</li>
     *
     * </ul>
     *
     * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
     *
     * <p>If all states report the same conflicting set of alternatives, then we
     * know we have the exact ambiguity set.</p>
     *
     * <p><code>|A_<em>i</em>|&gt;1</code> and
     * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
     *
     * <p>In other words, we continue examining lookahead until all {@code A_i}
     * have more than one alternative and all {@code A_i} are the same. If
     * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
     * because the resolved set is {@code {1}}. To determine what the real
     * ambiguity is, we have to know whether the ambiguity is between one and
     * two or one and three so we keep going. We can only stop prediction when
     * we need exact ambiguity detection when the sets look like
     * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
     */
    resolvesToJustOneViableAlt: function(altsets) {
        return PredictionMode.getSingleViableAlt(altsets);
    },

    /**
     * Determines if every alternative subset in {@code altsets} contains more
     * than one alternative.
     *
     * @param altsets a collection of alternative subsets
     * @return {@code true} if every {@link BitSet} in {@code altsets} has
     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
     */
    allSubsetsConflict: function(altsets) {
        return ! PredictionMode.hasNonConflictingAltSet(altsets);
    },
    /**
     * Determines if any single alternative subset in {@code altsets} contains
     * exactly one alternative.
     *
     * @param altsets a collection of alternative subsets
     * @return {@code true} if {@code altsets} contains a {@link BitSet} with
     * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
     */
    hasNonConflictingAltSet: function(altsets) {
        for(let i=0;i<altsets.length;i++) {
            const alts = altsets[i];
            if (alts.length===1) {
                return true;
            }
        }
        return false;
    },


    /**
     * Determines if any single alternative subset in {@code altsets} contains
     * more than one alternative.
     *
     * @param altsets a collection of alternative subsets
     * @return {@code true} if {@code altsets} contains a {@link BitSet} with
     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
     */
    hasConflictingAltSet: function(altsets) {
        for(let i=0;i<altsets.length;i++) {
            const alts = altsets[i];
            if (alts.length>1) {
                return true;
            }
        }
        return false;
    },


    /**
     * Determines if every alternative subset in {@code altsets} is equivalent.
     *
     * @param altsets a collection of alternative subsets
     * @return {@code true} if every member of {@code altsets} is equal to the
     * others, otherwise {@code false}
     */
    allSubsetsEqual: function(altsets) {
        let first = null;
        for(let i=0;i<altsets.length;i++) {
            const alts = altsets[i];
            if (first === null) {
                first = alts;
            } else if (alts!==first) {
                return false;
            }
        }
        return true;
    },


    /**
     * Returns the unique alternative predicted by all alternative subsets in
     * {@code altsets}. If no such alternative exists, this method returns
     * {@link ATN//INVALID_ALT_NUMBER}.
     *
     * @param altsets a collection of alternative subsets
     */
    getUniqueAlt: function(altsets) {
        const all = PredictionMode.getAlts(altsets);
        if (all.length===1) {
            return all.minValue();
        } else {
            return ATN.INVALID_ALT_NUMBER;
        }
    },

    /**
     * Gets the complete set of represented alternatives for a collection of
     * alternative subsets. This method returns the union of each {@link BitSet}
     * in {@code altsets}.
     *
     * @param altsets a collection of alternative subsets
     * @return the set of represented alternatives in {@code altsets}
     */
    getAlts: function(altsets) {
        const all = new BitSet();
        altsets.map( function(alts) { all.or(alts); });
        return all;
    },

    /**
     * This function gets the conflicting alt subsets from a configuration set.
     * For each configuration {@code c} in {@code configs}:
     *
     * <pre>
     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
     * alt and not pred
     * </pre>
     */
    getConflictingAltSubsets: function(configs) {
        const configToAlts = new HashMap();
        configToAlts.hashFunction = function(cfg) { HashCode.hashStuff(cfg.state.stateNumber, cfg.context); };
        configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);};
        configs.items.map(function(cfg) {
            let alts = configToAlts.get(cfg);
            if (alts === null) {
                alts = new BitSet();
                configToAlts.set(cfg, alts);
            }
            alts.add(cfg.alt);
        });
        return configToAlts.getValues();
    },

    /**
     * Get a map from state to alt subset from a configuration set. For each
     * configuration {@code c} in {@code configs}:
     *
     * <pre>
     * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
     * </pre>
     */
    getStateToAltMap: function(configs) {
        const m = new AltDict();
        configs.items.map(function(c) {
            let alts = m.get(c.state);
            if (alts === null) {
                alts = new BitSet();
                m.set(c.state, alts);
            }
            alts.add(c.alt);
        });
        return m;
    },

    hasStateAssociatedWithOneAlt: function(configs) {
        const values = PredictionMode.getStateToAltMap(configs).values();
        for(let i=0;i<values.length;i++) {
            if (values[i].length===1) {
                return true;
            }
        }
        return false;
    },

    getSingleViableAlt: function(altsets) {
        let result = null;
        for(let i=0;i<altsets.length;i++) {
            const alts = altsets[i];
            const minAlt = alts.minValue();
            if(result===null) {
                result = minAlt;
            } else if(result!==minAlt) { // more than 1 viable alt
                return ATN.INVALID_ALT_NUMBER;
            }
        }
        return result;
    }
};

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Indicates that the parser could not decide which of two or more paths
 * to take based upon the remaining input. It tracks the starting token
 * of the offending input and also knows where the parser was
 * in the various paths when the error. Reported by reportNoViableAlternative()
 */

class NoViableAltException extends RecognitionException {
    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
        ctx = ctx || recognizer._ctx;
        offendingToken = offendingToken || recognizer.getCurrentToken();
        startToken = startToken || recognizer.getCurrentToken();
        input = input || recognizer.getInputStream();
        super({message: "", recognizer: recognizer, input: input, ctx: ctx});
        // Which configurations did we try at input.index() that couldn't match
        // input.LT(1)?//
        this.deadEndConfigs = deadEndConfigs;
        // The token object at the start index; the input stream might
        // not be buffering tokens so get a reference to it. (At the
        // time the error occurred, of course the stream needs to keep a
        // buffer all of the tokens but later we might not have access to those.)
        this.startToken = startToken;
        this.offendingToken = offendingToken;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class DoubleDict {

    constructor(defaultMapCtor) {
        this.defaultMapCtor = defaultMapCtor || HashMap;
        this.cacheMap = new this.defaultMapCtor();
    }

    get(a, b) {
        const d = this.cacheMap.get(a) || null;
        return d === null ? null : (d.get(b) || null);
    }

    set(a, b, o) {
        let d = this.cacheMap.get(a) || null;
        if (d === null) {
            d = new this.defaultMapCtor();
            this.cacheMap.set(a, d);
        }
        d.set(b, o);
    }

}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
 *
 * <p>
 * The basic complexity of the adaptive strategy makes it harder to understand.
 * We begin with ATN simulation to build paths in a DFA. Subsequent prediction
 * requests go through the DFA first. If they reach a state without an edge for
 * the current symbol, the algorithm fails over to the ATN simulation to
 * complete the DFA path for the current input (until it finds a conflict state
 * or uniquely predicting state).</p>
 *
 * <p>
 * All of that is done without using the outer context because we want to create
 * a DFA that is not dependent upon the rule invocation stack when we do a
 * prediction. One DFA works in all contexts. We avoid using context not
 * necessarily because it's slower, although it can be, but because of the DFA
 * caching problem. The closure routine only considers the rule invocation stack
 * created during prediction beginning in the decision rule. For example, if
 * prediction occurs without invoking another rule's ATN, there are no context
 * stacks in the configurations. When lack of context leads to a conflict, we
 * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
 * strategy (versus full LL(*)).</p>
 *
 * <p>
 * When SLL yields a configuration set with conflict, we rewind the input and
 * retry the ATN simulation, this time using full outer context without adding
 * to the DFA. Configuration context stacks will be the full invocation stacks
 * from the start rule. If we get a conflict using full context, then we can
 * definitively say we have a true ambiguity for that input sequence. If we
 * don't get a conflict, it implies that the decision is sensitive to the outer
 * context. (It is not context-sensitive in the sense of context-sensitive
 * grammars.)</p>
 *
 * <p>
 * The next time we reach this DFA state with an SLL conflict, through DFA
 * simulation, we will again retry the ATN simulation using full context mode.
 * This is slow because we can't save the results and have to "interpret" the
 * ATN each time we get that input.</p>
 *
 * <p>
 * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
 *
 * <p>
 * We could cache results from full context to predicted alternative easily and
 * that saves a lot of time but doesn't work in presence of predicates. The set
 * of visible predicates from the ATN start state changes depending on the
 * context, because closure can fall off the end of a rule. I tried to cache
 * tuples (stack context, semantic context, predicted alt) but it was slower
 * than interpreting and much more complicated. Also required a huge amount of
 * memory. The goal is not to create the world's fastest parser anyway. I'd like
 * to keep this algorithm simple. By launching multiple threads, we can improve
 * the speed of parsing across a large number of files.</p>
 *
 * <p>
 * There is no strict ordering between the amount of input used by SLL vs LL,
 * which makes it really hard to build a cache for full context. Let's say that
 * we have input A B C that leads to an SLL conflict with full context X. That
 * implies that using X we might only use A B but we could also use A B C D to
 * resolve conflict. Input A B C D could predict alternative 1 in one position
 * in the input and A B C E could predict alternative 2 in another position in
 * input. The conflicting SLL configurations could still be non-unique in the
 * full context prediction, which would lead us to requiring more input than the
 * original A B C.	To make a	prediction cache work, we have to track	the exact
 * input	used during the previous prediction. That amounts to a cache that maps
 * X to a specific DFA for that context.</p>
 *
 * <p>
 * Something should be done for left-recursive expression predictions. They are
 * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
 * with full LL thing Sam does.</p>
 *
 * <p>
 * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
 *
 * <p>
 * We avoid doing full context retry when the outer context is empty, we did not
 * dip into the outer context by falling off the end of the decision state rule,
 * or when we force SLL mode.</p>
 *
 * <p>
 * As an example of the not dip into outer context case, consider as super
 * constructor calls versus function calls. One grammar might look like
 * this:</p>
 *
 * <pre>
 * ctorBody
 *   : '{' superCall? stat* '}'
 *   ;
 * </pre>
 *
 * <p>
 * Or, you might see something like</p>
 *
 * <pre>
 * stat
 *   : superCall ';'
 *   | expression ';'
 *   | ...
 *   ;
 * </pre>
 *
 * <p>
 * In both cases I believe that no closure operations will dip into the outer
 * context. In the first case ctorBody in the worst case will stop at the '}'.
 * In the 2nd case it should stop at the ';'. Both cases should stay within the
 * entry rule and not dip into the outer context.</p>
 *
 * <p>
 * <strong>PREDICATES</strong></p>
 *
 * <p>
 * Predicates are always evaluated if present in either SLL or LL both. SLL and
 * LL simulation deals with predicates differently. SLL collects predicates as
 * it performs closure operations like ANTLR v3 did. It delays predicate
 * evaluation until it reaches and accept state. This allows us to cache the SLL
 * ATN simulation whereas, if we had evaluated predicates on-the-fly during
 * closure, the DFA state configuration sets would be different and we couldn't
 * build up a suitable DFA.</p>
 *
 * <p>
 * When building a DFA accept state during ATN simulation, we evaluate any
 * predicates and return the sole semantically valid alternative. If there is
 * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
 * we throw an exception. Alternatives without predicates act like they have
 * true predicates. The simple way to think about it is to strip away all
 * alternatives with false predicates and choose the minimum alternative that
 * remains.</p>
 *
 * <p>
 * When we start in the DFA and reach an accept state that's predicated, we test
 * those and return the minimum semantically viable alternative. If no
 * alternatives are viable, we throw an exception.</p>
 *
 * <p>
 * During full LL ATN simulation, closure always evaluates predicates and
 * on-the-fly. This is crucial to reducing the configuration set size during
 * closure. It hits a landmine when parsing with the Java grammar, for example,
 * without this on-the-fly evaluation.</p>
 *
 * <p>
 * <strong>SHARING DFA</strong></p>
 *
 * <p>
 * All instances of the same parser share the same decision DFAs through a
 * static field. Each instance gets its own ATN simulator but they share the
 * same {@link //decisionToDFA} field. They also share a
 * {@link PredictionContextCache} object that makes sure that all
 * {@link PredictionContext} objects are shared among the DFA states. This makes
 * a big size difference.</p>
 *
 * <p>
 * <strong>THREAD SAFETY</strong></p>
 *
 * <p>
 * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when
 * it adds a new DFA object to that array. {@link //addDFAEdge}
 * locks on the DFA for the current decision when setting the
 * {@link DFAState//edges} field. {@link //addDFAState} locks on
 * the DFA for the current decision when looking up a DFA state to see if it
 * already exists. We must make sure that all requests to add DFA states that
 * are equivalent result in the same shared DFA object. This is because lots of
 * threads will be trying to update the DFA at once. The
 * {@link //addDFAState} method also locks inside the DFA lock
 * but this time on the shared context cache when it rebuilds the
 * configurations' {@link PredictionContext} objects using cached
 * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
 * safe as long as we can guarantee that all threads referencing
 * {@code s.edge[t]} get the same physical target {@link DFAState}, or
 * {@code null}. Once into the DFA, the DFA simulation does not reference the
 * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new
 * targets. The DFA simulator will either find {@link DFAState//edges} to be
 * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
 * {@code dfa.edges[t]} to be non-null. The
 * {@link //addDFAEdge} method could be racing to set the field
 * but in either case the DFA simulator works; if {@code null}, and requests ATN
 * simulation. It could also race trying to get {@code dfa.edges[t]}, but either
 * way it will work because it's not doing a test and set operation.</p>
 *
 * <p>
 * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
 * Parsing)</strong></p>
 *
 * <p>
 * Sam pointed out that if SLL does not give a syntax error, then there is no
 * point in doing full LL, which is slower. We only have to try LL if we get a
 * syntax error. For maximum speed, Sam starts the parser set to pure SLL
 * mode with the {@link BailErrorStrategy}:</p>
 *
 * <pre>
 * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};
 * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
 * </pre>
 *
 * <p>
 * If it does not get a syntax error, then we're done. If it does get a syntax
 * error, we need to retry with the combined SLL/LL strategy.</p>
 *
 * <p>
 * The reason this works is as follows. If there are no SLL conflicts, then the
 * grammar is SLL (at least for that input set). If there is an SLL conflict,
 * the full LL analysis must yield a set of viable alternatives which is a
 * subset of the alternatives reported by SLL. If the LL set is a singleton,
 * then the grammar is LL but not SLL. If the LL set is the same size as the SLL
 * set, the decision is SLL. If the LL set has size &gt; 1, then that decision
 * is truly ambiguous on the current input. If the LL set is smaller, then the
 * SLL conflict resolution might choose an alternative that the full LL would
 * rule out as a possibility based upon better context information. If that's
 * the case, then the SLL parse will definitely get an error because the full LL
 * analysis says it's not viable. If SLL conflict resolution chooses an
 * alternative within the LL set, them both SLL and LL would choose the same
 * alternative because they both choose the minimum of multiple conflicting
 * alternatives.</p>
 *
 * <p>
 * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
 * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
 * parsing will get an error because SLL will pursue alternative 1. If
 * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
 * choose the same alternative because alternative one is the minimum of either
 * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
 * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
 *
 * <p>
 * Of course, if the input is invalid, then we will get an error for sure in
 * both SLL and LL parsing. Erroneous input will therefore require 2 passes over
 * the input.</p>
 */
class ParserATNSimulator extends ATNSimulator {
    constructor(parser, atn, decisionToDFA, sharedContextCache) {
        super(atn, sharedContextCache);
        this.parser = parser;
        this.decisionToDFA = decisionToDFA;
        // SLL, LL, or LL + exact ambig detection?//
        this.predictionMode = PredictionMode.LL;
        // LAME globals to avoid parameters!!!!! I need these down deep in predTransition
        this._input = null;
        this._startIndex = 0;
        this._outerContext = null;
        this._dfa = null;
        /**
         * Each prediction operation uses a cache for merge of prediction contexts.
         *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
         *  isn't synchronized but we're ok since two threads shouldn't reuse same
         *  parser/atnsim object because it can only handle one input at a time.
         *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
         *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
         *  also be examined during cache lookup.
         */
        this.mergeCache = null;
        this.debug = false;
        this.debug_closure = false;
        this.debug_add = false;
        this.debug_list_atn_decisions = false;
        this.dfa_debug = false;
        this.retry_debug = false;
    }

    reset() {}

    adaptivePredict(input, decision, outerContext) {
        if (this.debug || this.debug_list_atn_decisions) {
            console.log("adaptivePredict decision " + decision +
                                   " exec LA(1)==" + this.getLookaheadName(input) +
                                   " line " + input.LT(1).line + ":" +
                                   input.LT(1).column);
        }
        this._input = input;
        this._startIndex = input.index;
        this._outerContext = outerContext;

        const dfa = this.decisionToDFA[decision];
        this._dfa = dfa;
        const m = input.mark();
        const index = input.index;

        // Now we are certain to have a specific decision's DFA
        // But, do we still need an initial state?
        try {
            let s0;
            if (dfa.precedenceDfa) {
                // the start state for a precedence DFA depends on the current
                // parser precedence, and is provided by a DFA method.
                s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
            } else {
                // the start state for a "regular" DFA is just s0
                s0 = dfa.s0;
            }
            if (s0===null) {
                if (outerContext===null) {
                    outerContext = RuleContext.EMPTY;
                }
                if (this.debug || this.debug_list_atn_decisions) {
                    console.log("predictATN decision " + dfa.decision +
                                       " exec LA(1)==" + this.getLookaheadName(input) +
                                       ", outerContext=" + outerContext.toString(this.parser.ruleNames));
                }

                const fullCtx = false;
                let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);

                if( dfa.precedenceDfa) {
                    // If this is a precedence DFA, we use applyPrecedenceFilter
                    // to convert the computed start state to a precedence start
                    // state. We then use DFA.setPrecedenceStartState to set the
                    // appropriate start state for the precedence level rather
                    // than simply setting DFA.s0.
                    //
                    dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway
                    s0_closure = this.applyPrecedenceFilter(s0_closure);
                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                    dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
                } else {
                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                    dfa.s0 = s0;
                }
            }
            const alt = this.execATN(dfa, s0, input, index, outerContext);
            if (this.debug) {
                console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));
            }
            return alt;
        } finally {
            this._dfa = null;
            this.mergeCache = null; // wack cache after each prediction
            input.seek(index);
            input.release(m);
        }
    }

    /**
     * Performs ATN simulation to compute a predicted alternative based
     *  upon the remaining input, but also updates the DFA cache to avoid
     *  having to traverse the ATN again for the same input sequence.
     *
     * There are some key conditions we're looking for after computing a new
     * set of ATN configs (proposed DFA state):
     *       if the set is empty, there is no viable alternative for current symbol
     *       does the state uniquely predict an alternative?
     *       does the state have a conflict that would prevent us from
     *         putting it on the work list?
     *
     * We also have some key operations to do:
     *       add an edge from previous DFA state to potentially new DFA state, D,
     *         upon current symbol but only if adding to work list, which means in all
     *         cases except no viable alternative (and possibly non-greedy decisions?)
     *       collecting predicates and adding semantic context to DFA accept states
     *       adding rule context to context-sensitive DFA accept states
     *       consuming an input symbol
     *       reporting a conflict
     *       reporting an ambiguity
     *       reporting a context sensitivity
     *       reporting insufficient predicates
     *
     * cover these cases:
     *    dead end
     *    single alt
     *    single alt + preds
     *    conflict
     *    conflict + preds
     *
     */
    execATN(dfa, s0, input, startIndex, outerContext ) {
        if (this.debug || this.debug_list_atn_decisions) {
            console.log("execATN decision " + dfa.decision +
                    " exec LA(1)==" + this.getLookaheadName(input) +
                    " line " + input.LT(1).line + ":" + input.LT(1).column);
        }
        let alt;
        let previousD = s0;

        if (this.debug) {
            console.log("s0 = " + s0);
        }
        let t = input.LA(1);
        for(;;) { // while more work
            let D = this.getExistingTargetState(previousD, t);
            if(D===null) {
                D = this.computeTargetState(dfa, previousD, t);
            }
            if(D===ATNSimulator.ERROR) {
                // if any configs in previous dipped into outer context, that
                // means that input up to t actually finished entry rule
                // at least for SLL decision. Full LL doesn't dip into outer
                // so don't need special case.
                // We will get an error no matter what so delay until after
                // decision; better error message. Also, no reachable target
                // ATN states in SLL implies LL will also get nowhere.
                // If conflict in states that dip out, choose min since we
                // will get error no matter what.
                const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
                input.seek(startIndex);
                alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
                if(alt!==ATN.INVALID_ALT_NUMBER) {
                    return alt;
                } else {
                    throw e;
                }
            }
            if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
                // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
                let conflictingAlts = null;
                if (D.predicates!==null) {
                    if (this.debug) {
                        console.log("DFA state has preds in DFA sim LL failover");
                    }
                    const conflictIndex = input.index;
                    if(conflictIndex !== startIndex) {
                        input.seek(startIndex);
                    }
                    conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
                    if (conflictingAlts.length===1) {
                        if(this.debug) {
                            console.log("Full LL avoided");
                        }
                        return conflictingAlts.minValue();
                    }
                    if (conflictIndex !== startIndex) {
                        // restore the index so reporting the fallback to full
                        // context occurs with the index at the correct spot
                        input.seek(conflictIndex);
                    }
                }
                if (this.dfa_debug) {
                    console.log("ctx sensitive state " + outerContext +" in " + D);
                }
                const fullCtx = true;
                const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
                this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
                alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
                return alt;
            }
            if (D.isAcceptState) {
                if (D.predicates===null) {
                    return D.prediction;
                }
                const stopIndex = input.index;
                input.seek(startIndex);
                const alts = this.evalSemanticContext(D.predicates, outerContext, true);
                if (alts.length===0) {
                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                } else if (alts.length===1) {
                    return alts.minValue();
                } else {
                    // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.
                    this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
                    return alts.minValue();
                }
            }
            previousD = D;

            if (t !== Token.EOF) {
                input.consume();
                t = input.LA(1);
            }
        }
    }

    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns {@code null}.
     *
     * @param previousD The current DFA state
     * @param t The next input symbol
     * @return The existing target DFA state for the given input symbol
     * {@code t}, or {@code null} if the target state for this edge is not
     * already cached
     */
    getExistingTargetState(previousD, t) {
        const edges = previousD.edges;
        if (edges===null) {
            return null;
        } else {
            return edges[t + 1] || null;
        }
    }

    /**
     * Compute a target state for an edge in the DFA, and attempt to add the
     * computed state and corresponding edge to the DFA.
     *
     * @param dfa The DFA
     * @param previousD The current DFA state
     * @param t The next input symbol
     *
     * @return The computed target DFA state for the given input symbol
     * {@code t}. If {@code t} does not lead to a valid DFA state, this method
     * returns {@link //ERROR
     */
    computeTargetState(dfa, previousD, t) {
       const reach = this.computeReachSet(previousD.configs, t, false);
        if(reach===null) {
            this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
            return ATNSimulator.ERROR;
        }
        // create new target state; we'll add to DFA after it's complete
        let D = new DFAState(null, reach);

        const predictedAlt = this.getUniqueAlt(reach);

        if (this.debug) {
            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
            console.log("SLL altSubSets=" + arrayToString(altSubSets) +
                        /*", previous=" + previousD.configs + */
                        ", configs=" + reach +
                        ", predict=" + predictedAlt +
                        ", allSubsetsConflict=" +
                        PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" +
                        this.getConflictingAlts(reach));
        }
        if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {
            // NO CONFLICT, UNIQUELY PREDICTED ALT
            D.isAcceptState = true;
            D.configs.uniqueAlt = predictedAlt;
            D.prediction = predictedAlt;
        } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
            // MORE THAN ONE VIABLE ALTERNATIVE
            D.configs.conflictingAlts = this.getConflictingAlts(reach);
            D.requiresFullContext = true;
            // in SLL-only mode, we will stop at this state and return the minimum alt
            D.isAcceptState = true;
            D.prediction = D.configs.conflictingAlts.minValue();
        }
        if (D.isAcceptState && D.configs.hasSemanticContext) {
            this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
            if( D.predicates!==null) {
                D.prediction = ATN.INVALID_ALT_NUMBER;
            }
        }
        // all adds to dfa are done after we've created full D state
        D = this.addDFAEdge(dfa, previousD, t, D);
        return D;
    }

    predicateDFAState(dfaState, decisionState) {
        // We need to test all predicates, even in DFA states that
        // uniquely predict alternative.
        const nalts = decisionState.transitions.length;
        // Update DFA so reach becomes accept state with (predicate,alt)
        // pairs if preds found for conflicting alts
        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
        if (altToPred!==null) {
            dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
            dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds
        } else {
            // There are preds in configs but they might go away
            // when OR'd together like {p}? || NONE == NONE. If neither
            // alt has preds, resolve to min alt
            dfaState.prediction = altsToCollectPredsFrom.minValue();
        }
    }

// comes back with reach.uniqueAlt set to a valid alt
    execATNWithFullContext(dfa, D, // how far we got before failing over
                                         s0,
                                         input,
                                         startIndex,
                                         outerContext) {
        if (this.debug || this.debug_list_atn_decisions) {
            console.log("execATNWithFullContext "+s0);
        }
        const fullCtx = true;
        let foundExactAmbig = false;
        let reach;
        let previous = s0;
        input.seek(startIndex);
        let t = input.LA(1);
        let predictedAlt = -1;
        for (;;) { // while more work
            reach = this.computeReachSet(previous, t, fullCtx);
            if (reach===null) {
                // if any configs in previous dipped into outer context, that
                // means that input up to t actually finished entry rule
                // at least for LL decision. Full LL doesn't dip into outer
                // so don't need special case.
                // We will get an error no matter what so delay until after
                // decision; better error message. Also, no reachable target
                // ATN states in SLL implies LL will also get nowhere.
                // If conflict in states that dip out, choose min since we
                // will get error no matter what.
                const e = this.noViableAlt(input, outerContext, previous, startIndex);
                input.seek(startIndex);
                const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
                if(alt!==ATN.INVALID_ALT_NUMBER) {
                    return alt;
                } else {
                    throw e;
                }
            }
            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
            if(this.debug) {
                console.log("LL altSubSets=" + altSubSets + ", predict=" +
                      PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" +
                      PredictionMode.resolvesToJustOneViableAlt(altSubSets));
            }
            reach.uniqueAlt = this.getUniqueAlt(reach);
            // unique prediction?
            if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {
                predictedAlt = reach.uniqueAlt;
                break;
            } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
                predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
                if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {
                    break;
                }
            } else {
                // In exact ambiguity mode, we never try to terminate early.
                // Just keeps scarfing until we know what the conflict is
                if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
                    foundExactAmbig = true;
                    predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
                    break;
                }
                // else there are multiple non-conflicting subsets or
                // we're not sure what the ambiguity is yet.
                // So, keep going.
            }
            previous = reach;
            if( t !== Token.EOF) {
                input.consume();
                t = input.LA(1);
            }
        }
        // If the configuration set uniquely predicts an alternative,
        // without conflict, then we know that it's a full LL decision
        // not SLL.
        if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {
            this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
            return predictedAlt;
        }
        // We do not check predicates here because we have checked them
        // on-the-fly when doing full context prediction.

        //
        // In non-exact ambiguity detection mode, we might	actually be able to
        // detect an exact ambiguity, but I'm not going to spend the cycles
        // needed to check. We only emit ambiguity warnings in exact ambiguity
        // mode.
        //
        // For example, we might know that we have conflicting configurations.
        // But, that does not mean that there is no way forward without a
        // conflict. It's possible to have nonconflicting alt subsets as in:

        // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]

        // from
        //
        //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
        //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
        //
        // In this case, (17,1,[5 $]) indicates there is some next sequence that
        // would resolve this without conflict to alternative 1. Any other viable
        // next sequence, however, is associated with a conflict.  We stop
        // looking for input because no amount of further lookahead will alter
        // the fact that we should predict alternative 1.  We just can't say for
        // sure that there is an ambiguity without looking further.

        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);

        return predictedAlt;
    }

    computeReachSet(closure, t, fullCtx) {
        if (this.debug) {
            console.log("in computeReachSet, starting closure: " + closure);
        }
        if( this.mergeCache===null) {
            this.mergeCache = new DoubleDict();
        }
        const intermediate = new ATNConfigSet(fullCtx);

        // Configurations already in a rule stop state indicate reaching the end
        // of the decision rule (local context) or end of the start rule (full
        // context). Once reached, these configurations are never updated by a
        // closure operation, so they are handled separately for the performance
        // advantage of having a smaller intermediate set when calling closure.
        //
        // For full-context reach operations, separate handling is required to
        // ensure that the alternative matching the longest overall sequence is
        // chosen when multiple such configurations can match the input.

        let skippedStopStates = null;

        // First figure out where we can reach on input t
        for (let i=0; i<closure.items.length;i++) {
            const c = closure.items[i];
            if(this.debug) {
                console.log("testing " + this.getTokenName(t) + " at " + c);
            }
            if (c.state instanceof RuleStopState) {
                if (fullCtx || t === Token.EOF) {
                    if (skippedStopStates===null) {
                        skippedStopStates = [];
                    }
                    skippedStopStates.push(c);
                    if(this.debug_add) {
                        console.log("added " + c + " to skippedStopStates");
                    }
                }
                continue;
            }
            for(let j=0;j<c.state.transitions.length;j++) {
                const trans = c.state.transitions[j];
                const target = this.getReachableTarget(trans, t);
                if (target!==null) {
                    const cfg = new ATNConfig({state:target}, c);
                    intermediate.add(cfg, this.mergeCache);
                    if(this.debug_add) {
                        console.log("added " + cfg + " to intermediate");
                    }
                }
            }
        }
        // Now figure out where the reach operation can take us...
        let reach = null;

        // This block optimizes the reach operation for intermediate sets which
        // trivially indicate a termination state for the overall
        // adaptivePredict operation.
        //
        // The conditions assume that intermediate
        // contains all configurations relevant to the reach set, but this
        // condition is not true when one or more configurations have been
        // withheld in skippedStopStates, or when the current symbol is EOF.
        //
        if (skippedStopStates===null && t!==Token.EOF) {
            if (intermediate.items.length===1) {
                // Don't pursue the closure if there is just one state.
                // It can only have one alternative; just add to result
                // Also don't pursue the closure if there is unique alternative
                // among the configurations.
                reach = intermediate;
            } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {
                // Also don't pursue the closure if there is unique alternative
                // among the configurations.
                reach = intermediate;
            }
        }
        // If the reach set could not be trivially determined, perform a closure
        // operation on the intermediate set to compute its initial value.
        //
        if (reach===null) {
            reach = new ATNConfigSet(fullCtx);
            const closureBusy = new HashSet();
            const treatEofAsEpsilon = t === Token.EOF;
            for (let k=0; k<intermediate.items.length;k++) {
                this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
            }
        }
        if (t === Token.EOF) {
            // After consuming EOF no additional input is possible, so we are
            // only interested in configurations which reached the end of the
            // decision rule (local context) or end of the start rule (full
            // context). Update reach to contain only these configurations. This
            // handles both explicit EOF transitions in the grammar and implicit
            // EOF transitions following the end of the decision or start rule.
            //
            // When reach==intermediate, no closure operation was performed. In
            // this case, removeAllConfigsNotInRuleStopState needs to check for
            // reachable rule stop states as well as configurations already in
            // a rule stop state.
            //
            // This is handled before the configurations in skippedStopStates,
            // because any configurations potentially added from that list are
            // already guaranteed to meet this condition whether or not it's
            // required.
            //
            reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
        }
        // If skippedStopStates!==null, then it contains at least one
        // configuration. For full-context reach operations, these
        // configurations reached the end of the start rule, in which case we
        // only add them back to reach if no configuration during the current
        // closure operation reached such a state. This ensures adaptivePredict
        // chooses an alternative matching the longest overall sequence when
        // multiple alternatives are viable.
        //
        if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {
            for (let l=0; l<skippedStopStates.length;l++) {
                reach.add(skippedStopStates[l], this.mergeCache);
            }
        }
        if (reach.items.length===0) {
            return null;
        } else {
            return reach;
        }
    }

    /**
     * Return a configuration set containing only the configurations from
     * {@code configs} which are in a {@link RuleStopState}. If all
     * configurations in {@code configs} are already in a rule stop state, this
     * method simply returns {@code configs}.
     *
     * <p>When {@code lookToEndOfRule} is true, this method uses
     * {@link ATN//nextTokens} for each configuration in {@code configs} which is
     * not already in a rule stop state to see if a rule stop state is reachable
     * from the configuration via epsilon-only transitions.</p>
     *
     * @param configs the configuration set to update
     * @param lookToEndOfRule when true, this method checks for rule stop states
     * reachable by epsilon-only transitions from each configuration in
     * {@code configs}.
     *
     * @return {@code configs} if all configurations in {@code configs} are in a
     * rule stop state, otherwise return a new configuration set containing only
     * the configurations from {@code configs} which are in a rule stop state
     */
    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
        if (PredictionMode.allConfigsInRuleStopStates(configs)) {
            return configs;
        }
        const result = new ATNConfigSet(configs.fullCtx);
        for(let i=0; i<configs.items.length;i++) {
            const config = configs.items[i];
            if (config.state instanceof RuleStopState) {
                result.add(config, this.mergeCache);
                continue;
            }
            if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
                const nextTokens = this.atn.nextTokens(config.state);
                if (nextTokens.contains(Token.EPSILON)) {
                    const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
                    result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);
                }
            }
        }
        return result;
    }

    computeStartState(p, ctx, fullCtx) {
        // always at least the implicit call to start rule
        const initialContext = predictionContextFromRuleContext(this.atn, ctx);
        const configs = new ATNConfigSet(fullCtx);
        for(let i=0;i<p.transitions.length;i++) {
            const target = p.transitions[i].target;
            const c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);
            const closureBusy = new HashSet();
            this.closure(c, configs, closureBusy, true, fullCtx, false);
        }
        return configs;
    }

    /**
     * This method transforms the start state computed by
     * {@link //computeStartState} to the special start state used by a
     * precedence DFA for a particular precedence value. The transformation
     * process applies the following changes to the start state's configuration
     * set.
     *
     * <ol>
     * <li>Evaluate the precedence predicates for each configuration using
     * {@link SemanticContext//evalPrecedence}.</li>
     * <li>Remove all configurations which predict an alternative greater than
     * 1, for which another configuration that predicts alternative 1 is in the
     * same ATN state with the same prediction context. This transformation is
     * valid for the following reasons:
     * <ul>
     * <li>The closure block cannot contain any epsilon transitions which bypass
     * the body of the closure, so all states reachable via alternative 1 are
     * part of the precedence alternatives of the transformed left-recursive
     * rule.</li>
     * <li>The "primary" portion of a left recursive rule cannot contain an
     * epsilon transition, so the only way an alternative other than 1 can exist
     * in a state that is also reachable via alternative 1 is by nesting calls
     * to the left-recursive rule, with the outer calls not being at the
     * preferred precedence level.</li>
     * </ul>
     * </li>
     * </ol>
     *
     * <p>
     * The prediction context must be considered by this filter to address
     * situations like the following.
     * </p>
     * <code>
     * <pre>
     * grammar TA;
     * prog: statement* EOF;
     * statement: letterA | statement letterA 'b' ;
     * letterA: 'a';
     * </pre>
     * </code>
     * <p>
     * If the above grammar, the ATN state immediately before the token
     * reference {@code 'a'} in {@code letterA} is reachable from the left edge
     * of both the primary and closure blocks of the left-recursive rule
     * {@code statement}. The prediction context associated with each of these
     * configurations distinguishes between them, and prevents the alternative
     * which stepped out to {@code prog} (and then back in to {@code statement}
     * from being eliminated by the filter.
     * </p>
     *
     * @param configs The configuration set computed by
     * {@link //computeStartState} as the start state for the DFA.
     * @return The transformed configuration set representing the start state
     * for a precedence DFA at a particular precedence level (determined by
     * calling {@link Parser//getPrecedence})
     */
    applyPrecedenceFilter(configs) {
        let config;
        const statesFromAlt1 = [];
        const configSet = new ATNConfigSet(configs.fullCtx);
        for(let i=0; i<configs.items.length; i++) {
            config = configs.items[i];
            // handle alt 1 first
            if (config.alt !== 1) {
                continue;
            }
            const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
            if (updatedContext===null) {
                // the configuration was eliminated
                continue;
            }
            statesFromAlt1[config.state.stateNumber] = config.context;
            if (updatedContext !== config.semanticContext) {
                configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);
            } else {
                configSet.add(config, this.mergeCache);
            }
        }
        for(let i=0; i<configs.items.length; i++) {
            config = configs.items[i];
            if (config.alt === 1) {
                // already handled
                continue;
            }
            // In the future, this elimination step could be updated to also
            // filter the prediction context for alternatives predicting alt>1
            // (basically a graph subtraction algorithm).
            if (!config.precedenceFilterSuppressed) {
                const context = statesFromAlt1[config.state.stateNumber] || null;
                if (context!==null && context.equals(config.context)) {
                    // eliminated
                    continue;
                }
            }
            configSet.add(config, this.mergeCache);
        }
        return configSet;
    }

    getReachableTarget(trans, ttype) {
        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
            return trans.target;
        } else {
            return null;
        }
    }

    getPredsForAmbigAlts(ambigAlts, configs, nalts) {
        // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
        // altToPred starts as an array of all null contexts. The entry at index i
        // corresponds to alternative i. altToPred[i] may have one of three values:
        //   1. null: no ATNConfig c is found such that c.alt==i
        //   2. SemanticContext.NONE: At least one ATNConfig c exists such that
        //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,
        //      alt i has at least one unpredicated config.
        //   3. Non-NONE Semantic Context: There exists at least one, and for all
        //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.
        //
        // From this, it is clear that NONE||anything==NONE.
        //
        let altToPred = [];
        for(let i=0;i<configs.items.length;i++) {
            const c = configs.items[i];
            if(ambigAlts.has( c.alt )) {
                altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
            }
        }
        let nPredAlts = 0;
        for (let i =1;i< nalts+1;i++) {
            const pred = altToPred[i] || null;
            if (pred===null) {
                altToPred[i] = SemanticContext.NONE;
            } else if (pred !== SemanticContext.NONE) {
                nPredAlts += 1;
            }
        }
        // nonambig alts are null in altToPred
        if (nPredAlts===0) {
            altToPred = null;
        }
        if (this.debug) {
            console.log("getPredsForAmbigAlts result " + arrayToString(altToPred));
        }
        return altToPred;
    }

    getPredicatePredictions(ambigAlts, altToPred) {
        const pairs = [];
        let containsPredicate = false;
        for (let i=1; i<altToPred.length;i++) {
            const pred = altToPred[i];
            // unpredicated is indicated by SemanticContext.NONE
            if( ambigAlts!==null && ambigAlts.has( i )) {
                pairs.push(new PredPrediction(pred, i));
            }
            if (pred !== SemanticContext.NONE) {
                containsPredicate = true;
            }
        }
        if (! containsPredicate) {
            return null;
        }
        return pairs;
    }

    /**
     * This method is used to improve the localization of error messages by
     * choosing an alternative rather than throwing a
     * {@link NoViableAltException} in particular prediction scenarios where the
     * {@link //ERROR} state was reached during ATN simulation.
     *
     * <p>
     * The default implementation of this method uses the following
     * algorithm to identify an ATN configuration which successfully parsed the
     * decision entry rule. Choosing such an alternative ensures that the
     * {@link ParserRuleContext} returned by the calling rule will be complete
     * and valid, and the syntax error will be reported later at a more
     * localized location.</p>
     *
     * <ul>
     * <li>If a syntactically valid path or paths reach the end of the decision rule and
     * they are semantically valid if predicated, return the min associated alt.</li>
     * <li>Else, if a semantically invalid but syntactically valid path exist
     * or paths exist, return the minimum associated alt.
     * </li>
     * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
     * </ul>
     *
     * <p>
     * In some scenarios, the algorithm described above could predict an
     * alternative which will result in a {@link FailedPredicateException} in
     * the parser. Specifically, this could occur if the <em>only</em> configuration
     * capable of successfully parsing to the end of the decision rule is
     * blocked by a semantic predicate. By choosing this alternative within
     * {@link //adaptivePredict} instead of throwing a
     * {@link NoViableAltException}, the resulting
     * {@link FailedPredicateException} in the parser will identify the specific
     * predicate which is preventing the parser from successfully parsing the
     * decision rule, which helps developers identify and correct logic errors
     * in semantic predicates.
     * </p>
     *
     * @param configs The ATN configurations which were valid immediately before
     * the {@link //ERROR} state was reached
     * @param outerContext The is the \gamma_0 initial parser context from the paper
     * or the parser stack at the instant before prediction commences.
     *
     * @return The value to return from {@link //adaptivePredict}, or
     * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
     * identified and {@link //adaptivePredict} should report an error instead
     */
    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
        const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
        const semValidConfigs = cfgs[0];
        const semInvalidConfigs = cfgs[1];
        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
        if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists
            return alt;
        }
        // Is there a syntactically valid path with a failed pred?
        if (semInvalidConfigs.items.length>0) {
            alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
            if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists
                return alt;
            }
        }
        return ATN.INVALID_ALT_NUMBER;
    }

    getAltThatFinishedDecisionEntryRule(configs) {
        const alts = [];
        for(let i=0;i<configs.items.length; i++) {
            const c = configs.items[i];
            if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {
                if(alts.indexOf(c.alt)<0) {
                    alts.push(c.alt);
                }
            }
        }
        if (alts.length===0) {
            return ATN.INVALID_ALT_NUMBER;
        } else {
            return Math.min.apply(null, alts);
        }
    }

    /**
     * Walk the list of configurations and split them according to
     * those that have preds evaluating to true/false.  If no pred, assume
     * true pred and include in succeeded set.  Returns Pair of sets.
     *
     * Create a new set so as not to alter the incoming parameter.
     *
     * Assumption: the input stream has been restored to the starting point
     * prediction, which is where predicates need to evaluate.*/
    splitAccordingToSemanticValidity( configs, outerContext) {
        const succeeded = new ATNConfigSet(configs.fullCtx);
        const failed = new ATNConfigSet(configs.fullCtx);
        for(let i=0;i<configs.items.length; i++) {
            const c = configs.items[i];
            if (c.semanticContext !== SemanticContext.NONE) {
                const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
                if (predicateEvaluationResult) {
                    succeeded.add(c);
                } else {
                    failed.add(c);
                }
            } else {
                succeeded.add(c);
            }
        }
        return [succeeded, failed];
    }

    /**
     * Look through a list of predicate/alt pairs, returning alts for the
     * pairs that win. A {@code NONE} predicate indicates an alt containing an
     * unpredicated config which behaves as "always true." If !complete
     * then we stop at the first predicate that evaluates to true. This
     * includes pairs with null predicates.
     */
    evalSemanticContext(predPredictions, outerContext, complete) {
        const predictions = new BitSet();
        for(let i=0;i<predPredictions.length;i++) {
            const pair = predPredictions[i];
            if (pair.pred === SemanticContext.NONE) {
                predictions.add(pair.alt);
                if (! complete) {
                    break;
                }
                continue;
            }
            const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
            if (this.debug || this.dfa_debug) {
                console.log("eval pred " + pair + "=" + predicateEvaluationResult);
            }
            if (predicateEvaluationResult) {
                if (this.debug || this.dfa_debug) {
                    console.log("PREDICT " + pair.alt);
                }
                predictions.add(pair.alt);
                if (! complete) {
                    break;
                }
            }
        }
        return predictions;
    }

// TODO: If we are doing predicates, there is no point in pursuing
//     closure operations if we reach a DFA state that uniquely predicts
//     alternative. We will not be caching that DFA state and it is a
//     waste to pursue the closure. Might have to advance when we do
//     ambig detection thought :(
//
    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
        const initialDepth = 0;
        this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,
                                 fullCtx, initialDepth, treatEofAsEpsilon);
    }

    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
        if (this.debug || this.debug_closure) {
            console.log("closure(" + config.toString(this.parser,true) + ")");
            // console.log("configs(" + configs.toString() + ")");
            if(config.reachesIntoOuterContext>50) {
                throw "problem";
            }
        }
        if (config.state instanceof RuleStopState) {
            // We hit rule end. If we have context info, use it
            // run thru all possible stack tops in ctx
            if (! config.context.isEmpty()) {
                for (let i =0; i<config.context.length; i++) {
                    if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
                        if (fullCtx) {
                            configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);
                            continue;
                        } else {
                            // we have no context info, just chase follow links (if greedy)
                            if (this.debug) {
                                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                            }
                            this.closure_(config, configs, closureBusy, collectPredicates,
                                     fullCtx, depth, treatEofAsEpsilon);
                        }
                        continue;
                    }
                    const returnState = this.atn.states[config.context.getReturnState(i)];
                    const newContext = config.context.getParent(i); // "pop" return state
                    const parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};
                    const c = new ATNConfig(parms, null);
                    // While we have context to pop back from, we may have
                    // gotten that context AFTER having falling off a rule.
                    // Make sure we track that we are now out of context.
                    c.reachesIntoOuterContext = config.reachesIntoOuterContext;
                    this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
                }
                return;
            } else if( fullCtx) {
                // reached end of start rule
                configs.add(config, this.mergeCache);
                return;
            } else {
                // else if we have no context info, just chase follow links (if greedy)
                if (this.debug) {
                    console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                }
            }
        }
        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
    }

    // Do the actual work of walking epsilon edges//
    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
        const p = config.state;
        // optimization
        if (! p.epsilonOnlyTransitions) {
            configs.add(config, this.mergeCache);
            // make sure to not return here, because EOF transitions can act as
            // both epsilon transitions and non-epsilon transitions.
        }
        for(let i = 0;i<p.transitions.length; i++) {
            if(i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))
                continue;

            const t = p.transitions[i];
            const continueCollecting = collectPredicates && !(t instanceof ActionTransition);
            const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
            if (c!==null) {
                let newDepth = depth;
                if ( config.state instanceof RuleStopState) {
                    // target fell off end of rule; mark resulting c as having dipped into outer context
                    // We can't get here if incoming config was rule stop and we had context
                    // track how far we dip into outer context.  Might
                    // come in handy and we avoid evaluating context dependent
                    // preds if this is > 0.
                    if (this._dfa !== null && this._dfa.precedenceDfa) {
                        if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
                            c.precedenceFilterSuppressed = true;
                        }
                    }

                    c.reachesIntoOuterContext += 1;
                    if (closureBusy.add(c)!==c) {
                        // avoid infinite recursion for right-recursive rules
                        continue;
                    }
                    configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
                    newDepth -= 1;
                    if (this.debug) {
                        console.log("dips into outer ctx: " + c);
                    }
                } else {
                    if (!t.isEpsilon && closureBusy.add(c)!==c){
                        // avoid infinite recursion for EOF* and EOF+
                        continue;
                    }
                    if (t instanceof RuleTransition) {
                        // latch when newDepth goes negative - once we step out of the entry context we can't return
                        if (newDepth >= 0) {
                            newDepth += 1;
                        }
                    }
                }
                this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
            }
        }
    }

    canDropLoopEntryEdgeInLeftRecursiveRule(config) {
        // return False
        const p = config.state;
        // First check to see if we are in StarLoopEntryState generated during
        // left-recursion elimination. For efficiency, also check if
        // the context has an empty stack case. If so, it would mean
        // global FOLLOW so we can't perform optimization
        // Are we the special loop entry/exit state? or SLL wildcard
        if(p.stateType !== ATNState.STAR_LOOP_ENTRY)
            return false;
        if(p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||
               config.context.isEmpty() || config.context.hasEmptyPath())
            return false;

        // Require all return states to return back to the same rule that p is in.
        const numCtxs = config.context.length;
        for(let i=0; i<numCtxs; i++) { // for each stack context
            const returnState = this.atn.states[config.context.getReturnState(i)];
            if (returnState.ruleIndex !== p.ruleIndex)
                return false;
        }

        const decisionStartState = p.transitions[0].target;
        const blockEndStateNum = decisionStartState.endState.stateNumber;
        const blockEndState = this.atn.states[blockEndStateNum];

        // Verify that the top of each stack context leads to loop entry/exit
        // state through epsilon edges and w/o leaving rule.
        for(let i=0; i<numCtxs; i++) { // for each stack context
            const returnStateNumber = config.context.getReturnState(i);
            const returnState = this.atn.states[returnStateNumber];
            // all states must have single outgoing epsilon edge
            if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)
                return false;

            // Look for prefix op case like 'not expr', (' type ')' expr
            const returnStateTarget = returnState.transitions[0].target;
            if ( returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p )
                continue;

            // Look for 'expr op expr' or case where expr's return state is block end
            // of (...)* internal block; the block end points to loop back
            // which points to p but we don't need to check that
            if ( returnState === blockEndState )
                continue;

            // Look for ternary expr ? expr : expr. The return state points at block end,
            // which points at loop entry state
            if ( returnStateTarget === blockEndState )
                continue;

            // Look for complex prefix 'between expr and expr' case where 2nd expr's
            // return state points at block end state of (...)* internal block
            if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1
                    && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)
                continue;

            // anything else ain't conforming
            return false;
        }
        return true;
    }

    getRuleName(index) {
        if (this.parser!==null && index>=0) {
            return this.parser.ruleNames[index];
        } else {
            return "<rule " + index + ">";
        }
    }

    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
        switch(t.serializationType) {
        case Transition.RULE:
            return this.ruleTransition(config, t);
        case Transition.PRECEDENCE:
            return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
        case Transition.PREDICATE:
            return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
        case Transition.ACTION:
            return this.actionTransition(config, t);
        case Transition.EPSILON:
            return new ATNConfig({state:t.target}, config);
        case Transition.ATOM:
        case Transition.RANGE:
        case Transition.SET:
            // EOF transitions act like epsilon transitions after the first EOF
            // transition is traversed
            if (treatEofAsEpsilon) {
                if (t.matches(Token.EOF, 0, 1)) {
                    return new ATNConfig({state: t.target}, config);
                }
            }
            return null;
        default:
            return null;
        }
    }

    actionTransition(config, t) {
        if (this.debug) {
            const index = t.actionIndex === -1 ? 65535 : t.actionIndex;
            console.log("ACTION edge " + t.ruleIndex + ":" + index);
        }
        return new ATNConfig({state:t.target}, config);
    }

    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
        if (this.debug) {
            console.log("PRED (collectPredicates=" + collectPredicates + ") " +
                    pt.precedence + ">=_p, ctx dependent=true");
            if (this.parser!==null) {
                console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
            }
        }
        let c = null;
        if (collectPredicates && inContext) {
            if (fullCtx) {
                // In full context mode, we can evaluate predicates on-the-fly
                // during closure, which dramatically reduces the size of
                // the config sets. It also obviates the need to test predicates
                // later during conflict resolution.
                const currentPosition = this._input.index;
                this._input.seek(this._startIndex);
                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
                this._input.seek(currentPosition);
                if (predSucceeds) {
                    c = new ATNConfig({state:pt.target}, config); // no pred context
                }
            } else {
                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
            }
        } else {
            c = new ATNConfig({state:pt.target}, config);
        }
        if (this.debug) {
            console.log("config from pred transition=" + c);
        }
        return c;
    }

    predTransition(config, pt, collectPredicates, inContext, fullCtx) {
        if (this.debug) {
            console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex +
                    ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
            if (this.parser!==null) {
                console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
            }
        }
        let c = null;
        if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {
            if (fullCtx) {
                // In full context mode, we can evaluate predicates on-the-fly
                // during closure, which dramatically reduces the size of
                // the config sets. It also obviates the need to test predicates
                // later during conflict resolution.
                const currentPosition = this._input.index;
                this._input.seek(this._startIndex);
                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
                this._input.seek(currentPosition);
                if (predSucceeds) {
                    c = new ATNConfig({state:pt.target}, config); // no pred context
                }
            } else {
                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
            }
        } else {
            c = new ATNConfig({state:pt.target}, config);
        }
        if (this.debug) {
            console.log("config from pred transition=" + c);
        }
        return c;
    }

    ruleTransition(config, t) {
        if (this.debug) {
            console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
        }
        const returnState = t.followState;
        const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
        return new ATNConfig({state:t.target, context:newContext}, config );
    }

    getConflictingAlts(configs) {
        const altsets = PredictionMode.getConflictingAltSubsets(configs);
        return PredictionMode.getAlts(altsets);
    }

    /**
     * Sam pointed out a problem with the previous definition, v3, of
     * ambiguous states. If we have another state associated with conflicting
     * alternatives, we should keep going. For example, the following grammar
     *
     * s : (ID | ID ID?) ';' ;
     *
     * When the ATN simulation reaches the state before ';', it has a DFA
     * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
     * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
     * because alternative to has another way to continue, via [6|2|[]].
     * The key is that we have a single state that has config's only associated
     * with a single alternative, 2, and crucially the state transitions
     * among the configurations are all non-epsilon transitions. That means
     * we don't consider any conflicts that include alternative 2. So, we
     * ignore the conflict between alts 1 and 2. We ignore a set of
     * conflicting alts when there is an intersection with an alternative
     * associated with a single alt state in the state&rarr;config-list map.
     *
     * It's also the case that we might have two conflicting configurations but
     * also a 3rd nonconflicting configuration for a different alternative:
     * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
     *
     * a : A | A | A B ;
     *
     * After matching input A, we reach the stop state for rule A, state 1.
     * State 8 is the state right before B. Clearly alternatives 1 and 2
     * conflict and no amount of further lookahead will separate the two.
     * However, alternative 3 will be able to continue and so we do not
     * stop working on this state. In the previous example, we're concerned
     * with states associated with the conflicting alternatives. Here alt
     * 3 is not associated with the conflicting configs, but since we can continue
     * looking for input reasonably, I don't declare the state done. We
     * ignore a set of conflicting alts when we have an alternative
     * that we still need to pursue
     */
    getConflictingAltsOrUniqueAlt(configs) {
        let conflictingAlts = null;
        if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {
            conflictingAlts = new BitSet();
            conflictingAlts.add(configs.uniqueAlt);
        } else {
            conflictingAlts = configs.conflictingAlts;
        }
        return conflictingAlts;
    }

    getTokenName(t) {
        if (t===Token.EOF) {
            return "EOF";
        }
        if( this.parser!==null && this.parser.literalNames!==null) {
            if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
                console.log("" + t + " ttype out of range: " + this.parser.literalNames);
                console.log("" + this.parser.getInputStream().getTokens());
            } else {
                const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];
                return name + "<" + t + ">";
            }
        }
        return "" + t;
    }

    getLookaheadName(input) {
        return this.getTokenName(input.LA(1));
    }

    /**
     * Used for debugging in adaptivePredict around execATN but I cut
     * it out for clarity now that alg. works well. We can leave this
     * "dead" code for a bit
     */
    dumpDeadEndConfigs(nvae) {
        console.log("dead end configs: ");
        const decs = nvae.getDeadEndConfigs();
        for(let i=0; i<decs.length; i++) {
            const c = decs[i];
            let trans = "no edges";
            if (c.state.transitions.length>0) {
                const t = c.state.transitions[0];
                if (t instanceof AtomTransition) {
                    trans = "Atom "+ this.getTokenName(t.label);
                } else if (t instanceof SetTransition) {
                    const neg = (t instanceof NotSetTransition);
                    trans = (neg ? "~" : "") + "Set " + t.set;
                }
            }
            console.error(c.toString(this.parser, true) + ":" + trans);
        }
    }

    noViableAlt(input, outerContext, configs, startIndex) {
        return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
    }

    getUniqueAlt(configs) {
        let alt = ATN.INVALID_ALT_NUMBER;
        for(let i=0;i<configs.items.length;i++) {
            const c = configs.items[i];
            if (alt === ATN.INVALID_ALT_NUMBER) {
                alt = c.alt; // found first alt
            } else if( c.alt!==alt) {
                return ATN.INVALID_ALT_NUMBER;
            }
        }
        return alt;
    }

    /**
     * Add an edge to the DFA, if possible. This method calls
     * {@link //addDFAState} to ensure the {@code to} state is present in the
     * DFA. If {@code from} is {@code null}, or if {@code t} is outside the
     * range of edges that can be represented in the DFA tables, this method
     * returns without adding the edge to the DFA.
     *
     * <p>If {@code to} is {@code null}, this method returns {@code null}.
     * Otherwise, this method returns the {@link DFAState} returned by calling
     * {@link //addDFAState} for the {@code to} state.</p>
     *
     * @param dfa The DFA
     * @param from_ The source state for the edge
     * @param t The input symbol
     * @param to The target state for the edge
     *
     * @return If {@code to} is {@code null}, this method returns {@code null};
     * otherwise this method returns the result of calling {@link //addDFAState}
     * on {@code to}
     */
    addDFAEdge(dfa, from_, t, to) {
        if( this.debug) {
            console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
        }
        if (to===null) {
            return null;
        }
        to = this.addDFAState(dfa, to); // used existing if possible not incoming
        if (from_===null || t < -1 || t > this.atn.maxTokenType) {
            return to;
        }
        if (from_.edges===null) {
            from_.edges = [];
        }
        from_.edges[t+1] = to; // connect

        if (this.debug) {
            const literalNames = this.parser===null ? null : this.parser.literalNames;
            const symbolicNames = this.parser===null ? null : this.parser.symbolicNames;
            console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
        }
        return to;
    }

    /**
     * Add state {@code D} to the DFA if it is not already present, and return
     * the actual instance stored in the DFA. If a state equivalent to {@code D}
     * is already in the DFA, the existing state is returned. Otherwise this
     * method returns {@code D} after adding it to the DFA.
     *
     * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
     * does not change the DFA.</p>
     *
     * @param dfa The dfa
     * @param D The DFA state to add
     * @return The state stored in the DFA. This will be either the existing
     * state if {@code D} is already in the DFA, or {@code D} itself if the
     * state was not already present
     */
    addDFAState(dfa, D) {
        if (D === ATNSimulator.ERROR) {
            return D;
        }
        const existing = dfa.states.get(D);
        if(existing!==null) {
            return existing;
        }
        D.stateNumber = dfa.states.length;
        if (! D.configs.readOnly) {
            D.configs.optimizeConfigs(this);
            D.configs.setReadonly(true);
        }
        dfa.states.add(D);
        if (this.debug) {
            console.log("adding new DFA state: " + D);
        }
        return D;
    }

    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
        if (this.debug || this.retry_debug) {
            const interval = new Interval(startIndex, stopIndex + 1);
            console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs +
                               ", input=" + this.parser.getTokenStream().getText(interval));
        }
        if (this.parser!==null) {
            this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
        }
    }

    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
        if (this.debug || this.retry_debug) {
            const interval = new Interval(startIndex, stopIndex + 1);
            console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs +
                               ", input=" + this.parser.getTokenStream().getText(interval));
        }
        if (this.parser!==null) {
            this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
        }
    }

    // If context sensitive parsing, we know it's ambiguity not conflict//
    reportAmbiguity(dfa, D, startIndex, stopIndex,
                                   exact, ambigAlts, configs ) {
        if (this.debug || this.retry_debug) {
            const interval = new Interval(startIndex, stopIndex + 1);
            console.log("reportAmbiguity " + ambigAlts + ":" + configs +
                               ", input=" + this.parser.getTokenStream().getText(interval));
        }
        if (this.parser!==null) {
            this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
        }
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var atn = { ATN, ATNDeserializer, LexerATNSimulator, ParserATNSimulator, PredictionMode };

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * A DFA walker that knows how to dump them to serialized strings.
 */
class DFASerializer {
    constructor(dfa, literalNames, symbolicNames) {
        this.dfa = dfa;
        this.literalNames = literalNames || [];
        this.symbolicNames = symbolicNames || [];
    }

    toString() {
       if(this.dfa.s0 === null) {
           return null;
       }
       let buf = "";
       const states = this.dfa.sortedStates();
       for(let i=0; i<states.length; i++) {
           const s = states[i];
           if(s.edges!==null) {
                const n = s.edges.length;
                for(let j=0;j<n;j++) {
                    const t = s.edges[j] || null;
                    if(t!==null && t.stateNumber !== 0x7FFFFFFF) {
                        buf = buf.concat(this.getStateString(s));
                        buf = buf.concat("-");
                        buf = buf.concat(this.getEdgeLabel(j));
                        buf = buf.concat("->");
                        buf = buf.concat(this.getStateString(t));
                        buf = buf.concat('\n');
                    }
                }
           }
       }
       return buf.length===0 ? null : buf;
    }

    getEdgeLabel(i) {
        if (i===0) {
            return "EOF";
        } else if(this.literalNames !==null || this.symbolicNames!==null) {
            return this.literalNames[i-1] || this.symbolicNames[i-1];
        } else {
            return String.fromCharCode(i-1);
        }
    }

    getStateString(s) {
        const baseStateStr = ( s.isAcceptState ? ":" : "") + "s" + s.stateNumber + ( s.requiresFullContext ? "^" : "");
        if(s.isAcceptState) {
            if (s.predicates !== null) {
                return baseStateStr + "=>" + arrayToString(s.predicates);
            } else {
                return baseStateStr + "=>" + s.prediction.toString();
            }
        } else {
            return baseStateStr;
        }
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class LexerDFASerializer extends DFASerializer {
    constructor(dfa) {
        super(dfa, null);
    }

    getEdgeLabel(i) {
        return "'" + String.fromCharCode(i) + "'";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class DFA {
	constructor(atnStartState, decision) {
		if (decision === undefined) {
			decision = 0;
		}
		/**
		 * From which ATN state did we create this DFA?
		 */
		this.atnStartState = atnStartState;
		this.decision = decision;
		/**
		 * A set of all DFA states. Use {@link Map} so we can get old state back
		 * ({@link Set} only allows you to see if it's there).
		 */
		this._states = new HashSet();
		this.s0 = null;
		/**
		 * {@code true} if this DFA is for a precedence decision; otherwise,
		 * {@code false}. This is the backing field for {@link //isPrecedenceDfa},
		 * {@link //setPrecedenceDfa}
		 */
		this.precedenceDfa = false;
		if (atnStartState instanceof StarLoopEntryState)
		{
			if (atnStartState.isPrecedenceDecision) {
				this.precedenceDfa = true;
				const precedenceState = new DFAState(null, new ATNConfigSet());
				precedenceState.edges = [];
				precedenceState.isAcceptState = false;
				precedenceState.requiresFullContext = false;
				this.s0 = precedenceState;
			}
		}
	}

	/**
	 * Get the start state for a specific precedence value.
	 *
	 * @param precedence The current precedence.
	 * @return The start state corresponding to the specified precedence, or
	 * {@code null} if no start state exists for the specified precedence.
	 *
	 * @throws IllegalStateException if this is not a precedence DFA.
	 * @see //isPrecedenceDfa()
	 */
	getPrecedenceStartState(precedence) {
		if (!(this.precedenceDfa)) {
			throw ("Only precedence DFAs may contain a precedence start state.");
		}
		// s0.edges is never null for a precedence DFA
		if (precedence < 0 || precedence >= this.s0.edges.length) {
			return null;
		}
		return this.s0.edges[precedence] || null;
	}

	/**
	 * Set the start state for a specific precedence value.
	 *
	 * @param precedence The current precedence.
	 * @param startState The start state corresponding to the specified
	 * precedence.
	 *
	 * @throws IllegalStateException if this is not a precedence DFA.
	 * @see //isPrecedenceDfa()
	 */
	setPrecedenceStartState(precedence, startState) {
		if (!(this.precedenceDfa)) {
			throw ("Only precedence DFAs may contain a precedence start state.");
		}
		if (precedence < 0) {
			return;
		}

		/**
		 * synchronization on s0 here is ok. when the DFA is turned into a
		 * precedence DFA, s0 will be initialized once and not updated again
		 * s0.edges is never null for a precedence DFA
		 */
		this.s0.edges[precedence] = startState;
	}

	/**
	 * Sets whether this is a precedence DFA. If the specified value differs
	 * from the current DFA configuration, the following actions are taken;
	 * otherwise no changes are made to the current DFA.
	 *
	 * <ul>
	 * <li>The {@link //states} map is cleared</li>
	 * <li>If {@code precedenceDfa} is {@code false}, the initial state
	 * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
	 * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
	 * store the start states for individual precedence values.</li>
	 * <li>The {@link //precedenceDfa} field is updated</li>
	 * </ul>
	 *
	 * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
	 * {@code false}
	 */
	setPrecedenceDfa(precedenceDfa) {
		if (this.precedenceDfa!==precedenceDfa) {
			this._states = new HashSet();
			if (precedenceDfa) {
				const precedenceState = new DFAState(null, new ATNConfigSet());
				precedenceState.edges = [];
				precedenceState.isAcceptState = false;
				precedenceState.requiresFullContext = false;
				this.s0 = precedenceState;
			} else {
				this.s0 = null;
			}
			this.precedenceDfa = precedenceDfa;
		}
	}

	/**
	 * Return a list of all states in this DFA, ordered by state number.
	 */
	sortedStates() {
		const list = this._states.values();
		return list.sort(function(a, b) {
			return a.stateNumber - b.stateNumber;
		});
	}

	toString(literalNames, symbolicNames) {
		literalNames = literalNames || null;
		symbolicNames = symbolicNames || null;
		if (this.s0 === null) {
			return "";
		}
		const serializer = new DFASerializer(this, literalNames, symbolicNames);
		return serializer.toString();
	}

	toLexerString() {
		if (this.s0 === null) {
			return "";
		}
		const serializer = new LexerDFASerializer(this);
		return serializer.toString();
	}

	get states(){
		return this._states;
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var dfa = { DFA, DFASerializer, LexerDFASerializer, PredPrediction };

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class ParseTreeListener {
    visitTerminal(node) {
    }

    visitErrorNode(node) {
    }

    enterEveryRule(node) {
    }

    exitEveryRule(node) {
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class ParseTreeVisitor {
    visit(ctx) {
        if (Array.isArray(ctx)) {
            return ctx.map(function(child) {
                return child.accept(this);
            }, this);
        } else {
            return ctx.accept(this);
        }
    }

    visitChildren(ctx) {
        if (ctx.children) {
            return this.visit(ctx.children);
        } else {
            return null;
        }
    }

    visitTerminal(node) {
    }

    visitErrorNode(node) {
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ParseTreeWalker {

    /**
     * Performs a walk on the given parse tree starting at the root and going down recursively
     * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before
     * recursively walking down into child nodes, then
     * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.
     * @param listener The listener used by the walker to process grammar rules
     * @param t The parse tree to be walked on
     */
    walk(listener, t) {
        const errorNode = t instanceof ErrorNode ||
            (t.isErrorNode !== undefined && t.isErrorNode());
        if (errorNode) {
            listener.visitErrorNode(t);
        } else if (t instanceof TerminalNode) {
            listener.visitTerminal(t);
        } else {
            this.enterRule(listener, t);
            for (let i = 0; i < t.getChildCount(); i++) {
                const child = t.getChild(i);
                this.walk(listener, child);
            }
            this.exitRule(listener, t);
        }
    }

    /**
     * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}
     * then by triggering the event specific to the given parse tree node
     * @param listener The listener responding to the trigger events
     * @param r The grammar rule containing the rule context
     */
    enterRule(listener, r) {
        const ctx = r.getRuleContext();
        listener.enterEveryRule(ctx);
        ctx.enterRule(listener);
    }

    /**
     * Exits a grammar rule by first triggering the event specific to the given parse tree node
     * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}
     * @param listener The listener responding to the trigger events
     * @param r The grammar rule containing the rule context
     */
    exitRule(listener, r) {
        const ctx = r.getRuleContext();
        ctx.exitRule(listener);
        listener.exitEveryRule(ctx);
    }
}

ParseTreeWalker.DEFAULT = new ParseTreeWalker();

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var tree = { Trees, RuleNode, ErrorNode, TerminalNode, ParseTreeListener, ParseTreeVisitor, ParseTreeWalker };

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * This signifies any kind of mismatched input exceptions such as
 * when the current input does not match the expected token.
 */
class InputMismatchException extends RecognitionException {
    constructor(recognizer) {
        super({message: "", recognizer: recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx});
        this.offendingToken = recognizer.getCurrentToken();
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * A semantic predicate failed during validation. Validation of predicates
 * occurs when normally parsing the alternative just like matching a token.
 * Disambiguating predicate evaluation occurs when we test a predicate during
 * prediction.
 */
class FailedPredicateException extends RecognitionException {
    constructor(recognizer, predicate, message) {
        super({
            message: formatMessage(predicate, message || null), recognizer: recognizer,
            input: recognizer.getInputStream(), ctx: recognizer._ctx
        });
        const s = recognizer._interp.atn.states[recognizer.state];
        const trans = s.transitions[0];
        if (trans instanceof PredicateTransition) {
            this.ruleIndex = trans.ruleIndex;
            this.predicateIndex = trans.predIndex;
        } else {
            this.ruleIndex = 0;
            this.predicateIndex = 0;
        }
        this.predicate = predicate;
        this.offendingToken = recognizer.getCurrentToken();
    }
}


function formatMessage(predicate, message) {
    if (message !==null) {
        return message;
    } else {
        return "failed predicate: {" + predicate + "}?";
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */


/**
 * This implementation of {@link ANTLRErrorListener} can be used to identify
 *  certain potential correctness and performance problems in grammars. "Reports"
 *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate
 *  message.
 *
 *  <ul>
 *  <li><b>Ambiguities</b>: These are cases where more than one path through the
 *  grammar can match the input.</li>
 *  <li><b>Weak context sensitivity</b>: These are cases where full-context
 *  prediction resolved an SLL conflict to a unique alternative which equaled the
 *  minimum alternative of the SLL conflict.</li>
 *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the
 *  full-context prediction resolved an SLL conflict to a unique alternative,
 *  <em>and</em> the minimum alternative of the SLL conflict was found to not be
 *  a truly viable alternative. Two-stage parsing cannot be used for inputs where
 *  this situation occurs.</li>
 *  </ul>
 */
class DiagnosticErrorListener extends ErrorListener {
	constructor(exactOnly) {
		super();
		exactOnly = exactOnly || true;
		// whether all ambiguities or only exact ambiguities are reported.
		this.exactOnly = exactOnly;
	}

	reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
		if (this.exactOnly && !exact) {
			return;
		}
		const msg = "reportAmbiguity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			": ambigAlts=" +
			this.getConflictingAlts(ambigAlts, configs) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
		recognizer.notifyErrorListeners(msg);
	}

	reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
		const msg = "reportAttemptingFullContext d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
		recognizer.notifyErrorListeners(msg);
	}

	reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
		const msg = "reportContextSensitivity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
		recognizer.notifyErrorListeners(msg);
	}

	getDecisionDescription(recognizer, dfa) {
		const decision = dfa.decision;
		const ruleIndex = dfa.atnStartState.ruleIndex;

		const ruleNames = recognizer.ruleNames;
		if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
			return "" + decision;
		}
		const ruleName = ruleNames[ruleIndex] || null;
		if (ruleName === null || ruleName.length === 0) {
			return "" + decision;
		}
		return `${decision} (${ruleName})`;
	}

	/**
	 * Computes the set of conflicting or ambiguous alternatives from a
	 * configuration set, if that information was not already provided by the
	 * parser.
	 *
	 * @param reportedAlts The set of conflicting or ambiguous alternatives, as
	 * reported by the parser.
	 * @param configs The conflicting or ambiguous configuration set.
	 * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
	 * returns the set of alternatives represented in {@code configs}.
     */
	getConflictingAlts(reportedAlts, configs) {
		if (reportedAlts !== null) {
			return reportedAlts;
		}
		const result = new BitSet();
		for (let i = 0; i < configs.items.length; i++) {
			result.add(configs.items[i].alt);
		}
		return `{${result.values().join(", ")}}`;
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class ParseCancellationException extends Error {
    constructor() {
        super();
        Error.captureStackTrace(this, ParseCancellationException);
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ErrorStrategy {

    reset(recognizer) {
    }

    recoverInline(recognizer) {
    }

    recover(recognizer, e) {
    }

    sync(recognizer) {
    }

    inErrorRecoveryMode(recognizer) {
    }

    reportError(recognizer) {
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * This is the default implementation of {@link ANTLRErrorStrategy} used for
 * error reporting and recovery in ANTLR parsers.
 */
class DefaultErrorStrategy extends ErrorStrategy {
    constructor() {
        super();
        /**
         * Indicates whether the error strategy is currently "recovering from an
         * error". This is used to suppress reporting multiple error messages while
         * attempting to recover from a detected syntax error.
         *
         * @see //inErrorRecoveryMode
         */
        this.errorRecoveryMode = false;

        /**
         * The index into the input stream where the last error occurred.
         * This is used to prevent infinite loops where an error is found
         * but no token is consumed during recovery...another error is found,
         * ad nauseum. This is a failsafe mechanism to guarantee that at least
         * one token/tree node is consumed for two errors.
         */
        this.lastErrorIndex = -1;
        this.lastErrorStates = null;
        this.nextTokensContext = null;
        this.nextTokenState = 0;
    }

    /**
     * <p>The default implementation simply calls {@link //endErrorCondition} to
     * ensure that the handler is not in error recovery mode.</p>
     */
    reset(recognizer) {
        this.endErrorCondition(recognizer);
    }

    /**
     * This method is called to enter error recovery mode when a recognition
     * exception is reported.
     *
     * @param recognizer the parser instance
     */
    beginErrorCondition(recognizer) {
        this.errorRecoveryMode = true;
    }

    inErrorRecoveryMode(recognizer) {
        return this.errorRecoveryMode;
    }

    /**
     * This method is called to leave error recovery mode after recovering from
     * a recognition exception.
     * @param recognizer
     */
    endErrorCondition(recognizer) {
        this.errorRecoveryMode = false;
        this.lastErrorStates = null;
        this.lastErrorIndex = -1;
    }

    /**
     * {@inheritDoc}
     * <p>The default implementation simply calls {@link //endErrorCondition}.</p>
     */
    reportMatch(recognizer) {
        this.endErrorCondition(recognizer);
    }

    /**
     * {@inheritDoc}
     *
     * <p>The default implementation returns immediately if the handler is already
     * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
     * and dispatches the reporting task based on the runtime type of {@code e}
     * according to the following table.</p>
     *
     * <ul>
     * <li>{@link NoViableAltException}: Dispatches the call to
     * {@link //reportNoViableAlternative}</li>
     * <li>{@link InputMismatchException}: Dispatches the call to
     * {@link //reportInputMismatch}</li>
     * <li>{@link FailedPredicateException}: Dispatches the call to
     * {@link //reportFailedPredicate}</li>
     * <li>All other types: calls {@link Parser//notifyErrorListeners} to report
     * the exception</li>
     * </ul>
     */
    reportError(recognizer, e) {
        // if we've already reported an error and have not matched a token
        // yet successfully, don't report any errors.
        if(this.inErrorRecoveryMode(recognizer)) {
            return; // don't report spurious errors
        }
        this.beginErrorCondition(recognizer);
        if ( e instanceof NoViableAltException ) {
            this.reportNoViableAlternative(recognizer, e);
        } else if ( e instanceof InputMismatchException ) {
            this.reportInputMismatch(recognizer, e);
        } else if ( e instanceof FailedPredicateException ) {
            this.reportFailedPredicate(recognizer, e);
        } else {
            console.log("unknown recognition error type: " + e.constructor.name);
            console.log(e.stack);
            recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
        }
    }

    /**
     *
     * {@inheritDoc}
     *
     * <p>The default implementation resynchronizes the parser by consuming tokens
     * until we find one in the resynchronization set--loosely the set of tokens
     * that can follow the current rule.</p>
     *
     */
    recover(recognizer, e) {
        if (this.lastErrorIndex===recognizer.getInputStream().index &&
            this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {
            // uh oh, another error at same token index and previously-visited
            // state in ATN; must be a case where LT(1) is in the recovery
            // token set so nothing got consumed. Consume a single token
            // at least to prevent an infinite loop; this is a failsafe.
            recognizer.consume();
        }
        this.lastErrorIndex = recognizer._input.index;
        if (this.lastErrorStates === null) {
            this.lastErrorStates = [];
        }
        this.lastErrorStates.push(recognizer.state);
        const followSet = this.getErrorRecoverySet(recognizer);
        this.consumeUntil(recognizer, followSet);
    }

    /**
     * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
     * that the current lookahead symbol is consistent with what were expecting
     * at this point in the ATN. You can call this anytime but ANTLR only
     * generates code to check before subrules/loops and each iteration.
     *
     * <p>Implements Jim Idle's magic sync mechanism in closures and optional
     * subrules. E.g.,</p>
     *
     * <pre>
     * a : sync ( stuff sync )* ;
     * sync : {consume to what can follow sync} ;
     * </pre>
     *
     * At the start of a sub rule upon error, {@link //sync} performs single
     * token deletion, if possible. If it can't do that, it bails on the current
     * rule and uses the default error recovery, which consumes until the
     * resynchronization set of the current rule.
     *
     * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
     * with an empty alternative), then the expected set includes what follows
     * the subrule.</p>
     *
     * <p>During loop iteration, it consumes until it sees a token that can start a
     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
     * stay in the loop as long as possible.</p>
     *
     * <p><strong>ORIGINS</strong></p>
     *
     * <p>Previous versions of ANTLR did a poor job of their recovery within loops.
     * A single mismatch token or missing token would force the parser to bail
     * out of the entire rules surrounding the loop. So, for rule</p>
     *
     * <pre>
     * classDef : 'class' ID '{' member* '}'
     * </pre>
     *
     * input with an extra token between members would force the parser to
     * consume until it found the next class definition rather than the next
     * member definition of the current class.
     *
     * <p>This functionality cost a little bit of effort because the parser has to
     * compare token set at the start of the loop and at each iteration. If for
     * some reason speed is suffering for you, you can turn off this
     * functionality by simply overriding this method as a blank { }.</p>
     *
     */
    sync(recognizer) {
        // If already recovering, don't try to sync
        if (this.inErrorRecoveryMode(recognizer)) {
            return;
        }
        const s = recognizer._interp.atn.states[recognizer.state];
        const la = recognizer.getTokenStream().LA(1);
        // try cheaper subset first; might get lucky. seems to shave a wee bit off
        const nextTokens = recognizer.atn.nextTokens(s);
        if(nextTokens.contains(la)) {
            this.nextTokensContext = null;
            this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
            return;
        } else if (nextTokens.contains(Token.EPSILON)) {
            if(this.nextTokensContext === null) {
                // It's possible the next token won't match information tracked
                // by sync is restricted for performance.
                this.nextTokensContext = recognizer._ctx;
                this.nextTokensState = recognizer._stateNumber;
            }
            return;
        }
        switch (s.stateType) {
            case ATNState.BLOCK_START:
            case ATNState.STAR_BLOCK_START:
            case ATNState.PLUS_BLOCK_START:
            case ATNState.STAR_LOOP_ENTRY:
                // report error and recover if possible
                if( this.singleTokenDeletion(recognizer) !== null) {
                    return;
                } else {
                    throw new InputMismatchException(recognizer);
                }
            case ATNState.PLUS_LOOP_BACK:
            case ATNState.STAR_LOOP_BACK:
                {
                this.reportUnwantedToken(recognizer);
                const expecting = new IntervalSet();
                expecting.addSet(recognizer.getExpectedTokens());
                const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
                this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
                }
                break;
            // do nothing if we can't identify the exact kind of ATN state
        }
    }

    /**
     * This is called by {@link //reportError} when the exception is a
     * {@link NoViableAltException}.
     *
     * @see //reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportNoViableAlternative(recognizer, e) {
        const tokens = recognizer.getTokenStream();
        let input;
        if(tokens !== null) {
            if (e.startToken.type===Token.EOF) {
                input = "<EOF>";
            } else {
                input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
            }
        } else {
            input = "<unknown input>";
        }
        const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }

    /**
     * This is called by {@link //reportError} when the exception is an
     * {@link InputMismatchException}.
     *
     * @see //reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportInputMismatch(recognizer, e) {
        const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) +
            " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }

    /**
     * This is called by {@link //reportError} when the exception is a
     * {@link FailedPredicateException}.
     *
     * @see //reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportFailedPredicate(recognizer, e) {
        const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
        const msg = "rule " + ruleName + " " + e.message;
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }

    /**
     * This method is called to report a syntax error which requires the removal
     * of a token from the input stream. At the time this method is called, the
     * erroneous symbol is current {@code LT(1)} symbol and has not yet been
     * removed from the input stream. When this method returns,
     * {@code recognizer} is in error recovery mode.
     *
     * <p>This method is called when {@link //singleTokenDeletion} identifies
     * single-token deletion as a viable recovery strategy for a mismatched
     * input error.</p>
     *
     * <p>The default implementation simply returns if the handler is already in
     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
     * enter error recovery mode, followed by calling
     * {@link Parser//notifyErrorListeners}.</p>
     *
     * @param recognizer the parser instance
     *
     */
    reportUnwantedToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
            return;
        }
        this.beginErrorCondition(recognizer);
        const t = recognizer.getCurrentToken();
        const tokenName = this.getTokenErrorDisplay(t);
        const expecting = this.getExpectedTokens(recognizer);
        const msg = "extraneous input " + tokenName + " expecting " +
            expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
        recognizer.notifyErrorListeners(msg, t, null);
    }

    /**
     * This method is called to report a syntax error which requires the
     * insertion of a missing token into the input stream. At the time this
     * method is called, the missing token has not yet been inserted. When this
     * method returns, {@code recognizer} is in error recovery mode.
     *
     * <p>This method is called when {@link //singleTokenInsertion} identifies
     * single-token insertion as a viable recovery strategy for a mismatched
     * input error.</p>
     *
     * <p>The default implementation simply returns if the handler is already in
     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
     * enter error recovery mode, followed by calling
     * {@link Parser//notifyErrorListeners}.</p>
     *
     * @param recognizer the parser instance
     */
    reportMissingToken(recognizer) {
        if ( this.inErrorRecoveryMode(recognizer)) {
            return;
        }
        this.beginErrorCondition(recognizer);
        const t = recognizer.getCurrentToken();
        const expecting = this.getExpectedTokens(recognizer);
        const msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +
            " at " + this.getTokenErrorDisplay(t);
        recognizer.notifyErrorListeners(msg, t, null);
    }

    /**
     * <p>The default implementation attempts to recover from the mismatched input
     * by using single token insertion and deletion as described below. If the
     * recovery attempt fails, this method throws an
     * {@link InputMismatchException}.</p>
     *
     * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
     *
     * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
     * right token, however, then assume {@code LA(1)} is some extra spurious
     * token and delete it. Then consume and return the next token (which was
     * the {@code LA(2)} token) as the successful result of the match operation.</p>
     *
     * <p>This recovery strategy is implemented by {@link
        * //singleTokenDeletion}.</p>
     *
     * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
     *
     * <p>If current token (at {@code LA(1)}) is consistent with what could come
     * after the expected {@code LA(1)} token, then assume the token is missing
     * and use the parser's {@link TokenFactory} to create it on the fly. The
     * "insertion" is performed by returning the created token as the successful
     * result of the match operation.</p>
     *
     * <p>This recovery strategy is implemented by {@link
        * //singleTokenInsertion}.</p>
     *
     * <p><strong>EXAMPLE</strong></p>
     *
     * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
     * the parser returns from the nested call to {@code expr}, it will have
     * call chain:</p>
     *
     * <pre>
     * stat &rarr; expr &rarr; atom
     * </pre>
     *
     * and it will be trying to match the {@code ')'} at this point in the
     * derivation:
     *
     * <pre>
     * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
     * ^
     * </pre>
     *
     * The attempt to match {@code ')'} will fail when it sees {@code ';'} and
     * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
     * is in the set of tokens that can follow the {@code ')'} token reference
     * in rule {@code atom}. It can assume that you forgot the {@code ')'}.
     */
    recoverInline(recognizer) {
        // SINGLE TOKEN DELETION
        const matchedSymbol = this.singleTokenDeletion(recognizer);
        if (matchedSymbol !== null) {
            // we have deleted the extra token.
            // now, move past ttype token as if all were ok
            recognizer.consume();
            return matchedSymbol;
        }
        // SINGLE TOKEN INSERTION
        if (this.singleTokenInsertion(recognizer)) {
            return this.getMissingSymbol(recognizer);
        }
        // even that didn't work; must throw the exception
        throw new InputMismatchException(recognizer);
    }

    /**
     * This method implements the single-token insertion inline error recovery
     * strategy. It is called by {@link //recoverInline} if the single-token
     * deletion strategy fails to recover from the mismatched input. If this
     * method returns {@code true}, {@code recognizer} will be in error recovery
     * mode.
     *
     * <p>This method determines whether or not single-token insertion is viable by
     * checking if the {@code LA(1)} input symbol could be successfully matched
     * if it were instead the {@code LA(2)} symbol. If this method returns
     * {@code true}, the caller is responsible for creating and inserting a
     * token with the correct type to produce this behavior.</p>
     *
     * @param recognizer the parser instance
     * @return {@code true} if single-token insertion is a viable recovery
     * strategy for the current mismatched input, otherwise {@code false}
     */
    singleTokenInsertion(recognizer) {
        const currentSymbolType = recognizer.getTokenStream().LA(1);
        // if current token is consistent with what could come after current
        // ATN state, then we know we're missing a token; error recovery
        // is free to conjure up and insert the missing token
        const atn = recognizer._interp.atn;
        const currentState = atn.states[recognizer.state];
        const next = currentState.transitions[0].target;
        const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);
        if (expectingAtLL2.contains(currentSymbolType) ){
            this.reportMissingToken(recognizer);
            return true;
        } else {
            return false;
        }
    }

    /**
     * This method implements the single-token deletion inline error recovery
     * strategy. It is called by {@link //recoverInline} to attempt to recover
     * from mismatched input. If this method returns null, the parser and error
     * handler state will not have changed. If this method returns non-null,
     * {@code recognizer} will <em>not</em> be in error recovery mode since the
     * returned token was a successful match.
     *
     * <p>If the single-token deletion is successful, this method calls
     * {@link //reportUnwantedToken} to report the error, followed by
     * {@link Parser//consume} to actually "delete" the extraneous token. Then,
     * before returning {@link //reportMatch} is called to signal a successful
     * match.</p>
     *
     * @param recognizer the parser instance
     * @return the successfully matched {@link Token} instance if single-token
     * deletion successfully recovers from the mismatched input, otherwise
     * {@code null}
     */
    singleTokenDeletion(recognizer) {
        const nextTokenType = recognizer.getTokenStream().LA(2);
        const expecting = this.getExpectedTokens(recognizer);
        if (expecting.contains(nextTokenType)) {
            this.reportUnwantedToken(recognizer);
            // print("recoverFromMismatchedToken deleting " \
            // + str(recognizer.getTokenStream().LT(1)) \
            // + " since " + str(recognizer.getTokenStream().LT(2)) \
            // + " is what we want", file=sys.stderr)
            recognizer.consume(); // simply delete extra token
            // we want to return the token we're actually matching
            const matchedSymbol = recognizer.getCurrentToken();
            this.reportMatch(recognizer); // we know current token is correct
            return matchedSymbol;
        } else {
            return null;
        }
    }

    /**
     * Conjure up a missing token during error recovery.
     *
     * The recognizer attempts to recover from single missing
     * symbols. But, actions might refer to that missing symbol.
     * For example, x=ID {f($x);}. The action clearly assumes
     * that there has been an identifier matched previously and that
     * $x points at that token. If that token is missing, but
     * the next token in the stream is what we want we assume that
     * this token is missing and we keep going. Because we
     * have to return some token to replace the missing token,
     * we have to conjure one up. This method gives the user control
     * over the tokens returned for missing tokens. Mostly,
     * you will want to create something special for identifier
     * tokens. For literals such as '{' and ',', the default
     * action in the parser or tree parser works. It simply creates
     * a CommonToken of the appropriate type. The text will be the token.
     * If you change what tokens must be created by the lexer,
     * override this method to create the appropriate tokens.
     *
     */
    getMissingSymbol(recognizer) {
        const currentSymbol = recognizer.getCurrentToken();
        const expecting = this.getExpectedTokens(recognizer);
        const expectedTokenType = expecting.first(); // get any element
        let tokenText;
        if (expectedTokenType===Token.EOF) {
            tokenText = "<missing EOF>";
        } else {
            tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
        }
        let current = currentSymbol;
        const lookback = recognizer.getTokenStream().LT(-1);
        if (current.type===Token.EOF && lookback !== null) {
            current = lookback;
        }
        return recognizer.getTokenFactory().create(current.source,
            expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,
            -1, -1, current.line, current.column);
    }

    getExpectedTokens(recognizer) {
        return recognizer.getExpectedTokens();
    }

    /**
     * How should a token be displayed in an error message? The default
     * is to display just the text, but during development you might
     * want to have a lot of information spit out. Override in that case
     * to use t.toString() (which, for CommonToken, dumps everything about
     * the token). This is better than forcing you to override a method in
     * your token objects because you don't have to go modify your lexer
     * so that it creates a new Java type.
     */
    getTokenErrorDisplay(t) {
        if (t === null) {
            return "<no token>";
        }
        let s = t.text;
        if (s === null) {
            if (t.type===Token.EOF) {
                s = "<EOF>";
            } else {
                s = "<" + t.type + ">";
            }
        }
        return this.escapeWSAndQuote(s);
    }

    escapeWSAndQuote(s) {
        s = s.replace(/\n/g,"\\n");
        s = s.replace(/\r/g,"\\r");
        s = s.replace(/\t/g,"\\t");
        return "'" + s + "'";
    }

    /**
     * Compute the error recovery set for the current rule. During
     * rule invocation, the parser pushes the set of tokens that can
     * follow that rule reference on the stack; this amounts to
     * computing FIRST of what follows the rule reference in the
     * enclosing rule. See LinearApproximator.FIRST().
     * This local follow set only includes tokens
     * from within the rule; i.e., the FIRST computation done by
     * ANTLR stops at the end of a rule.
     *
     * EXAMPLE
     *
     * When you find a "no viable alt exception", the input is not
     * consistent with any of the alternatives for rule r. The best
     * thing to do is to consume tokens until you see something that
     * can legally follow a call to r//or* any rule that called r.
     * You don't want the exact set of viable next tokens because the
     * input might just be missing a token--you might consume the
     * rest of the input looking for one of the missing tokens.
     *
     * Consider grammar:
     *
     * a : '[' b ']'
     * | '(' b ')'
     * ;
     * b : c '^' INT ;
     * c : ID
     * | INT
     * ;
     *
     * At each rule invocation, the set of tokens that could follow
     * that rule is pushed on a stack. Here are the various
     * context-sensitive follow sets:
     *
     * FOLLOW(b1_in_a) = FIRST(']') = ']'
     * FOLLOW(b2_in_a) = FIRST(')') = ')'
     * FOLLOW(c_in_b) = FIRST('^') = '^'
     *
     * Upon erroneous input "[]", the call chain is
     *
     * a -> b -> c
     *
     * and, hence, the follow context stack is:
     *
     * depth follow set start of rule execution
     * 0 <EOF> a (from main())
     * 1 ']' b
     * 2 '^' c
     *
     * Notice that ')' is not included, because b would have to have
     * been called from a different context in rule a for ')' to be
     * included.
     *
     * For error recovery, we cannot consider FOLLOW(c)
     * (context-sensitive or otherwise). We need the combined set of
     * all context-sensitive FOLLOW sets--the set of all tokens that
     * could follow any reference in the call chain. We need to
     * resync to one of those tokens. Note that FOLLOW(c)='^' and if
     * we resync'd to that token, we'd consume until EOF. We need to
     * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
     * In this case, for input "[]", LA(1) is ']' and in the set, so we would
     * not consume anything. After printing an error, rule c would
     * return normally. Rule b would not find the required '^' though.
     * At this point, it gets a mismatched token error and throws an
     * exception (since LA(1) is not in the viable following token
     * set). The rule exception handler tries to recover, but finds
     * the same recovery set and doesn't consume anything. Rule b
     * exits normally returning to rule a. Now it finds the ']' (and
     * with the successful match exits errorRecovery mode).
     *
     * So, you can see that the parser walks up the call chain looking
     * for the token that was a member of the recovery set.
     *
     * Errors are not generated in errorRecovery mode.
     *
     * ANTLR's error recovery mechanism is based upon original ideas:
     *
     * "Algorithms + Data Structures = Programs" by Niklaus Wirth
     *
     * and
     *
     * "A note on error recovery in recursive descent parsers":
     * http://portal.acm.org/citation.cfm?id=947902.947905
     *
     * Later, Josef Grosch had some good ideas:
     *
     * "Efficient and Comfortable Error Recovery in Recursive Descent
     * Parsers":
     * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
     *
     * Like Grosch I implement context-sensitive FOLLOW sets that are combined
     * at run-time upon error to avoid overhead during parsing.
     */
    getErrorRecoverySet(recognizer) {
        const atn = recognizer._interp.atn;
        let ctx = recognizer._ctx;
        const recoverSet = new IntervalSet();
        while (ctx !== null && ctx.invokingState>=0) {
            // compute what follows who invoked us
            const invokingState = atn.states[ctx.invokingState];
            const rt = invokingState.transitions[0];
            const follow = atn.nextTokens(rt.followState);
            recoverSet.addSet(follow);
            ctx = ctx.parentCtx;
        }
        recoverSet.removeOne(Token.EPSILON);
        return recoverSet;
    }

// Consume tokens until one matches the given token set.//
    consumeUntil(recognizer, set) {
        let ttype = recognizer.getTokenStream().LA(1);
        while( ttype !== Token.EOF && !set.contains(ttype)) {
            recognizer.consume();
            ttype = recognizer.getTokenStream().LA(1);
        }
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
 * by immediately canceling the parse operation with a
 * {@link ParseCancellationException}. The implementation ensures that the
 * {@link ParserRuleContext//exception} field is set for all parse tree nodes
 * that were not completed prior to encountering the error.
 *
 * <p>
 * This error strategy is useful in the following scenarios.</p>
 *
 * <ul>
 * <li><strong>Two-stage parsing:</strong> This error strategy allows the first
 * stage of two-stage parsing to immediately terminate if an error is
 * encountered, and immediately fall back to the second stage. In addition to
 * avoiding wasted work by attempting to recover from errors here, the empty
 * implementation of {@link BailErrorStrategy//sync} improves the performance of
 * the first stage.</li>
 * <li><strong>Silent validation:</strong> When syntax errors are not being
 * reported or logged, and the parse result is simply ignored if errors occur,
 * the {@link BailErrorStrategy} avoids wasting work on recovering from errors
 * when the result will be ignored either way.</li>
 * </ul>
 *
 * <p>
 * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
 *
 * @see Parser//setErrorHandler(ANTLRErrorStrategy)
 * */
class BailErrorStrategy extends DefaultErrorStrategy {

    constructor() {
        super();
    }

    /**
     * Instead of recovering from exception {@code e}, re-throw it wrapped
     * in a {@link ParseCancellationException} so it is not caught by the
     * rule function catches. Use {@link Exception//getCause()} to get the
     * original {@link RecognitionException}.
     */
    recover(recognizer, e) {
        let context = recognizer._ctx;
        while (context !== null) {
            context.exception = e;
            context = context.parentCtx;
        }
        throw new ParseCancellationException(e);
    }

    /**
     * Make sure we don't attempt to recover inline; if the parser
     * successfully recovers, it won't throw an exception.
     */
    recoverInline(recognizer) {
        this.recover(recognizer, new InputMismatchException(recognizer));
    }

// Make sure we don't attempt to recover from problems in subrules.//
    sync(recognizer) {
        // pass
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var error = {
    RecognitionException, NoViableAltException, LexerNoViableAltException, InputMismatchException, FailedPredicateException,
    DiagnosticErrorListener, BailErrorStrategy, DefaultErrorStrategy, ErrorListener
};

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * If decodeToUnicodeCodePoints is true, the input is treated
 * as a series of Unicode code points.
 *
 * Otherwise, the input is treated as a series of 16-bit UTF-16 code
 * units.
 */
class InputStream {
	constructor(data, decodeToUnicodeCodePoints) {
		this.name = "<empty>";
		this.strdata = data;
		this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
		// _loadString - Vacuum all input from a string and then treat it like a buffer.
		this._index = 0;
		this.data = [];
		if (this.decodeToUnicodeCodePoints) {
			for (let i = 0; i < this.strdata.length; ) {
				const codePoint = this.strdata.codePointAt(i);
				this.data.push(codePoint);
				i += codePoint <= 0xFFFF ? 1 : 2;
			}
		} else {
			this.data = new Array(this.strdata.length);
			for (let i = 0; i < this.strdata.length; i++) {
				const codeUnit = this.strdata.charCodeAt(i);
				this.data[i] = codeUnit;
			}
		}
		this._size = this.data.length;
	}

	/**
	 * Reset the stream so that it's in the same state it was
	 * when the object was created *except* the data array is not
	 * touched.
	 */
	reset() {
		this._index = 0;
	}

	consume() {
		if (this._index >= this._size) {
			// assert this.LA(1) == Token.EOF
			throw ("cannot consume EOF");
		}
		this._index += 1;
	}

	LA(offset) {
		if (offset === 0) {
			return 0; // undefined
		}
		if (offset < 0) {
			offset += 1; // e.g., translate LA(-1) to use offset=0
		}
		const pos = this._index + offset - 1;
		if (pos < 0 || pos >= this._size) { // invalid
			return Token.EOF;
		}
		return this.data[pos];
	}

	LT(offset) {
		return this.LA(offset);
	}

// mark/release do nothing; we have entire buffer
	mark() {
		return -1;
	}

	release(marker) {
	}

	/**
	 * consume() ahead until p==_index; can't just set p=_index as we must
	 * update line and column. If we seek backwards, just set p
	 */
	seek(_index) {
		if (_index <= this._index) {
			this._index = _index; // just jump; don't update stream state (line,
									// ...)
			return;
		}
		// seek forward
		this._index = Math.min(_index, this._size);
	}

	getText(start, stop) {
		if (stop >= this._size) {
			stop = this._size - 1;
		}
		if (start >= this._size) {
			return "";
		} else {
			if (this.decodeToUnicodeCodePoints) {
				let result = "";
				for (let i = start; i <= stop; i++) {
					result += String.fromCodePoint(this.data[i]);
				}
				return result;
			} else {
				return this.strdata.slice(start, stop + 1);
			}
		}
	}

	toString() {
		return this.strdata;
	}

	get index(){
		return this._index;
	}

	get size(){
		return this._size;
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Utility functions to create InputStreams from various sources.
 *
 * All returned InputStreams support the full range of Unicode
 * up to U+10FFFF (the default behavior of InputStream only supports
 * code points up to U+FFFF).
 */
var CharStreams = {
  // Creates an InputStream from a string.
  fromString: function(str) {
    return new InputStream(str, true);
  },

  /**
   * Asynchronously creates an InputStream from a blob given the
   * encoding of the bytes in that blob (defaults to 'utf8' if
   * encoding is null).
   *
   * Invokes onLoad(result) on success, onError(error) on
   * failure.
   */
  fromBlob: function(blob, encoding, onLoad, onError) {
    const reader = new window.FileReader();
    reader.onload = function(e) {
      const is = new InputStream(e.target.result, true);
      onLoad(is);
    };
    reader.onerror = onError;
    reader.readAsText(blob, encoding);
  },

  /**
   * Creates an InputStream from a Buffer given the
   * encoding of the bytes in that buffer (defaults to 'utf8' if
   * encoding is null).
   */
  fromBuffer: function(buffer, encoding) {
    return new InputStream(buffer.toString(encoding), true);
  },

  /** Asynchronously creates an InputStream from a file on disk given
   * the encoding of the bytes in that file (defaults to 'utf8' if
   * encoding is null).
   *
   * Invokes callback(error, result) on completion.
   */
  fromPath: function(path, encoding, callback) {
    fs__default["default"].readFile(path, encoding, function(err, data) {
      let is = null;
      if (data !== null) {
        is = new InputStream(data, true);
      }
      callback(err, is);
    });
  },

  /**
   * Synchronously creates an InputStream given a path to a file
   * on disk and the encoding of the bytes in that file (defaults to
   * 'utf8' if encoding is null).
   */
  fromPathSync: function(path, encoding) {
    const data = fs__default["default"].readFileSync(path, encoding);
    return new InputStream(data, true);
  }
};

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * This is an InputStream that is loaded from a file all at once
 * when you construct the object.
 */
class FileStream extends InputStream {
	constructor(fileName, decodeToUnicodeCodePoints) {
		const data = fs__default["default"].readFileSync(fileName, "utf8");
		super(data, decodeToUnicodeCodePoints);
		this.fileName = fileName;
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
// this is just to keep meaningful parameter types to Parser
class TokenStream {}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * This implementation of {@link TokenStream} loads tokens from a
 * {@link TokenSource} on-demand, and places the tokens in a buffer to provide
 * access to any previous token by index.
 *
 * <p>
 * This token stream ignores the value of {@link Token//getChannel}. If your
 * parser requires the token stream filter tokens to only those on a particular
 * channel, such as {@link Token//DEFAULT_CHANNEL} or
 * {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a
 * {@link CommonTokenStream}.</p>
 */
class BufferedTokenStream extends TokenStream {
	constructor(tokenSource) {

		super();
		// The {@link TokenSource} from which tokens for this stream are fetched.
		this.tokenSource = tokenSource;
		/**
		 * A collection of all tokens fetched from the token source. The list is
		 * considered a complete view of the input once {@link //fetchedEOF} is set
		 * to {@code true}.
		 */
		this.tokens = [];

		/**
		 * The index into {@link //tokens} of the current token (next token to
		 * {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should
		 * be
		 * {@link //LT LT(1)}.
		 *
		 * <p>This field is set to -1 when the stream is first constructed or when
		 * {@link //setTokenSource} is called, indicating that the first token has
		 * not yet been fetched from the token source. For additional information,
		 * see the documentation of {@link IntStream} for a description of
		 * Initializing Methods.</p>
		 */
		this.index = -1;

		/**
		 * Indicates whether the {@link Token//EOF} token has been fetched from
		 * {@link //tokenSource} and added to {@link //tokens}. This field improves
		 * performance for the following cases:
		 *
		 * <ul>
		 * <li>{@link //consume}: The lookahead check in {@link //consume} to
		 * prevent
		 * consuming the EOF symbol is optimized by checking the values of
		 * {@link //fetchedEOF} and {@link //p} instead of calling {@link
		 * //LA}.</li>
		 * <li>{@link //fetch}: The check to prevent adding multiple EOF symbols
		 * into
		 * {@link //tokens} is trivial with this field.</li>
		 * <ul>
		 */
		this.fetchedEOF = false;
	}

	mark() {
		return 0;
	}

	release(marker) {
		// no resources to release
	}

	reset() {
		this.seek(0);
	}

	seek(index) {
		this.lazyInit();
		this.index = this.adjustSeekIndex(index);
	}

	get(index) {
		this.lazyInit();
		return this.tokens[index];
	}

	consume() {
		let skipEofCheck = false;
		if (this.index >= 0) {
			if (this.fetchedEOF) {
				// the last token in tokens is EOF. skip check if p indexes any
				// fetched token except the last.
				skipEofCheck = this.index < this.tokens.length - 1;
			} else {
				// no EOF token in tokens. skip check if p indexes a fetched token.
				skipEofCheck = this.index < this.tokens.length;
			}
		} else {
			// not yet initialized
			skipEofCheck = false;
		}
		if (!skipEofCheck && this.LA(1) === Token.EOF) {
			throw "cannot consume EOF";
		}
		if (this.sync(this.index + 1)) {
			this.index = this.adjustSeekIndex(this.index + 1);
		}
	}

	/**
	 * Make sure index {@code i} in tokens has a token.
	 *
	 * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise
	 * {@code false}.
	 * @see //get(int i)
	 */
	sync(i) {
		const n = i - this.tokens.length + 1; // how many more elements we need?
		if (n > 0) {
			const fetched = this.fetch(n);
			return fetched >= n;
		}
		return true;
	}

	/**
	 * Add {@code n} elements to buffer.
	 *
	 * @return {Number} The actual number of elements added to the buffer.
	 */
	fetch(n) {
		if (this.fetchedEOF) {
			return 0;
		}
		for (let i = 0; i < n; i++) {
			const t = this.tokenSource.nextToken();
			t.tokenIndex = this.tokens.length;
			this.tokens.push(t);
			if (t.type === Token.EOF) {
				this.fetchedEOF = true;
				return i + 1;
			}
		}
		return n;
	}

// Get all tokens from start..stop inclusively///
	getTokens(start, stop, types) {
		if (types === undefined) {
			types = null;
		}
		if (start < 0 || stop < 0) {
			return null;
		}
		this.lazyInit();
		const subset = [];
		if (stop >= this.tokens.length) {
			stop = this.tokens.length - 1;
		}
		for (let i = start; i < stop; i++) {
			const t = this.tokens[i];
			if (t.type === Token.EOF) {
				break;
			}
			if (types === null || types.contains(t.type)) {
				subset.push(t);
			}
		}
		return subset;
	}

	LA(i) {
		return this.LT(i).type;
	}

	LB(k) {
		if (this.index - k < 0) {
			return null;
		}
		return this.tokens[this.index - k];
	}

	LT(k) {
		this.lazyInit();
		if (k === 0) {
			return null;
		}
		if (k < 0) {
			return this.LB(-k);
		}
		const i = this.index + k - 1;
		this.sync(i);
		if (i >= this.tokens.length) { // return EOF token
			// EOF must be last token
			return this.tokens[this.tokens.length - 1];
		}
		return this.tokens[i];
	}

	/**
	 * Allowed derived classes to modify the behavior of operations which change
	 * the current stream position by adjusting the target token index of a seek
	 * operation. The default implementation simply returns {@code i}. If an
	 * exception is thrown in this method, the current stream index should not be
	 * changed.
	 *
	 * <p>For example, {@link CommonTokenStream} overrides this method to ensure
	 * that
	 * the seek target is always an on-channel token.</p>
	 *
	 * @param {Number} i The target token index.
	 * @return {Number} The adjusted target token index.
	 */
	adjustSeekIndex(i) {
		return i;
	}

	lazyInit() {
		if (this.index === -1) {
			this.setup();
		}
	}

	setup() {
		this.sync(0);
		this.index = this.adjustSeekIndex(0);
	}

// Reset this token stream by setting its token source.///
	setTokenSource(tokenSource) {
		this.tokenSource = tokenSource;
		this.tokens = [];
		this.index = -1;
		this.fetchedEOF = false;
	}

	/**
	 * Given a starting index, return the index of the next token on channel.
	 * Return i if tokens[i] is on channel. Return -1 if there are no tokens
	 * on channel between i and EOF.
	 */
	nextTokenOnChannel(i, channel) {
		this.sync(i);
		if (i >= this.tokens.length) {
			return -1;
		}
		let token = this.tokens[i];
		while (token.channel !== this.channel) {
			if (token.type === Token.EOF) {
				return -1;
			}
			i += 1;
			this.sync(i);
			token = this.tokens[i];
		}
		return i;
	}

	/**
	 * Given a starting index, return the index of the previous token on channel.
	 * Return i if tokens[i] is on channel. Return -1 if there are no tokens
	 * on channel between i and 0.
	 */
	previousTokenOnChannel(i, channel) {
		while (i >= 0 && this.tokens[i].channel !== channel) {
			i -= 1;
		}
		return i;
	}

	/**
	 * Collect all tokens on specified channel to the right of
	 * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
	 * EOF. If channel is -1, find any non default channel token.
	 */
	getHiddenTokensToRight(tokenIndex,
			channel) {
		if (channel === undefined) {
			channel = -1;
		}
		this.lazyInit();
		if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
			throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
		}
		const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
		const from_ = tokenIndex + 1;
		// if none onchannel to right, nextOnChannel=-1 so set to = last token
		const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
		return this.filterForChannel(from_, to, channel);
	}

	/**
	 * Collect all tokens on specified channel to the left of
	 * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
	 * If channel is -1, find any non default channel token.
	 */
	getHiddenTokensToLeft(tokenIndex,
			channel) {
		if (channel === undefined) {
			channel = -1;
		}
		this.lazyInit();
		if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
			throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
		}
		const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
		if (prevOnChannel === tokenIndex - 1) {
			return null;
		}
		// if none on channel to left, prevOnChannel=-1 then from=0
		const from_ = prevOnChannel + 1;
		const to = tokenIndex - 1;
		return this.filterForChannel(from_, to, channel);
	}

	filterForChannel(left, right, channel) {
		const hidden = [];
		for (let i = left; i < right + 1; i++) {
			const t = this.tokens[i];
			if (channel === -1) {
				if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
					hidden.push(t);
				}
			} else if (t.channel === channel) {
				hidden.push(t);
			}
		}
		if (hidden.length === 0) {
			return null;
		}
		return hidden;
	}

	getSourceName() {
		return this.tokenSource.getSourceName();
	}

// Get the text of all tokens in this buffer.///
	getText(interval) {
		this.lazyInit();
		this.fill();
		if (interval === undefined || interval === null) {
			interval = new Interval(0, this.tokens.length - 1);
		}
		let start = interval.start;
		if (start instanceof Token) {
			start = start.tokenIndex;
		}
		let stop = interval.stop;
		if (stop instanceof Token) {
			stop = stop.tokenIndex;
		}
		if (start === null || stop === null || start < 0 || stop < 0) {
			return "";
		}
		if (stop >= this.tokens.length) {
			stop = this.tokens.length - 1;
		}
		let s = "";
		for (let i = start; i < stop + 1; i++) {
			const t = this.tokens[i];
			if (t.type === Token.EOF) {
				break;
			}
			s = s + t.text;
		}
		return s;
	}

// Get all tokens from lexer until EOF///
	fill() {
		this.lazyInit();
		while (this.fetch(1000) === 1000) {
			continue;
		}
	}
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * This class extends {@link BufferedTokenStream} with functionality to filter
 * token streams to tokens on a particular channel (tokens where
 * {@link Token//getChannel} returns a particular value).
 *
 * <p>
 * This token stream provides access to all tokens by index or when calling
 * methods like {@link //getText}. The channel filtering is only used for code
 * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and
 * {@link //LB}.</p>
 *
 * <p>
 * By default, tokens are placed on the default channel
 * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the
 * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to
 * call {@link Lexer//setChannel}.
 * </p>
 *
 * <p>
 * Note: lexer rules which use the {@code ->skip} lexer command or call
 * {@link Lexer//skip} do not produce tokens at all, so input text matched by
 * such a rule will not be available as part of the token stream, regardless of
 * channel.</p>
 */
class CommonTokenStream extends BufferedTokenStream {
    constructor(lexer, channel) {
        super(lexer);
        this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;
    }

    adjustSeekIndex(i) {
        return this.nextTokenOnChannel(i, this.channel);
    }

    LB(k) {
        if (k===0 || this.index-k<0) {
            return null;
        }
        let i = this.index;
        let n = 1;
        // find k good tokens looking backwards
        while (n <= k) {
            // skip off-channel tokens
            i = this.previousTokenOnChannel(i - 1, this.channel);
            n += 1;
        }
        if (i < 0) {
            return null;
        }
        return this.tokens[i];
    }

    LT(k) {
        this.lazyInit();
        if (k === 0) {
            return null;
        }
        if (k < 0) {
            return this.LB(-k);
        }
        let i = this.index;
        let n = 1; // we know tokens[pos] is a good one
        // find k good tokens
        while (n < k) {
            // skip off-channel tokens, but make sure to not look past EOF
            if (this.sync(i + 1)) {
                i = this.nextTokenOnChannel(i + 1, this.channel);
            }
            n += 1;
        }
        return this.tokens[i];
    }

    // Count EOF just once.
    getNumberOfOnChannelTokens() {
        let n = 0;
        this.fill();
        for (let i =0; i< this.tokens.length;i++) {
            const t = this.tokens[i];
            if( t.channel===this.channel) {
                n += 1;
            }
            if( t.type===Token.EOF) {
                break;
            }
        }
        return n;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class TraceListener extends ParseTreeListener {
    constructor(parser) {
        super();
        this.parser = parser;
    }

    enterEveryRule(ctx) {
        console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }

    visitTerminal(node) {
        console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
    }

    exitEveryRule(ctx) {
        console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class Parser extends Recognizer {
    /**
     * this is all the parsing support code essentially; most of it is error
     * recovery stuff.
     */
    constructor(input) {
        super();
        // The input stream.
        this._input = null;
        /**
         * The error handling strategy for the parser. The default value is a new
         * instance of {@link DefaultErrorStrategy}.
         */
        this._errHandler = new DefaultErrorStrategy();
        this._precedenceStack = [];
        this._precedenceStack.push(0);
        /**
         * The {@link ParserRuleContext} object for the currently executing rule.
         * this is always non-null during the parsing process.
         */
        this._ctx = null;
        /**
         * Specifies whether or not the parser should construct a parse tree during
         * the parsing process. The default value is {@code true}.
         */
        this.buildParseTrees = true;
        /**
         * When {@link //setTrace}{@code (true)} is called, a reference to the
         * {@link TraceListener} is stored here so it can be easily removed in a
         * later call to {@link //setTrace}{@code (false)}. The listener itself is
         * implemented as a parser listener so this field is not directly used by
         * other parser methods.
         */
        this._tracer = null;
        /**
         * The list of {@link ParseTreeListener} listeners registered to receive
         * events during the parse.
         */
        this._parseListeners = null;
        /**
         * The number of syntax errors reported during parsing. this value is
         * incremented each time {@link //notifyErrorListeners} is called.
         */
        this._syntaxErrors = 0;
        this.setInputStream(input);
    }

    // reset the parser's state
    reset() {
        if (this._input !== null) {
            this._input.seek(0);
        }
        this._errHandler.reset(this);
        this._ctx = null;
        this._syntaxErrors = 0;
        this.setTrace(false);
        this._precedenceStack = [];
        this._precedenceStack.push(0);
        if (this._interp !== null) {
            this._interp.reset();
        }
    }

    /**
     * Match current input symbol against {@code ttype}. If the symbol type
     * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
     * called to complete the match process.
     *
     * <p>If the symbol type does not match,
     * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
     * strategy to attempt recovery. If {@link //getBuildParseTree} is
     * {@code true} and the token index of the symbol returned by
     * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
     * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
     *
     * @param ttype the token type to match
     * @return the matched symbol
     * @throws RecognitionException if the current input symbol did not match
     * {@code ttype} and the error strategy could not recover from the
     * mismatched symbol
     */
    match(ttype) {
        let t = this.getCurrentToken();
        if (t.type === ttype) {
            this._errHandler.reportMatch(this);
            this.consume();
        } else {
            t = this._errHandler.recoverInline(this);
            if (this.buildParseTrees && t.tokenIndex === -1) {
                // we must have conjured up a new token during single token
                // insertion
                // if it's not the current symbol
                this._ctx.addErrorNode(t);
            }
        }
        return t;
    }

    /**
     * Match current input symbol as a wildcard. If the symbol type matches
     * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
     * and {@link //consume} are called to complete the match process.
     *
     * <p>If the symbol type does not match,
     * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
     * strategy to attempt recovery. If {@link //getBuildParseTree} is
     * {@code true} and the token index of the symbol returned by
     * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
     * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
     *
     * @return the matched symbol
     * @throws RecognitionException if the current input symbol did not match
     * a wildcard and the error strategy could not recover from the mismatched
     * symbol
     */
    matchWildcard() {
        let t = this.getCurrentToken();
        if (t.type > 0) {
            this._errHandler.reportMatch(this);
            this.consume();
        } else {
            t = this._errHandler.recoverInline(this);
            if (this._buildParseTrees && t.tokenIndex === -1) {
                // we must have conjured up a new token during single token
                // insertion
                // if it's not the current symbol
                this._ctx.addErrorNode(t);
            }
        }
        return t;
    }

    getParseListeners() {
        return this._parseListeners || [];
    }

    /**
     * Registers {@code listener} to receive events during the parsing process.
     *
     * <p>To support output-preserving grammar transformations (including but not
     * limited to left-recursion removal, automated left-factoring, and
     * optimized code generation), calls to listener methods during the parse
     * may differ substantially from calls made by
     * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
     * particular, rule entry and exit events may occur in a different order
     * during the parse than after the parser. In addition, calls to certain
     * rule entry methods may be omitted.</p>
     *
     * <p>With the following specific exceptions, calls to listener events are
     * <em>deterministic</em>, i.e. for identical input the calls to listener
     * methods will be the same.</p>
     *
     * <ul>
     * <li>Alterations to the grammar used to generate code may change the
     * behavior of the listener calls.</li>
     * <li>Alterations to the command line options passed to ANTLR 4 when
     * generating the parser may change the behavior of the listener calls.</li>
     * <li>Changing the version of the ANTLR Tool used to generate the parser
     * may change the behavior of the listener calls.</li>
     * </ul>
     *
     * @param listener the listener to add
     *
     * @throws NullPointerException if {@code} listener is {@code null}
     */
    addParseListener(listener) {
        if (listener === null) {
            throw "listener";
        }
        if (this._parseListeners === null) {
            this._parseListeners = [];
        }
        this._parseListeners.push(listener);
    }

    /**
     * Remove {@code listener} from the list of parse listeners.
     *
     * <p>If {@code listener} is {@code null} or has not been added as a parse
     * listener, this method does nothing.</p>
     * @param listener the listener to remove
     */
    removeParseListener(listener) {
        if (this._parseListeners !== null) {
            const idx = this._parseListeners.indexOf(listener);
            if (idx >= 0) {
                this._parseListeners.splice(idx, 1);
            }
            if (this._parseListeners.length === 0) {
                this._parseListeners = null;
            }
        }
    }

    // Remove all parse listeners.
    removeParseListeners() {
        this._parseListeners = null;
    }

    // Notify any parse listeners of an enter rule event.
    triggerEnterRuleEvent() {
        if (this._parseListeners !== null) {
            const ctx = this._ctx;
            this._parseListeners.forEach(function (listener) {
                listener.enterEveryRule(ctx);
                ctx.enterRule(listener);
            });
        }
    }

    /**
     * Notify any parse listeners of an exit rule event.
     * @see //addParseListener
     */
    triggerExitRuleEvent() {
        if (this._parseListeners !== null) {
            // reverse order walk of listeners
            const ctx = this._ctx;
            this._parseListeners.slice(0).reverse().forEach(function (listener) {
                ctx.exitRule(listener);
                listener.exitEveryRule(ctx);
            });
        }
    }

    getTokenFactory() {
        return this._input.tokenSource._factory;
    }

    // Tell our token source and error strategy about a new way to create tokens.
    setTokenFactory(factory) {
        this._input.tokenSource._factory = factory;
    }

    /**
     * The ATN with bypass alternatives is expensive to create so we create it
     * lazily.
     *
     * @throws UnsupportedOperationException if the current parser does not
     * implement the {@link //getSerializedATN()} method.
     */
    getATNWithBypassAlts() {
        const serializedAtn = this.getSerializedATN();
        if (serializedAtn === null) {
            throw "The current parser does not support an ATN with bypass alternatives.";
        }
        let result = this.bypassAltsAtnCache[serializedAtn];
        if (result === null) {
            const deserializationOptions = new ATNDeserializationOptions();
            deserializationOptions.generateRuleBypassTransitions = true;
            result = new ATNDeserializer(deserializationOptions)
                .deserialize(serializedAtn);
            this.bypassAltsAtnCache[serializedAtn] = result;
        }
        return result;
    }

    getInputStream() {
        return this.getTokenStream();
    }

    setInputStream(input) {
        this.setTokenStream(input);
    }

    getTokenStream() {
        return this._input;
    }

    // Set the token stream and reset the parser.
    setTokenStream(input) {
        this._input = null;
        this.reset();
        this._input = input;
    }

    /**
     * Match needs to return the current input symbol, which gets put
     * into the label for the associated token ref; e.g., x=ID.
     */
    getCurrentToken() {
        return this._input.LT(1);
    }

    notifyErrorListeners(msg, offendingToken, err) {
        offendingToken = offendingToken || null;
        err = err || null;
        if (offendingToken === null) {
            offendingToken = this.getCurrentToken();
        }
        this._syntaxErrors += 1;
        const line = offendingToken.line;
        const column = offendingToken.column;
        const listener = this.getErrorListenerDispatch();
        listener.syntaxError(this, offendingToken, line, column, msg, err);
    }

    /**
     * Consume and return the {@linkplain //getCurrentToken current symbol}.
     *
     * <p>E.g., given the following input with {@code A} being the current
     * lookahead symbol, this function moves the cursor to {@code B} and returns
     * {@code A}.</p>
     *
     * <pre>
     * A B
     * ^
     * </pre>
     *
     * If the parser is not in error recovery mode, the consumed symbol is added
     * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
     * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
     * If the parser <em>is</em> in error recovery mode, the consumed symbol is
     * added to the parse tree using
     * {@link ParserRuleContext//addErrorNode(Token)}, and
     * {@link ParseTreeListener//visitErrorNode} is called on any parse
     * listeners.
     */
    consume() {
        const o = this.getCurrentToken();
        if (o.type !== Token.EOF) {
            this.getInputStream().consume();
        }
        const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
        if (this.buildParseTrees || hasListener) {
            let node;
            if (this._errHandler.inErrorRecoveryMode(this)) {
                node = this._ctx.addErrorNode(o);
            } else {
                node = this._ctx.addTokenNode(o);
            }
            node.invokingState = this.state;
            if (hasListener) {
                this._parseListeners.forEach(function (listener) {
                    if (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {
                        listener.visitErrorNode(node);
                    } else if (node instanceof TerminalNode) {
                        listener.visitTerminal(node);
                    }
                });
            }
        }
        return o;
    }

    addContextToParseTree() {
        // add current context to parent if we have a parent
        if (this._ctx.parentCtx !== null) {
            this._ctx.parentCtx.addChild(this._ctx);
        }
    }

    /**
     * Always called by generated parsers upon entry to a rule. Access field
     * {@link //_ctx} get the current context.
     */
    enterRule(localctx, state, ruleIndex) {
        this.state = state;
        this._ctx = localctx;
        this._ctx.start = this._input.LT(1);
        if (this.buildParseTrees) {
            this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
    }

    exitRule() {
        this._ctx.stop = this._input.LT(-1);
        // trigger event on _ctx, before it reverts to parent
        this.triggerExitRuleEvent();
        this.state = this._ctx.invokingState;
        this._ctx = this._ctx.parentCtx;
    }

    enterOuterAlt(localctx, altNum) {
        localctx.setAltNumber(altNum);
        // if we have new localctx, make sure we replace existing ctx
        // that is previous child of parse tree
        if (this.buildParseTrees && this._ctx !== localctx) {
            if (this._ctx.parentCtx !== null) {
                this._ctx.parentCtx.removeLastChild();
                this._ctx.parentCtx.addChild(localctx);
            }
        }
        this._ctx = localctx;
    }

    /**
     * Get the precedence level for the top-most precedence rule.
     *
     * @return The precedence level for the top-most precedence rule, or -1 if
     * the parser context is not nested within a precedence rule.
     */
    getPrecedence() {
        if (this._precedenceStack.length === 0) {
            return -1;
        } else {
            return this._precedenceStack[this._precedenceStack.length - 1];
        }
    }

    enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.state = state;
        this._precedenceStack.push(precedence);
        this._ctx = localctx;
        this._ctx.start = this._input.LT(1);
        this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
    }

    // Like {@link //enterRule} but for recursive rules.
    pushNewRecursionContext(localctx, state, ruleIndex) {
        const previous = this._ctx;
        previous.parentCtx = localctx;
        previous.invokingState = state;
        previous.stop = this._input.LT(-1);

        this._ctx = localctx;
        this._ctx.start = previous.start;
        if (this.buildParseTrees) {
            this._ctx.addChild(previous);
        }
        this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
    }

    unrollRecursionContexts(parentCtx) {
        this._precedenceStack.pop();
        this._ctx.stop = this._input.LT(-1);
        const retCtx = this._ctx; // save current ctx (return value)
        // unroll so _ctx is as it was before call to recursive method
        const parseListeners = this.getParseListeners();
        if (parseListeners !== null && parseListeners.length > 0) {
            while (this._ctx !== parentCtx) {
                this.triggerExitRuleEvent();
                this._ctx = this._ctx.parentCtx;
            }
        } else {
            this._ctx = parentCtx;
        }
        // hook into tree
        retCtx.parentCtx = parentCtx;
        if (this.buildParseTrees && parentCtx !== null) {
            // add return ctx into invoking rule's tree
            parentCtx.addChild(retCtx);
        }
    }

    getInvokingContext(ruleIndex) {
        let ctx = this._ctx;
        while (ctx !== null) {
            if (ctx.ruleIndex === ruleIndex) {
                return ctx;
            }
            ctx = ctx.parentCtx;
        }
        return null;
    }

    precpred(localctx, precedence) {
        return precedence >= this._precedenceStack[this._precedenceStack.length - 1];
    }

    inContext(context) {
        // TODO: useful in parser?
        return false;
    }

    /**
     * Checks whether or not {@code symbol} can follow the current state in the
     * ATN. The behavior of this method is equivalent to the following, but is
     * implemented such that the complete context-sensitive follow set does not
     * need to be explicitly constructed.
     *
     * <pre>
     * return getExpectedTokens().contains(symbol);
     * </pre>
     *
     * @param symbol the symbol type to check
     * @return {@code true} if {@code symbol} can follow the current state in
     * the ATN, otherwise {@code false}.
     */
    isExpectedToken(symbol) {
        const atn = this._interp.atn;
        let ctx = this._ctx;
        const s = atn.states[this.state];
        let following = atn.nextTokens(s);
        if (following.contains(symbol)) {
            return true;
        }
        if (!following.contains(Token.EPSILON)) {
            return false;
        }
        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
            const invokingState = atn.states[ctx.invokingState];
            const rt = invokingState.transitions[0];
            following = atn.nextTokens(rt.followState);
            if (following.contains(symbol)) {
                return true;
            }
            ctx = ctx.parentCtx;
        }
        if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Computes the set of input symbols which could follow the current parser
     * state and context, as given by {@link //getState} and {@link //getContext},
     * respectively.
     *
     * @see ATN//getExpectedTokens(int, RuleContext)
     */
    getExpectedTokens() {
        return this._interp.atn.getExpectedTokens(this.state, this._ctx);
    }

    getExpectedTokensWithinCurrentRule() {
        const atn = this._interp.atn;
        const s = atn.states[this.state];
        return atn.nextTokens(s);
    }

    // Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.
    getRuleIndex(ruleName) {
        const ruleIndex = this.getRuleIndexMap()[ruleName];
        if (ruleIndex !== null) {
            return ruleIndex;
        } else {
            return -1;
        }
    }

    /**
     * Return List&lt;String&gt; of the rule names in your parser instance
     * leading up to a call to the current rule. You could override if
     * you want more details such as the file/line info of where
     * in the ATN a rule is invoked.
     *
     * this is very useful for error messages.
     */
    getRuleInvocationStack(p) {
        p = p || null;
        if (p === null) {
            p = this._ctx;
        }
        const stack = [];
        while (p !== null) {
            // compute what follows who invoked us
            const ruleIndex = p.ruleIndex;
            if (ruleIndex < 0) {
                stack.push("n/a");
            } else {
                stack.push(this.ruleNames[ruleIndex]);
            }
            p = p.parentCtx;
        }
        return stack;
    }

    // For debugging and other purposes.
    getDFAStrings() {
        return this._interp.decisionToDFA.toString();
    }

    // For debugging and other purposes.
    dumpDFA() {
        let seenOne = false;
        for (let i = 0; i < this._interp.decisionToDFA.length; i++) {
            const dfa = this._interp.decisionToDFA[i];
            if (dfa.states.length > 0) {
                if (seenOne) {
                    console.log();
                }
                this.printer.println("Decision " + dfa.decision + ":");
                this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
                seenOne = true;
            }
        }
    }

    /*
        "			printer = function() {\r\n" +
        "				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
        "				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
        "			};\r\n" +
        */
    getSourceName() {
        return this._input.sourceName;
    }

    /**
     * During a parse is sometimes useful to listen in on the rule entry and exit
     * events as well as token matches. this is for quick and dirty debugging.
     */
    setTrace(trace) {
        if (!trace) {
            this.removeParseListener(this._tracer);
            this._tracer = null;
        } else {
            if (this._tracer !== null) {
                this.removeParseListener(this._tracer);
            }
            this._tracer = new TraceListener(this);
            this.addParseListener(this._tracer);
        }
    }
}

/**
 * this field maps from the serialized ATN string to the deserialized {@link
    * ATN} with
 * bypass alternatives.
 *
 * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
 */
Parser.bypassAltsAtnCache = {};

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Used to cache {@link PredictionContext} objects. Its used for the shared
 * context cash associated with contexts in DFA states. This cache
 * can be used for both lexers and parsers.
 */
class PredictionContextCache {

    constructor() {
        this.cache = new HashMap();
    }

    /**
     * Add a context to the cache and return it. If the context already exists,
     * return that one instead and do not add a new context to the cache.
     * Protect shared cache from unsafe thread access.
     */
    add(ctx) {
        if (ctx === PredictionContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        const existing = this.cache.get(ctx) || null;
        if (existing !== null) {
            return existing;
        }
        this.cache.set(ctx, ctx);
        return ctx;
    }

    get(ctx) {
        return this.cache.get(ctx) || null;
    }

    get length(){
        return this.cache.length;
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class TerminalNodeImpl extends TerminalNode {
    constructor(symbol) {
        super();
        this.parentCtx = null;
        this.symbol = symbol;
    }

    getChild(i) {
        return null;
    }

    getSymbol() {
        return this.symbol;
    }

    getParent() {
        return this.parentCtx;
    }

    getPayload() {
        return this.symbol;
    }

    getSourceInterval() {
        if (this.symbol === null) {
            return Interval.INVALID_INTERVAL;
        }
        const tokenIndex = this.symbol.tokenIndex;
        return new Interval(tokenIndex, tokenIndex);
    }

    getChildCount() {
        return 0;
    }

    accept(visitor) {
        return visitor.visitTerminal(this);
    }

    getText() {
        return this.symbol.text;
    }

    toString() {
        if (this.symbol.type === Token.EOF) {
            return "<EOF>";
        } else {
            return this.symbol.text;
        }
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ErrorNodeImpl extends TerminalNodeImpl {
    constructor(token) {
        super(token);
    }

    isErrorNode() {
        return true;
    }

    accept(visitor) {
        return visitor.visitErrorNode(this);
    }
}

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * A rule invocation record for parsing.
 *
 *  Contains all of the information about the current rule not stored in the
 *  RuleContext. It handles parse tree children list, Any ATN state
 *  tracing, and the default values available for rule indications:
 *  start, stop, rule index, current alt number, current
 *  ATN state.
 *
 *  Subclasses made for each rule and grammar track the parameters,
 *  return values, locals, and labels specific to that rule. These
 *  are the objects that are returned from rules.
 *
 *  Note text is not an actual field of a rule return value; it is computed
 *  from start and stop using the input stream's toString() method.  I
 *  could add a ctor to this so that we can pass in and store the input
 *  stream, but I'm not sure we want to do that.  It would seem to be undefined
 *  to get the .text property anyway if the rule matches tokens from multiple
 *  input streams.
 *
 *  I do not use getters for fields of objects that are used simply to
 *  group values such as this aggregate.  The getters/setters are there to
 *  satisfy the superclass interface.
 */
class ParserRuleContext extends RuleContext {
	constructor(parent, invokingStateNumber) {
		parent = parent || null;
		invokingStateNumber = invokingStateNumber || null;
		super(parent, invokingStateNumber);
		this.ruleIndex = -1;
		/**
		 * If we are debugging or building a parse tree for a visitor,
		 * we need to track all of the tokens and rule invocations associated
		 * with this rule's context. This is empty for parsing w/o tree constr.
		 * operation because we don't the need to track the details about
		 * how we parse this rule.
		 */
		this.children = null;
		this.start = null;
		this.stop = null;
		/**
		 * The exception that forced this rule to return. If the rule successfully
		 * completed, this is {@code null}.
		 */
		this.exception = null;
	}

	// COPY a ctx (I'm deliberately not using copy constructor)
	copyFrom(ctx) {
		// from RuleContext
		this.parentCtx = ctx.parentCtx;
		this.invokingState = ctx.invokingState;
		this.children = null;
		this.start = ctx.start;
		this.stop = ctx.stop;
		// copy any error nodes to alt label node
		if(ctx.children) {
			this.children = [];
			// reset parent pointer for any error nodes
			ctx.children.map(function(child) {
				if (child instanceof ErrorNodeImpl) {
					this.children.push(child);
					child.parentCtx = this;
				}
			}, this);
		}
	}

	// Double dispatch methods for listeners
	enterRule(listener) {
	}

	exitRule(listener) {
	}

	// Does not set parent link; other add methods do that
	addChild(child) {
		if (this.children === null) {
			this.children = [];
		}
		this.children.push(child);
		return child;
	}

	/** Used by enterOuterAlt to toss out a RuleContext previously added as
	 * we entered a rule. If we have // label, we will need to remove
	 * generic ruleContext object.
	 */
	removeLastChild() {
		if (this.children !== null) {
			this.children.pop();
		}
	}

	addTokenNode(token) {
		const node = new TerminalNodeImpl(token);
		this.addChild(node);
		node.parentCtx = this;
		return node;
	}

	addErrorNode(badToken) {
		const node = new ErrorNodeImpl(badToken);
		this.addChild(node);
		node.parentCtx = this;
		return node;
	}

	getChild(i, type) {
		type = type || null;
		if (this.children === null || i < 0 || i >= this.children.length) {
			return null;
		}
		if (type === null) {
			return this.children[i];
		} else {
			for(let j=0; j<this.children.length; j++) {
				const child = this.children[j];
				if(child instanceof type) {
					if(i===0) {
						return child;
					} else {
						i -= 1;
					}
				}
			}
			return null;
		}
	}

	getToken(ttype, i) {
		if (this.children === null || i < 0 || i >= this.children.length) {
			return null;
		}
		for(let j=0; j<this.children.length; j++) {
			const child = this.children[j];
			if (child instanceof TerminalNode) {
				if (child.symbol.type === ttype) {
					if(i===0) {
						return child;
					} else {
						i -= 1;
					}
				}
			}
		}
		return null;
	}

	getTokens(ttype ) {
		if (this.children=== null) {
			return [];
		} else {
			const tokens = [];
			for(let j=0; j<this.children.length; j++) {
				const child = this.children[j];
				if (child instanceof TerminalNode) {
					if (child.symbol.type === ttype) {
						tokens.push(child);
					}
				}
			}
			return tokens;
		}
	}

	getTypedRuleContext(ctxType, i) {
		return this.getChild(i, ctxType);
	}

	getTypedRuleContexts(ctxType) {
		if (this.children=== null) {
			return [];
		} else {
			const contexts = [];
			for(let j=0; j<this.children.length; j++) {
				const child = this.children[j];
				if (child instanceof ctxType) {
					contexts.push(child);
				}
			}
			return contexts;
		}
	}

	getChildCount() {
		if (this.children=== null) {
			return 0;
		} else {
			return this.children.length;
		}
	}

	getSourceInterval() {
		if( this.start === null || this.stop === null) {
			return Interval.INVALID_INTERVAL;
		} else {
			return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
		}
	}
}

RuleContext.EMPTY = new ParserRuleContext();

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Utils = { arrayToString };

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const antlr4 = {
    atn, dfa, tree, error, Token, CommonToken, CharStreams, InputStream, FileStream, CommonTokenStream, Lexer, Parser,
    PredictionContextCache, ParserRuleContext, Interval, IntervalSet, LL1Analyzer, Utils
};

var antlr4$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	'default': antlr4
});

var Protobuf3Lexer$1 = {};

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(antlr4$1);

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var serializedATN = ["\x03\u608B\uA72A\u8133\uB9ED\u417C\u3BE7\u7786", "\u5964\x02F\u036E\b\x01\x04\x02\t\x02\x04\x03\t\x03", "\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07", "\t\x07\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\x0B\t\x0B\x04", "\f\t\f\x04\r\t\r\x04\x0E\t\x0E\x04\x0F\t\x0F\x04\x10", "\t\x10\x04\x11\t\x11\x04\x12\t\x12\x04\x13\t\x13", "\x04\x14\t\x14\x04\x15\t\x15\x04\x16\t\x16\x04\x17", "\t\x17\x04\x18\t\x18\x04\x19\t\x19\x04\x1A\t\x1A", "\x04\x1B\t\x1B\x04\x1C\t\x1C\x04\x1D\t\x1D\x04\x1E", "\t\x1E\x04\x1F\t\x1F\x04 \t \x04!\t!\x04\"\t\"\x04#", "\t#\x04$\t$\x04%\t%\x04&\t&\x04'\t'\x04(\t(\x04)\t)\x04", "*\t*\x04+\t+\x04,\t,\x04-\t-\x04.\t.\x04/\t/\x040\t0\x04", "1\t1\x042\t2\x043\t3\x044\t4\x045\t5\x046\t6\x047\t7\x04", "8\t8\x049\t9\x04:\t:\x04;\t;\x04<\t<\x04=\t=\x04>\t>\x04", "?\t?\x04@\t@\x04A\tA\x04B\tB\x04C\tC\x04D\tD\x04E\tE\x04", "F\tF\x04G\tG\x04H\tH\x04I\tI\x04J\tJ\x04K\tK\x04L\tL\x04", "M\tM\x04N\tN\x04O\tO\x04P\tP\x04Q\tQ\x04R\tR\x03\x02\x03", "\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03", "\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03", "\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03", "\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03", "\x02\x03\x02\x03\x02\x03\x02\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x04\x03\x04\x03\x04\x03\x04\x03", "\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03", "\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03", "\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03", "\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03", "\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x05\x03", "\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03", "\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03", "\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03", "\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03", "\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03", "\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03", "\x05\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03", "\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03", "\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03", "\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03", "\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03", "\x06\x03\x06\x03\x07\x03\x07\x03\x07\x03\x07\x03", "\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03", "\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03", "\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03", "\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03", "\x07\x03\x07\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03", "\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03", "\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03", "\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\t\x03\t\x03", "\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03", "\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03", "\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\n\x03", "\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03", "\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03", "\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03", "\n\x03\x0B\x03\x0B\x03\x0B\x03\x0B\x03\x0B\x03", "\x0B\x03\x0B\x03\f\x03\f\x03\f\x03\f\x03\f\x03\f\x03", "\f\x03\r\x03\r\x03\r\x03\r\x03\r\x03\r\x03\r\x03\x0E", "\x03\x0E\x03\x0E\x03\x0E\x03\x0E\x03\x0F\x03\x0F", "\x03\x0F\x03\x0F\x03\x0F\x03\x0F\x03\x0F\x03\x10", "\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10", "\x03\x10\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11", "\x03\x11\x03\x11\x03\x12\x03\x12\x03\x12\x03\x12", "\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x13", "\x03\x13\x03\x13\x03\x13\x03\x13\x03\x13\x03\x14", "\x03\x14\x03\x14\x03\x14\x03\x15\x03\x15\x03\x15", "\x03\x15\x03\x15\x03\x15\x03\x16\x03\x16\x03\x16", "\x03\x16\x03\x16\x03\x16\x03\x17\x03\x17\x03\x17", "\x03\x17\x03\x17\x03\x17\x03\x17\x03\x18\x03\x18", "\x03\x18\x03\x18\x03\x18\x03\x18\x03\x18\x03\x19", "\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19", "\x03\x1A\x03\x1A\x03\x1A\x03\x1A\x03\x1A\x03\x1A", "\x03\x1A\x03\x1B\x03\x1B\x03\x1B\x03\x1B\x03\x1B", "\x03\x1B\x03\x1B\x03\x1B\x03\x1C\x03\x1C\x03\x1C", "\x03\x1C\x03\x1C\x03\x1C\x03\x1C\x03\x1C\x03\x1D", "\x03\x1D\x03\x1D\x03\x1D\x03\x1D\x03\x1D\x03\x1D", "\x03\x1D\x03\x1D\x03\x1E\x03\x1E\x03\x1E\x03\x1E", "\x03\x1E\x03\x1E\x03\x1E\x03\x1E\x03\x1E\x03\x1F", "\x03\x1F\x03\x1F\x03\x1F\x03\x1F\x03 \x03 \x03", " \x03 \x03 \x03 \x03 \x03!\x03!\x03!\x03!\x03!\x03", "!\x03!\x03\"\x03\"\x03\"\x03\"\x03\"\x03\"\x03#\x03", "#\x03#\x03#\x03#\x03#\x03$\x03$\x03$\x03$\x03$\x03", "$\x03$\x03$\x03$\x03%\x03%\x03%\x03&\x03&\x03&\x03", "&\x03'\x03'\x03'\x03'\x03'\x03(\x03(\x03(\x03", "(\x03(\x03(\x03(\x03(\x03)\x03)\x03)\x03)\x03)\x03", ")\x03)\x03)\x03*\x03*\x03*\x03*\x03+\x03+\x03+\x03", "+\x03+\x03+\x03+\x03,\x03,\x03,\x03,\x03,\x03,\x03", ",\x03,\x03-\x03-\x03-\x03-\x03-\x03-\x03-\x03-\x03", "-\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03", "/\x03/\x030\x030\x031\x031\x032\x032\x033\x033\x03", "4\x034\x035\x035\x036\x036\x037\x037\x038\x038\x03", "9\x039\x03:\x03:\x03;\x03;\x03<\x03<\x03=\x03=\x03", ">\x03>\x07>\u02D1\n>\f>\x0E>\u02D4\x0B>\x03>\x03>\x03", ">\x07>\u02D9\n>\f>\x0E>\u02DC\x0B>\x03>\x05>\u02DF\n>\x03", "?\x03?\x03?\x03?\x05?\u02E5\n?\x03@\x03@\x03@\x03@\x03", "@\x03A\x03A\x03A\x03A\x03A\x03B\x03B\x03B\x03C\x03", "C\x03C\x03C\x03C\x03C\x03C\x03C\x03C\x05C\u02FD\nC\x03", "D\x03D\x03D\x05D\u0302\nD\x03D\x05D\u0305\nD\x03D\x03", "D\x03D\x03D\x03D\x03D\x05D\u030D\nD\x05D\u030F\nD\x03", "D\x03D\x03D\x03D\x03D\x03D\x05D\u0317\nD\x03E\x03E\x03", "E\x05E\u031C\nE\x03E\x03E\x03F\x06F\u0321\nF\rF\x0EF\u0322", "\x03G\x03G\x03G\x05G\u0328\nG\x03H\x03H\x07H\u032C\nH", "\fH\x0EH\u032F\x0BH\x03I\x03I\x07I\u0333\nI\fI\x0EI\u0336", "\x0BI\x03J\x03J\x03J\x06J\u033B\nJ\rJ\x0EJ\u033C\x03K", "\x03K\x03K\x07K\u0342\nK\fK\x0EK\u0345\x0BK\x03L\x03L", "\x03M\x03M\x03N\x03N\x03O\x03O\x03P\x06P\u0350\nP\r", "P\x0EP\u0351\x03P\x03P\x03Q\x03Q\x03Q\x03Q\x07Q\u035A", "\nQ\fQ\x0EQ\u035D\x0BQ\x03Q\x03Q\x03R\x03R\x03R\x03", "R\x07R\u0365\nR\fR\x0ER\u0368\x0BR\x03R\x03R\x03R\x03", "R\x03R\x05\u02D2\u02DA\u0366\x02S\x03\x03\x05\x04\x07", "\x05\t\x06\x0B\x07\r\b\x0F\t\x11\n\x13\x0B\x15\f\x17", "\r\x19\x0E\x1B\x0F\x1D\x10\x1F\x11!\x12#\x13%\x14", "'\x15)\x16+\x17-\x18/\x191\x1A3\x1B5\x1C7\x1D9\x1E", ";\x1F= ?!A\"C#E$G%I&K'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s;u<", "w=y>{?}\x02\x7F\x02\x81\x02\x83\x02\x85@\x87A\x89", "\x02\x8B\x02\x8DB\x8F\x02\x91\x02\x93\x02\x95", "C\x97\x02\x99\x02\x9B\x02\x9D\x02\x9FD\xA1E\xA3", "F\x03\x02\r\x05\x02\x02\x02\f\f^^\x04\x02ZZzz\x0B", "\x02$$))^^cdhhppttvvxx\x04\x02GGgg\x03\x023;\x05\x02C", "\\aac|\x03\x022;\x03\x0229\x05\x022;CHch\x05\x02\x0B", "\f\x0E\x0F\"\"\x04\x02\f\f\x0F\x0F\x02\u037B\x02\x03", "\x03\x02\x02\x02\x02\x05\x03\x02\x02\x02\x02\x07", "\x03\x02\x02\x02\x02\t\x03\x02\x02\x02\x02\x0B", "\x03\x02\x02\x02\x02\r\x03\x02\x02\x02\x02\x0F", "\x03\x02\x02\x02\x02\x11\x03\x02\x02\x02\x02\x13", "\x03\x02\x02\x02\x02\x15\x03\x02\x02\x02\x02\x17", "\x03\x02\x02\x02\x02\x19\x03\x02\x02\x02\x02\x1B", "\x03\x02\x02\x02\x02\x1D\x03\x02\x02\x02\x02\x1F", "\x03\x02\x02\x02\x02!\x03\x02\x02\x02\x02#\x03", "\x02\x02\x02\x02%\x03\x02\x02\x02\x02'\x03\x02", "\x02\x02\x02)\x03\x02\x02\x02\x02+\x03\x02\x02", "\x02\x02-\x03\x02\x02\x02\x02/\x03\x02\x02\x02", "\x021\x03\x02\x02\x02\x023\x03\x02\x02\x02\x02", "5\x03\x02\x02\x02\x027\x03\x02\x02\x02\x029\x03", "\x02\x02\x02\x02;\x03\x02\x02\x02\x02=\x03\x02", "\x02\x02\x02?\x03\x02\x02\x02\x02A\x03\x02\x02", "\x02\x02C\x03\x02\x02\x02\x02E\x03\x02\x02\x02", "\x02G\x03\x02\x02\x02\x02I\x03\x02\x02\x02\x02", "K\x03\x02\x02\x02\x02M\x03\x02\x02\x02\x02O\x03", "\x02\x02\x02\x02Q\x03\x02\x02\x02\x02S\x03\x02", "\x02\x02\x02U\x03\x02\x02\x02\x02W\x03\x02\x02", "\x02\x02Y\x03\x02\x02\x02\x02[\x03\x02\x02\x02", "\x02]\x03\x02\x02\x02\x02_\x03\x02\x02\x02\x02", "a\x03\x02\x02\x02\x02c\x03\x02\x02\x02\x02e\x03", "\x02\x02\x02\x02g\x03\x02\x02\x02\x02i\x03\x02", "\x02\x02\x02k\x03\x02\x02\x02\x02m\x03\x02\x02", "\x02\x02o\x03\x02\x02\x02\x02q\x03\x02\x02\x02", "\x02s\x03\x02\x02\x02\x02u\x03\x02\x02\x02\x02", "w\x03\x02\x02\x02\x02y\x03\x02\x02\x02\x02{\x03", "\x02\x02\x02\x02\x85\x03\x02\x02\x02\x02\x87\x03", "\x02\x02\x02\x02\x8D\x03\x02\x02\x02\x02\x95\x03", "\x02\x02\x02\x02\x9F\x03\x02\x02\x02\x02\xA1\x03", "\x02\x02\x02\x02\xA3\x03\x02\x02\x02\x03\xA5\x03", "\x02\x02\x02\x05\xC2\x03\x02\x02\x02\x07\xDE\x03", "\x02\x02\x02\t\xFF\x03\x02\x02\x02\x0B\u0125\x03", "\x02\x02\x02\r\u0144\x03\x02\x02\x02\x0F\u0162\x03", "\x02\x02\x02\x11\u0181\x03\x02\x02\x02\x13\u019D\x03", "\x02\x02\x02\x15\u01BA\x03\x02\x02\x02\x17\u01C1\x03", "\x02\x02\x02\x19\u01C8\x03\x02\x02\x02\x1B\u01CF\x03", "\x02\x02\x02\x1D\u01D4\x03\x02\x02\x02\x1F\u01DB\x03", "\x02\x02\x02!\u01E3\x03\x02\x02\x02#\u01EA\x03\x02", "\x02\x02%\u01F3\x03\x02\x02\x02'\u01F9\x03\x02\x02", "\x02)\u01FD\x03\x02\x02\x02+\u0203\x03\x02\x02\x02", "-\u0209\x03\x02\x02\x02/\u0210\x03\x02\x02\x021\u0217", "\x03\x02\x02\x023\u021E\x03\x02\x02\x025\u0225\x03", "\x02\x02\x027\u022D\x03\x02\x02\x029\u0235\x03\x02", "\x02\x02;\u023E\x03\x02\x02\x02=\u0247\x03\x02\x02", "\x02?\u024C\x03\x02\x02\x02A\u0253\x03\x02\x02\x02", "C\u025A\x03\x02\x02\x02E\u0260\x03\x02\x02\x02G\u0266", "\x03\x02\x02\x02I\u026F\x03\x02\x02\x02K\u0272\x03", "\x02\x02\x02M\u0276\x03\x02\x02\x02O\u027B\x03\x02", "\x02\x02Q\u0283\x03\x02\x02\x02S\u028B\x03\x02\x02", "\x02U\u028F\x03\x02\x02\x02W\u0296\x03\x02\x02\x02", "Y\u029E\x03\x02\x02\x02[\u02A7\x03\x02\x02\x02]\u02B0", "\x03\x02\x02\x02_\u02B2\x03\x02\x02\x02a\u02B4\x03", "\x02\x02\x02c\u02B6\x03\x02\x02\x02e\u02B8\x03\x02", "\x02\x02g\u02BA\x03\x02\x02\x02i\u02BC\x03\x02\x02", "\x02k\u02BE\x03\x02\x02\x02m\u02C0\x03\x02\x02\x02", "o\u02C2\x03\x02\x02\x02q\u02C4\x03\x02\x02\x02s\u02C6", "\x03\x02\x02\x02u\u02C8\x03\x02\x02\x02w\u02CA\x03", "\x02\x02\x02y\u02CC\x03\x02\x02\x02{\u02DE\x03\x02", "\x02\x02}\u02E4\x03\x02\x02\x02\x7F\u02E6\x03\x02", "\x02\x02\x81\u02EB\x03\x02\x02\x02\x83\u02F0\x03\x02", "\x02\x02\x85\u02FC\x03\x02\x02\x02\x87\u0316\x03\x02", "\x02\x02\x89\u0318\x03\x02\x02\x02\x8B\u0320\x03\x02", "\x02\x02\x8D\u0327\x03\x02\x02\x02\x8F\u0329\x03\x02", "\x02\x02\x91\u0330\x03\x02\x02\x02\x93\u0337\x03\x02", "\x02\x02\x95\u033E\x03\x02\x02\x02\x97\u0346\x03\x02", "\x02\x02\x99\u0348\x03\x02\x02\x02\x9B\u034A\x03\x02", "\x02\x02\x9D\u034C\x03\x02\x02\x02\x9F\u034F\x03\x02", "\x02\x02\xA1\u0355\x03\x02\x02\x02\xA3\u0360\x03\x02", "\x02\x02\xA5\xA6\x07i\x02\x02\xA6\xA7\x07q\x02", "\x02\xA7\xA8\x07q\x02\x02\xA8\xA9\x07i\x02\x02", "\xA9\xAA\x07n\x02\x02\xAA\xAB\x07g\x02\x02\xAB", "\xAC\x070\x02\x02\xAC\xAD\x07r\x02\x02\xAD\xAE", "\x07t\x02\x02\xAE\xAF\x07q\x02\x02\xAF\xB0\x07", "v\x02\x02\xB0\xB1\x07q\x02\x02\xB1\xB2\x07d\x02", "\x02\xB2\xB3\x07w\x02\x02\xB3\xB4\x07h\x02\x02", "\xB4\xB5\x070\x02\x02\xB5\xB6\x07H\x02\x02\xB6", "\xB7\x07k\x02\x02\xB7\xB8\x07g\x02\x02\xB8\xB9", "\x07n\x02\x02\xB9\xBA\x07f\x02\x02\xBA\xBB\x07", "Q\x02\x02\xBB\xBC\x07r\x02\x02\xBC\xBD\x07v\x02", "\x02\xBD\xBE\x07k\x02\x02\xBE\xBF\x07q\x02\x02", "\xBF\xC0\x07p\x02\x02\xC0\xC1\x07u\x02\x02\xC1", "\x04\x03\x02\x02\x02\xC2\xC3\x07i\x02\x02\xC3", "\xC4\x07q\x02\x02\xC4\xC5\x07q\x02\x02\xC5\xC6", "\x07i\x02\x02\xC6\xC7\x07n\x02\x02\xC7\xC8\x07", "g\x02\x02\xC8\xC9\x070\x02\x02\xC9\xCA\x07r\x02", "\x02\xCA\xCB\x07t\x02\x02\xCB\xCC\x07q\x02\x02", "\xCC\xCD\x07v\x02\x02\xCD\xCE\x07q\x02\x02\xCE", "\xCF\x07d\x02\x02\xCF\xD0\x07w\x02\x02\xD0\xD1", "\x07h\x02\x02\xD1\xD2\x070\x02\x02\xD2\xD3\x07", "G\x02\x02\xD3\xD4\x07p\x02\x02\xD4\xD5\x07w\x02", "\x02\xD5\xD6\x07o\x02\x02\xD6\xD7\x07Q\x02\x02", "\xD7\xD8\x07r\x02\x02\xD8\xD9\x07v\x02\x02\xD9", "\xDA\x07k\x02\x02\xDA\xDB\x07q\x02\x02\xDB\xDC", "\x07p\x02\x02\xDC\xDD\x07u\x02\x02\xDD\x06\x03", "\x02\x02\x02\xDE\xDF\x07i\x02\x02\xDF\xE0\x07", "q\x02\x02\xE0\xE1\x07q\x02\x02\xE1\xE2\x07i\x02", "\x02\xE2\xE3\x07n\x02\x02\xE3\xE4\x07g\x02\x02", "\xE4\xE5\x070\x02\x02\xE5\xE6\x07r\x02\x02\xE6", "\xE7\x07t\x02\x02\xE7\xE8\x07q\x02\x02\xE8\xE9", "\x07v\x02\x02\xE9\xEA\x07q\x02\x02\xEA\xEB\x07", "d\x02\x02\xEB\xEC\x07w\x02\x02\xEC\xED\x07h\x02", "\x02\xED\xEE\x070\x02\x02\xEE\xEF\x07G\x02\x02", "\xEF\xF0\x07p\x02\x02\xF0\xF1\x07w\x02\x02\xF1", "\xF2\x07o\x02\x02\xF2\xF3\x07X\x02\x02\xF3\xF4", "\x07c\x02\x02\xF4\xF5\x07n\x02\x02\xF5\xF6\x07", "w\x02\x02\xF6\xF7\x07g\x02\x02\xF7\xF8\x07Q\x02", "\x02\xF8\xF9\x07r\x02\x02\xF9\xFA\x07v\x02\x02", "\xFA\xFB\x07k\x02\x02\xFB\xFC\x07q\x02\x02\xFC", "\xFD\x07p\x02\x02\xFD\xFE\x07u\x02\x02\xFE\b\x03", "\x02\x02\x02\xFF\u0100\x07i\x02\x02\u0100\u0101\x07", "q\x02\x02\u0101\u0102\x07q\x02\x02\u0102\u0103\x07i\x02", "\x02\u0103\u0104\x07n\x02\x02\u0104\u0105\x07g\x02\x02", "\u0105\u0106\x070\x02\x02\u0106\u0107\x07r\x02\x02\u0107", "\u0108\x07t\x02\x02\u0108\u0109\x07q\x02\x02\u0109\u010A", "\x07v\x02\x02\u010A\u010B\x07q\x02\x02\u010B\u010C\x07", "d\x02\x02\u010C\u010D\x07w\x02\x02\u010D\u010E\x07h\x02", "\x02\u010E\u010F\x070\x02\x02\u010F\u0110\x07G\x02\x02", "\u0110\u0111\x07z\x02\x02\u0111\u0112\x07v\x02\x02\u0112", "\u0113\x07g\x02\x02\u0113\u0114\x07p\x02\x02\u0114\u0115", "\x07u\x02\x02\u0115\u0116\x07k\x02\x02\u0116\u0117\x07", "q\x02\x02\u0117\u0118\x07p\x02\x02\u0118\u0119\x07T\x02", "\x02\u0119\u011A\x07c\x02\x02\u011A\u011B\x07p\x02\x02", "\u011B\u011C\x07i\x02\x02\u011C\u011D\x07g\x02\x02\u011D", "\u011E\x07Q\x02\x02\u011E\u011F\x07r\x02\x02\u011F\u0120", "\x07v\x02\x02\u0120\u0121\x07k\x02\x02\u0121\u0122\x07", "q\x02\x02\u0122\u0123\x07p\x02\x02\u0123\u0124\x07u\x02", "\x02\u0124\n\x03\x02\x02\x02\u0125\u0126\x07i\x02\x02", "\u0126\u0127\x07q\x02\x02\u0127\u0128\x07q\x02\x02\u0128", "\u0129\x07i\x02\x02\u0129\u012A\x07n\x02\x02\u012A\u012B", "\x07g\x02\x02\u012B\u012C\x070\x02\x02\u012C\u012D\x07", "r\x02\x02\u012D\u012E\x07t\x02\x02\u012E\u012F\x07q\x02", "\x02\u012F\u0130\x07v\x02\x02\u0130\u0131\x07q\x02\x02", "\u0131\u0132\x07d\x02\x02\u0132\u0133\x07w\x02\x02\u0133", "\u0134\x07h\x02\x02\u0134\u0135\x070\x02\x02\u0135\u0136", "\x07O\x02\x02\u0136\u0137\x07g\x02\x02\u0137\u0138\x07", "u\x02\x02\u0138\u0139\x07u\x02\x02\u0139\u013A\x07c\x02", "\x02\u013A\u013B\x07i\x02\x02\u013B\u013C\x07g\x02\x02", "\u013C\u013D\x07Q\x02\x02\u013D\u013E\x07r\x02\x02\u013E", "\u013F\x07v\x02\x02\u013F\u0140\x07k\x02\x02\u0140\u0141", "\x07q\x02\x02\u0141\u0142\x07p\x02\x02\u0142\u0143\x07", "u\x02\x02\u0143\f\x03\x02\x02\x02\u0144\u0145\x07i\x02", "\x02\u0145\u0146\x07q\x02\x02\u0146\u0147\x07q\x02\x02", "\u0147\u0148\x07i\x02\x02\u0148\u0149\x07n\x02\x02\u0149", "\u014A\x07g\x02\x02\u014A\u014B\x070\x02\x02\u014B\u014C", "\x07r\x02\x02\u014C\u014D\x07t\x02\x02\u014D\u014E\x07", "q\x02\x02\u014E\u014F\x07v\x02\x02\u014F\u0150\x07q\x02", "\x02\u0150\u0151\x07d\x02\x02\u0151\u0152\x07w\x02\x02", "\u0152\u0153\x07h\x02\x02\u0153\u0154\x070\x02\x02\u0154", "\u0155\x07O\x02\x02\u0155\u0156\x07g\x02\x02\u0156\u0157", "\x07v\x02\x02\u0157\u0158\x07j\x02\x02\u0158\u0159\x07", "q\x02\x02\u0159\u015A\x07f\x02\x02\u015A\u015B\x07Q\x02", "\x02\u015B\u015C\x07r\x02\x02\u015C\u015D\x07v\x02\x02", "\u015D\u015E\x07k\x02\x02\u015E\u015F\x07q\x02\x02\u015F", "\u0160\x07p\x02\x02\u0160\u0161\x07u\x02\x02\u0161\x0E", "\x03\x02\x02\x02\u0162\u0163\x07i\x02\x02\u0163\u0164", "\x07q\x02\x02\u0164\u0165\x07q\x02\x02\u0165\u0166\x07", "i\x02\x02\u0166\u0167\x07n\x02\x02\u0167\u0168\x07g\x02", "\x02\u0168\u0169\x070\x02\x02\u0169\u016A\x07r\x02\x02", "\u016A\u016B\x07t\x02\x02\u016B\u016C\x07q\x02\x02\u016C", "\u016D\x07v\x02\x02\u016D\u016E\x07q\x02\x02\u016E\u016F", "\x07d\x02\x02\u016F\u0170\x07w\x02\x02\u0170\u0171\x07", "h\x02\x02\u0171\u0172\x070\x02\x02\u0172\u0173\x07U\x02", "\x02\u0173\u0174\x07g\x02\x02\u0174\u0175\x07t\x02\x02", "\u0175\u0176\x07x\x02\x02\u0176\u0177\x07k\x02\x02\u0177", "\u0178\x07e\x02\x02\u0178\u0179\x07g\x02\x02\u0179\u017A", "\x07Q\x02\x02\u017A\u017B\x07r\x02\x02\u017B\u017C\x07", "v\x02\x02\u017C\u017D\x07k\x02\x02\u017D\u017E\x07q\x02", "\x02\u017E\u017F\x07p\x02\x02\u017F\u0180\x07u\x02\x02", "\u0180\x10\x03\x02\x02\x02\u0181\u0182\x07i\x02\x02", "\u0182\u0183\x07q\x02\x02\u0183\u0184\x07q\x02\x02\u0184", "\u0185\x07i\x02\x02\u0185\u0186\x07n\x02\x02\u0186\u0187", "\x07g\x02\x02\u0187\u0188\x070\x02\x02\u0188\u0189\x07", "r\x02\x02\u0189\u018A\x07t\x02\x02\u018A\u018B\x07q\x02", "\x02\u018B\u018C\x07v\x02\x02\u018C\u018D\x07q\x02\x02", "\u018D\u018E\x07d\x02\x02\u018E\u018F\x07w\x02\x02\u018F", "\u0190\x07h\x02\x02\u0190\u0191\x070\x02\x02\u0191\u0192", "\x07H\x02\x02\u0192\u0193\x07k\x02\x02\u0193\u0194\x07", "n\x02\x02\u0194\u0195\x07g\x02\x02\u0195\u0196\x07Q\x02", "\x02\u0196\u0197\x07r\x02\x02\u0197\u0198\x07v\x02\x02", "\u0198\u0199\x07k\x02\x02\u0199\u019A\x07q\x02\x02\u019A", "\u019B\x07p\x02\x02\u019B\u019C\x07u\x02\x02\u019C\x12", "\x03\x02\x02\x02\u019D\u019E\x07i\x02\x02\u019E\u019F", "\x07q\x02\x02\u019F\u01A0\x07q\x02\x02\u01A0\u01A1\x07", "i\x02\x02\u01A1\u01A2\x07n\x02\x02\u01A2\u01A3\x07g\x02", "\x02\u01A3\u01A4\x070\x02\x02\u01A4\u01A5\x07r\x02\x02", "\u01A5\u01A6\x07t\x02\x02\u01A6\u01A7\x07q\x02\x02\u01A7", "\u01A8\x07v\x02\x02\u01A8\u01A9\x07q\x02\x02\u01A9\u01AA", "\x07d\x02\x02\u01AA\u01AB\x07w\x02\x02\u01AB\u01AC\x07", "h\x02\x02\u01AC\u01AD\x070\x02\x02\u01AD\u01AE\x07Q\x02", "\x02\u01AE\u01AF\x07p\x02\x02\u01AF\u01B0\x07g\x02\x02", "\u01B0\u01B1\x07q\x02\x02\u01B1\u01B2\x07h\x02\x02\u01B2", "\u01B3\x07Q\x02\x02\u01B3\u01B4\x07r\x02\x02\u01B4\u01B5", "\x07v\x02\x02\u01B5\u01B6\x07k\x02\x02\u01B6\u01B7\x07", "q\x02\x02\u01B7\u01B8\x07p\x02\x02\u01B8\u01B9\x07u\x02", "\x02\u01B9\x14\x03\x02\x02\x02\u01BA\u01BB\x07u\x02", "\x02\u01BB\u01BC\x07{\x02\x02\u01BC\u01BD\x07p\x02\x02", "\u01BD\u01BE\x07v\x02\x02\u01BE\u01BF\x07c\x02\x02\u01BF", "\u01C0\x07z\x02\x02\u01C0\x16\x03\x02\x02\x02\u01C1", "\u01C2\x07k\x02\x02\u01C2\u01C3\x07o\x02\x02\u01C3\u01C4", "\x07r\x02\x02\u01C4\u01C5\x07q\x02\x02\u01C5\u01C6\x07", "t\x02\x02\u01C6\u01C7\x07v\x02\x02\u01C7\x18\x03\x02", "\x02\x02\u01C8\u01C9\x07g\x02\x02\u01C9\u01CA\x07z\x02", "\x02\u01CA\u01CB\x07v\x02\x02\u01CB\u01CC\x07g\x02\x02", "\u01CC\u01CD\x07p\x02\x02\u01CD\u01CE\x07f\x02\x02\u01CE", "\x1A\x03\x02\x02\x02\u01CF\u01D0\x07y\x02\x02\u01D0", "\u01D1\x07g\x02\x02\u01D1\u01D2\x07c\x02\x02\u01D2\u01D3", "\x07m\x02\x02\u01D3\x1C\x03\x02\x02\x02\u01D4\u01D5", "\x07r\x02\x02\u01D5\u01D6\x07w\x02\x02\u01D6\u01D7\x07", "d\x02\x02\u01D7\u01D8\x07n\x02\x02\u01D8\u01D9\x07k\x02", "\x02\u01D9\u01DA\x07e\x02\x02\u01DA\x1E\x03\x02\x02", "\x02\u01DB\u01DC\x07r\x02\x02\u01DC\u01DD\x07c\x02\x02", "\u01DD\u01DE\x07e\x02\x02\u01DE\u01DF\x07m\x02\x02\u01DF", "\u01E0\x07c\x02\x02\u01E0\u01E1\x07i\x02\x02\u01E1\u01E2", "\x07g\x02\x02\u01E2 \x03\x02\x02\x02\u01E3\u01E4\x07", "q\x02\x02\u01E4\u01E5\x07r\x02\x02\u01E5\u01E6\x07v\x02", "\x02\u01E6\u01E7\x07k\x02\x02\u01E7\u01E8\x07q\x02\x02", "\u01E8\u01E9\x07p\x02\x02\u01E9\"\x03\x02\x02\x02\u01EA", "\u01EB\x07t\x02\x02\u01EB\u01EC\x07g\x02\x02\u01EC\u01ED", "\x07r\x02\x02\u01ED\u01EE\x07g\x02\x02\u01EE\u01EF\x07", "c\x02\x02\u01EF\u01F0\x07v\x02\x02\u01F0\u01F1\x07g\x02", "\x02\u01F1\u01F2\x07f\x02\x02\u01F2$\x03\x02\x02\x02", "\u01F3\u01F4\x07q\x02\x02\u01F4\u01F5\x07p\x02\x02\u01F5", "\u01F6\x07g\x02\x02\u01F6\u01F7\x07q\x02\x02\u01F7\u01F8", "\x07h\x02\x02\u01F8&\x03\x02\x02\x02\u01F9\u01FA\x07", "o\x02\x02\u01FA\u01FB\x07c\x02\x02\u01FB\u01FC\x07r\x02", "\x02\u01FC(\x03\x02\x02\x02\u01FD\u01FE\x07k\x02\x02", "\u01FE\u01FF\x07p\x02\x02\u01FF\u0200\x07v\x02\x02\u0200", "\u0201\x075\x02\x02\u0201\u0202\x074\x02\x02\u0202*\x03", "\x02\x02\x02\u0203\u0204\x07k\x02\x02\u0204\u0205\x07", "p\x02\x02\u0205\u0206\x07v\x02\x02\u0206\u0207\x078\x02", "\x02\u0207\u0208\x076\x02\x02\u0208,\x03\x02\x02\x02", "\u0209\u020A\x07w\x02\x02\u020A\u020B\x07k\x02\x02\u020B", "\u020C\x07p\x02\x02\u020C\u020D\x07v\x02\x02\u020D\u020E", "\x075\x02\x02\u020E\u020F\x074\x02\x02\u020F.\x03\x02", "\x02\x02\u0210\u0211\x07w\x02\x02\u0211\u0212\x07k\x02", "\x02\u0212\u0213\x07p\x02\x02\u0213\u0214\x07v\x02\x02", "\u0214\u0215\x078\x02\x02\u0215\u0216\x076\x02\x02\u0216", "0\x03\x02\x02\x02\u0217\u0218\x07u\x02\x02\u0218\u0219", "\x07k\x02\x02\u0219\u021A\x07p\x02\x02\u021A\u021B\x07", "v\x02\x02\u021B\u021C\x075\x02\x02\u021C\u021D\x074\x02", "\x02\u021D2\x03\x02\x02\x02\u021E\u021F\x07u\x02\x02", "\u021F\u0220\x07k\x02\x02\u0220\u0221\x07p\x02\x02\u0221", "\u0222\x07v\x02\x02\u0222\u0223\x078\x02\x02\u0223\u0224", "\x076\x02\x02\u02244\x03\x02\x02\x02\u0225\u0226\x07", "h\x02\x02\u0226\u0227\x07k\x02\x02\u0227\u0228\x07z\x02", "\x02\u0228\u0229\x07g\x02\x02\u0229\u022A\x07f\x02\x02", "\u022A\u022B\x075\x02\x02\u022B\u022C\x074\x02\x02\u022C", "6\x03\x02\x02\x02\u022D\u022E\x07h\x02\x02\u022E\u022F", "\x07k\x02\x02\u022F\u0230\x07z\x02\x02\u0230\u0231\x07", "g\x02\x02\u0231\u0232\x07f\x02\x02\u0232\u0233\x078\x02", "\x02\u0233\u0234\x076\x02\x02\u02348\x03\x02\x02\x02", "\u0235\u0236\x07u\x02\x02\u0236\u0237\x07h\x02\x02\u0237", "\u0238\x07k\x02\x02\u0238\u0239\x07z\x02\x02\u0239\u023A", "\x07g\x02\x02\u023A\u023B\x07f\x02\x02\u023B\u023C\x07", "5\x02\x02\u023C\u023D\x074\x02\x02\u023D:\x03\x02\x02", "\x02\u023E\u023F\x07u\x02\x02\u023F\u0240\x07h\x02\x02", "\u0240\u0241\x07k\x02\x02\u0241\u0242\x07z\x02\x02\u0242", "\u0243\x07g\x02\x02\u0243\u0244\x07f\x02\x02\u0244\u0245", "\x078\x02\x02\u0245\u0246\x076\x02\x02\u0246<\x03\x02", "\x02\x02\u0247\u0248\x07d\x02\x02\u0248\u0249\x07q\x02", "\x02\u0249\u024A\x07q\x02\x02\u024A\u024B\x07n\x02\x02", "\u024B>\x03\x02\x02\x02\u024C\u024D\x07u\x02\x02\u024D", "\u024E\x07v\x02\x02\u024E\u024F\x07t\x02\x02\u024F\u0250", "\x07k\x02\x02\u0250\u0251\x07p\x02\x02\u0251\u0252\x07", "i\x02\x02\u0252@\x03\x02\x02\x02\u0253\u0254\x07f\x02", "\x02\u0254\u0255\x07q\x02\x02\u0255\u0256\x07w\x02\x02", "\u0256\u0257\x07d\x02\x02\u0257\u0258\x07n\x02\x02\u0258", "\u0259\x07g\x02\x02\u0259B\x03\x02\x02\x02\u025A\u025B", "\x07h\x02\x02\u025B\u025C\x07n\x02\x02\u025C\u025D\x07", "q\x02\x02\u025D\u025E\x07c\x02\x02\u025E\u025F\x07v\x02", "\x02\u025FD\x03\x02\x02\x02\u0260\u0261\x07d\x02\x02", "\u0261\u0262\x07{\x02\x02\u0262\u0263\x07v\x02\x02\u0263", "\u0264\x07g\x02\x02\u0264\u0265\x07u\x02\x02\u0265F\x03", "\x02\x02\x02\u0266\u0267\x07t\x02\x02\u0267\u0268\x07", "g\x02\x02\u0268\u0269\x07u\x02\x02\u0269\u026A\x07g\x02", "\x02\u026A\u026B\x07t\x02\x02\u026B\u026C\x07x\x02\x02", "\u026C\u026D\x07g\x02\x02\u026D\u026E\x07f\x02\x02\u026E", "H\x03\x02\x02\x02\u026F\u0270\x07v\x02\x02\u0270\u0271", "\x07q\x02\x02\u0271J\x03\x02\x02\x02\u0272\u0273\x07", "o\x02\x02\u0273\u0274\x07c\x02\x02\u0274\u0275\x07z\x02", "\x02\u0275L\x03\x02\x02\x02\u0276\u0277\x07g\x02\x02", "\u0277\u0278\x07p\x02\x02\u0278\u0279\x07w\x02\x02\u0279", "\u027A\x07o\x02\x02\u027AN\x03\x02\x02\x02\u027B\u027C", "\x07o\x02\x02\u027C\u027D\x07g\x02\x02\u027D\u027E\x07", "u\x02\x02\u027E\u027F\x07u\x02\x02\u027F\u0280\x07c\x02", "\x02\u0280\u0281\x07i\x02\x02\u0281\u0282\x07g\x02\x02", "\u0282P\x03\x02\x02\x02\u0283\u0284\x07u\x02\x02\u0284", "\u0285\x07g\x02\x02\u0285\u0286\x07t\x02\x02\u0286\u0287", "\x07x\x02\x02\u0287\u0288\x07k\x02\x02\u0288\u0289\x07", "e\x02\x02\u0289\u028A\x07g\x02\x02\u028AR\x03\x02\x02", "\x02\u028B\u028C\x07t\x02\x02\u028C\u028D\x07r\x02\x02", "\u028D\u028E\x07e\x02\x02\u028ET\x03\x02\x02\x02\u028F", "\u0290\x07u\x02\x02\u0290\u0291\x07v\x02\x02\u0291\u0292", "\x07t\x02\x02\u0292\u0293\x07g\x02\x02\u0293\u0294\x07", "c\x02\x02\u0294\u0295\x07o\x02\x02\u0295V\x03\x02\x02", "\x02\u0296\u0297\x07t\x02\x02\u0297\u0298\x07g\x02\x02", "\u0298\u0299\x07v\x02\x02\u0299\u029A\x07w\x02\x02\u029A", "\u029B\x07t\x02\x02\u029B\u029C\x07p\x02\x02\u029C\u029D", "\x07u\x02\x02\u029DX\x03\x02\x02\x02\u029E\u029F\x07", "$\x02\x02\u029F\u02A0\x07r\x02\x02\u02A0\u02A1\x07t\x02", "\x02\u02A1\u02A2\x07q\x02\x02\u02A2\u02A3\x07v\x02\x02", "\u02A3\u02A4\x07q\x02\x02\u02A4\u02A5\x075\x02\x02\u02A5", "\u02A6\x07$\x02\x02\u02A6Z\x03\x02\x02\x02\u02A7\u02A8", "\x07)\x02\x02\u02A8\u02A9\x07r\x02\x02\u02A9\u02AA\x07", "t\x02\x02\u02AA\u02AB\x07q\x02\x02\u02AB\u02AC\x07v\x02", "\x02\u02AC\u02AD\x07q\x02\x02\u02AD\u02AE\x075\x02\x02", "\u02AE\u02AF\x07)\x02\x02\u02AF\\\x03\x02\x02\x02\u02B0", "\u02B1\x07=\x02\x02\u02B1^\x03\x02\x02\x02\u02B2\u02B3", "\x07?\x02\x02\u02B3`\x03\x02\x02\x02\u02B4\u02B5\x07", "*\x02\x02\u02B5b\x03\x02\x02\x02\u02B6\u02B7\x07+\x02", "\x02\u02B7d\x03\x02\x02\x02\u02B8\u02B9\x07]\x02\x02", "\u02B9f\x03\x02\x02\x02\u02BA\u02BB\x07_\x02\x02\u02BB", "h\x03\x02\x02\x02\u02BC\u02BD\x07}\x02\x02\u02BDj\x03", "\x02\x02\x02\u02BE\u02BF\x07\x7F\x02\x02\u02BFl\x03", "\x02\x02\x02\u02C0\u02C1\x07>\x02\x02\u02C1n\x03\x02", "\x02\x02\u02C2\u02C3\x07@\x02\x02\u02C3p\x03\x02\x02", "\x02\u02C4\u02C5\x070\x02\x02\u02C5r\x03\x02\x02\x02", "\u02C6\u02C7\x07.\x02\x02\u02C7t\x03\x02\x02\x02\u02C8", "\u02C9\x07<\x02\x02\u02C9v\x03\x02\x02\x02\u02CA\u02CB", "\x07-\x02\x02\u02CBx\x03\x02\x02\x02\u02CC\u02CD\x07", "/\x02\x02\u02CDz\x03\x02\x02\x02\u02CE\u02D2\x07)\x02", "\x02\u02CF\u02D1\x05}?\x02\u02D0\u02CF\x03\x02\x02\x02", "\u02D1\u02D4\x03\x02\x02\x02\u02D2\u02D3\x03\x02\x02\x02", "\u02D2\u02D0\x03\x02\x02\x02\u02D3\u02D5\x03\x02\x02\x02", "\u02D4\u02D2\x03\x02\x02\x02\u02D5\u02DF\x07)\x02\x02", "\u02D6\u02DA\x07$\x02\x02\u02D7\u02D9\x05}?\x02\u02D8\u02D7", "\x03\x02\x02\x02\u02D9\u02DC\x03\x02\x02\x02\u02DA\u02DB", "\x03\x02\x02\x02\u02DA\u02D8\x03\x02\x02\x02\u02DB\u02DD", "\x03\x02\x02\x02\u02DC\u02DA\x03\x02\x02\x02\u02DD\u02DF", "\x07$\x02\x02\u02DE\u02CE\x03\x02\x02\x02\u02DE\u02D6", "\x03\x02\x02\x02\u02DF|\x03\x02\x02\x02\u02E0\u02E5", "\x05\x7F@\x02\u02E1\u02E5\x05\x81A\x02\u02E2\u02E5\x05", "\x83B\x02\u02E3\u02E5\n\x02\x02\x02\u02E4\u02E0\x03\x02", "\x02\x02\u02E4\u02E1\x03\x02\x02\x02\u02E4\u02E2\x03\x02", "\x02\x02\u02E4\u02E3\x03\x02\x02\x02\u02E5~\x03\x02", "\x02\x02\u02E6\u02E7\x07^\x02\x02\u02E7\u02E8\t\x03\x02", "\x02\u02E8\u02E9\x05\x9DO\x02\u02E9\u02EA\x05\x9DO\x02", "\u02EA\x80\x03\x02\x02\x02\u02EB\u02EC\x07^\x02\x02", "\u02EC\u02ED\x05\x9BN\x02\u02ED\u02EE\x05\x9BN\x02\u02EE", "\u02EF\x05\x9BN\x02\u02EF\x82\x03\x02\x02\x02\u02F0", "\u02F1\x07^\x02\x02\u02F1\u02F2\t\x04\x02\x02\u02F2\x84", "\x03\x02\x02\x02\u02F3\u02F4\x07v\x02\x02\u02F4\u02F5", "\x07t\x02\x02\u02F5\u02F6\x07w\x02\x02\u02F6\u02FD\x07", "g\x02\x02\u02F7\u02F8\x07h\x02\x02\u02F8\u02F9\x07c\x02", "\x02\u02F9\u02FA\x07n\x02\x02\u02FA\u02FB\x07u\x02\x02", "\u02FB\u02FD\x07g\x02\x02\u02FC\u02F3\x03\x02\x02\x02", "\u02FC\u02F7\x03\x02\x02\x02\u02FD\x86\x03\x02\x02\x02", "\u02FE\u02FF\x05\x8BF\x02\u02FF\u0301\x05q9\x02\u0300\u0302", "\x05\x8BF\x02\u0301\u0300\x03\x02\x02\x02\u0301\u0302", "\x03\x02\x02\x02\u0302\u0304\x03\x02\x02\x02\u0303\u0305", "\x05\x89E\x02\u0304\u0303\x03\x02\x02\x02\u0304\u0305", "\x03\x02\x02\x02\u0305\u030F\x03\x02\x02\x02\u0306\u0307", "\x05\x8BF\x02\u0307\u0308\x05\x89E\x02\u0308\u030F\x03", "\x02\x02\x02\u0309\u030A\x05q9\x02\u030A\u030C\x05\x8B", "F\x02\u030B\u030D\x05\x89E\x02\u030C\u030B\x03\x02\x02", "\x02\u030C\u030D\x03\x02\x02\x02\u030D\u030F\x03\x02\x02", "\x02\u030E\u02FE\x03\x02\x02\x02\u030E\u0306\x03\x02\x02", "\x02\u030E\u0309\x03\x02\x02\x02\u030F\u0317\x03\x02\x02", "\x02\u0310\u0311\x07k\x02\x02\u0311\u0312\x07p\x02\x02", "\u0312\u0317\x07h\x02\x02\u0313\u0314\x07p\x02\x02\u0314", "\u0315\x07c\x02\x02\u0315\u0317\x07p\x02\x02\u0316\u030E", "\x03\x02\x02\x02\u0316\u0310\x03\x02\x02\x02\u0316\u0313", "\x03\x02\x02\x02\u0317\x88\x03\x02\x02\x02\u0318\u031B", "\t\x05\x02\x02\u0319\u031C\x05w<\x02\u031A\u031C\x05y=\x02", "\u031B\u0319\x03\x02\x02\x02\u031B\u031A\x03\x02\x02\x02", "\u031B\u031C\x03\x02\x02\x02\u031C\u031D\x03\x02\x02\x02", "\u031D\u031E\x05\x8BF\x02\u031E\x8A\x03\x02\x02\x02", "\u031F\u0321\x05\x99M\x02\u0320\u031F\x03\x02\x02\x02", "\u0321\u0322\x03\x02\x02\x02\u0322\u0320\x03\x02\x02\x02", "\u0322\u0323\x03\x02\x02\x02\u0323\x8C\x03\x02\x02\x02", "\u0324\u0328\x05\x8FH\x02\u0325\u0328\x05\x91I\x02\u0326", "\u0328\x05\x93J\x02\u0327\u0324\x03\x02\x02\x02\u0327", "\u0325\x03\x02\x02\x02\u0327\u0326\x03\x02\x02\x02\u0328", "\x8E\x03\x02\x02\x02\u0329\u032D\t\x06\x02\x02\u032A", "\u032C\x05\x99M\x02\u032B\u032A\x03\x02\x02\x02\u032C", "\u032F\x03\x02\x02\x02\u032D\u032B\x03\x02\x02\x02\u032D", "\u032E\x03\x02\x02\x02\u032E\x90\x03\x02\x02\x02\u032F", "\u032D\x03\x02\x02\x02\u0330\u0334\x072\x02\x02\u0331", "\u0333\x05\x9BN\x02\u0332\u0331\x03\x02\x02\x02\u0333", "\u0336\x03\x02\x02\x02\u0334\u0332\x03\x02\x02\x02\u0334", "\u0335\x03\x02\x02\x02\u0335\x92\x03\x02\x02\x02\u0336", "\u0334\x03\x02\x02\x02\u0337\u0338\x072\x02\x02\u0338", "\u033A\t\x03\x02\x02\u0339\u033B\x05\x9DO\x02\u033A\u0339", "\x03\x02\x02\x02\u033B\u033C\x03\x02\x02\x02\u033C\u033A", "\x03\x02\x02\x02\u033C\u033D\x03\x02\x02\x02\u033D\x94", "\x03\x02\x02\x02\u033E\u0343\x05\x97L\x02\u033F\u0342", "\x05\x97L\x02\u0340\u0342\x05\x99M\x02\u0341\u033F\x03", "\x02\x02\x02\u0341\u0340\x03\x02\x02\x02\u0342\u0345\x03", "\x02\x02\x02\u0343\u0341\x03\x02\x02\x02\u0343\u0344\x03", "\x02\x02\x02\u0344\x96\x03\x02\x02\x02\u0345\u0343\x03", "\x02\x02\x02\u0346\u0347\t\x07\x02\x02\u0347\x98\x03", "\x02\x02\x02\u0348\u0349\t\b\x02\x02\u0349\x9A\x03\x02", "\x02\x02\u034A\u034B\t\t\x02\x02\u034B\x9C\x03\x02\x02", "\x02\u034C\u034D\t\n\x02\x02\u034D\x9E\x03\x02\x02\x02", "\u034E\u0350\t\x0B\x02\x02\u034F\u034E\x03\x02\x02\x02", "\u0350\u0351\x03\x02\x02\x02\u0351\u034F\x03\x02\x02\x02", "\u0351\u0352\x03\x02\x02\x02\u0352\u0353\x03\x02\x02\x02", "\u0353\u0354\bP\x02\x02\u0354\xA0\x03\x02\x02\x02\u0355", "\u0356\x071\x02\x02\u0356\u0357\x071\x02\x02\u0357\u035B", "\x03\x02\x02\x02\u0358\u035A\n\f\x02\x02\u0359\u0358\x03", "\x02\x02\x02\u035A\u035D\x03\x02\x02\x02\u035B\u0359\x03", "\x02\x02\x02\u035B\u035C\x03\x02\x02\x02\u035C\u035E\x03", "\x02\x02\x02\u035D\u035B\x03\x02\x02\x02\u035E\u035F\b", "Q\x02\x02\u035F\xA2\x03\x02\x02\x02\u0360\u0361\x07", "1\x02\x02\u0361\u0362\x07,\x02\x02\u0362\u0366\x03\x02", "\x02\x02\u0363\u0365\x0B\x02\x02\x02\u0364\u0363\x03\x02", "\x02\x02\u0365\u0368\x03\x02\x02\x02\u0366\u0367\x03\x02", "\x02\x02\u0366\u0364\x03\x02\x02\x02\u0367\u0369\x03\x02", "\x02\x02\u0368\u0366\x03\x02\x02\x02\u0369\u036A\x07,", "\x02\x02\u036A\u036B\x071\x02\x02\u036B\u036C\x03\x02", "\x02\x02\u036C\u036D\bR\x02\x02\u036D\xA4\x03\x02\x02", "\x02\x18\x02\u02D2\u02DA\u02DE\u02E4\u02FC\u0301\u0304\u030C\u030E", "\u0316\u031B\u0322\u0327\u032D\u0334\u033C\u0341\u0343\u0351\u035B\u0366", "\x03\b\x02\x02"].join("");
	var atn = new _antlr["default"].atn.ATNDeserializer().deserialize(serializedATN);
	var decisionsToDFA = atn.decisionToState.map(function (ds, index) {
	  return new _antlr["default"].dfa.DFA(ds, index);
	});

	var Protobuf3Lexer = /*#__PURE__*/function (_antlr4$Lexer) {
	  _inherits(Protobuf3Lexer, _antlr4$Lexer);

	  var _super = _createSuper(Protobuf3Lexer);

	  function Protobuf3Lexer(input) {
	    var _this;

	    _classCallCheck(this, Protobuf3Lexer);

	    _this = _super.call(this, input);
	    _this._interp = new _antlr["default"].atn.LexerATNSimulator(_assertThisInitialized(_this), atn, decisionsToDFA, new _antlr["default"].PredictionContextCache());
	    return _this;
	  }

	  _createClass(Protobuf3Lexer, [{
	    key: "atn",
	    get: function get() {
	      return atn;
	    }
	  }]);

	  return Protobuf3Lexer;
	}(_antlr["default"].Lexer);

	exports["default"] = Protobuf3Lexer;

	_defineProperty(Protobuf3Lexer, "grammarFileName", "Protobuf3.g4");

	_defineProperty(Protobuf3Lexer, "channelNames", ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"]);

	_defineProperty(Protobuf3Lexer, "modeNames", ["DEFAULT_MODE"]);

	_defineProperty(Protobuf3Lexer, "literalNames", [null, "'google.protobuf.FieldOptions'", "'google.protobuf.EnumOptions'", "'google.protobuf.EnumValueOptions'", "'google.protobuf.ExtensionRangeOptions'", "'google.protobuf.MessageOptions'", "'google.protobuf.MethodOptions'", "'google.protobuf.ServiceOptions'", "'google.protobuf.FileOptions'", "'google.protobuf.OneofOptions'", "'syntax'", "'import'", "'extend'", "'weak'", "'public'", "'package'", "'option'", "'repeated'", "'oneof'", "'map'", "'int32'", "'int64'", "'uint32'", "'uint64'", "'sint32'", "'sint64'", "'fixed32'", "'fixed64'", "'sfixed32'", "'sfixed64'", "'bool'", "'string'", "'double'", "'float'", "'bytes'", "'reserved'", "'to'", "'max'", "'enum'", "'message'", "'service'", "'rpc'", "'stream'", "'returns'", "'\"proto3\"'", "''proto3''", "';'", "'='", "'('", "')'", "'['", "']'", "'{'", "'}'", "'<'", "'>'", "'.'", "','", "':'", "'+'", "'-'"]);

	_defineProperty(Protobuf3Lexer, "symbolicNames", [null, "FIELD_OPTIONS", "ENUM_OPTIONS", "ENUM_VALUE_OPTIONS", "EXTENSION_RANGE_OPTIONS", "MESSAGE_OPTIONS", "METHOD_OPTIONS", "SERVICE_OPTIONS", "FILE_OPTIONS", "ONEOF_OPTIONS", "SYNTAX", "IMPORT", "EXTEND", "WEAK", "PUBLIC", "PACKAGE", "OPTION", "REPEATED", "ONEOF", "MAP", "INT32", "INT64", "UINT32", "UINT64", "SINT32", "SINT64", "FIXED32", "FIXED64", "SFIXED32", "SFIXED64", "BOOL", "STRING", "DOUBLE", "FLOAT", "BYTES", "RESERVED", "TO", "MAX", "ENUM", "MESSAGE", "SERVICE", "RPC", "STREAM", "RETURNS", "PROTO3_LIT_SINGLE", "PROTO3_LIT_DOBULE", "SEMI", "EQ", "LP", "RP", "LB", "RB", "LC", "RC", "LT", "GT", "DOT", "COMMA", "COLON", "PLUS", "MINUS", "STR_LIT", "BOOL_LIT", "FLOAT_LIT", "INT_LIT", "IDENTIFIER", "WS", "LINE_COMMENT", "COMMENT"]);

	_defineProperty(Protobuf3Lexer, "ruleNames", ["FIELD_OPTIONS", "ENUM_OPTIONS", "ENUM_VALUE_OPTIONS", "EXTENSION_RANGE_OPTIONS", "MESSAGE_OPTIONS", "METHOD_OPTIONS", "SERVICE_OPTIONS", "FILE_OPTIONS", "ONEOF_OPTIONS", "SYNTAX", "IMPORT", "EXTEND", "WEAK", "PUBLIC", "PACKAGE", "OPTION", "REPEATED", "ONEOF", "MAP", "INT32", "INT64", "UINT32", "UINT64", "SINT32", "SINT64", "FIXED32", "FIXED64", "SFIXED32", "SFIXED64", "BOOL", "STRING", "DOUBLE", "FLOAT", "BYTES", "RESERVED", "TO", "MAX", "ENUM", "MESSAGE", "SERVICE", "RPC", "STREAM", "RETURNS", "PROTO3_LIT_SINGLE", "PROTO3_LIT_DOBULE", "SEMI", "EQ", "LP", "RP", "LB", "RB", "LC", "RC", "LT", "GT", "DOT", "COMMA", "COLON", "PLUS", "MINUS", "STR_LIT", "CHAR_VALUE", "HEX_ESCAPE", "OCT_ESCAPE", "CHAR_ESCAPE", "BOOL_LIT", "FLOAT_LIT", "EXPONENT", "DECIMALS", "INT_LIT", "DECIMAL_LIT", "OCTAL_LIT", "HEX_LIT", "IDENTIFIER", "LETTER", "DECIMAL_DIGIT", "OCTAL_DIGIT", "HEX_DIGIT", "WS", "LINE_COMMENT", "COMMENT"]);

	Protobuf3Lexer.EOF = _antlr["default"].Token.EOF;
	Protobuf3Lexer.FIELD_OPTIONS = 1;
	Protobuf3Lexer.ENUM_OPTIONS = 2;
	Protobuf3Lexer.ENUM_VALUE_OPTIONS = 3;
	Protobuf3Lexer.EXTENSION_RANGE_OPTIONS = 4;
	Protobuf3Lexer.MESSAGE_OPTIONS = 5;
	Protobuf3Lexer.METHOD_OPTIONS = 6;
	Protobuf3Lexer.SERVICE_OPTIONS = 7;
	Protobuf3Lexer.FILE_OPTIONS = 8;
	Protobuf3Lexer.ONEOF_OPTIONS = 9;
	Protobuf3Lexer.SYNTAX = 10;
	Protobuf3Lexer.IMPORT = 11;
	Protobuf3Lexer.EXTEND = 12;
	Protobuf3Lexer.WEAK = 13;
	Protobuf3Lexer.PUBLIC = 14;
	Protobuf3Lexer.PACKAGE = 15;
	Protobuf3Lexer.OPTION = 16;
	Protobuf3Lexer.REPEATED = 17;
	Protobuf3Lexer.ONEOF = 18;
	Protobuf3Lexer.MAP = 19;
	Protobuf3Lexer.INT32 = 20;
	Protobuf3Lexer.INT64 = 21;
	Protobuf3Lexer.UINT32 = 22;
	Protobuf3Lexer.UINT64 = 23;
	Protobuf3Lexer.SINT32 = 24;
	Protobuf3Lexer.SINT64 = 25;
	Protobuf3Lexer.FIXED32 = 26;
	Protobuf3Lexer.FIXED64 = 27;
	Protobuf3Lexer.SFIXED32 = 28;
	Protobuf3Lexer.SFIXED64 = 29;
	Protobuf3Lexer.BOOL = 30;
	Protobuf3Lexer.STRING = 31;
	Protobuf3Lexer.DOUBLE = 32;
	Protobuf3Lexer.FLOAT = 33;
	Protobuf3Lexer.BYTES = 34;
	Protobuf3Lexer.RESERVED = 35;
	Protobuf3Lexer.TO = 36;
	Protobuf3Lexer.MAX = 37;
	Protobuf3Lexer.ENUM = 38;
	Protobuf3Lexer.MESSAGE = 39;
	Protobuf3Lexer.SERVICE = 40;
	Protobuf3Lexer.RPC = 41;
	Protobuf3Lexer.STREAM = 42;
	Protobuf3Lexer.RETURNS = 43;
	Protobuf3Lexer.PROTO3_LIT_SINGLE = 44;
	Protobuf3Lexer.PROTO3_LIT_DOBULE = 45;
	Protobuf3Lexer.SEMI = 46;
	Protobuf3Lexer.EQ = 47;
	Protobuf3Lexer.LP = 48;
	Protobuf3Lexer.RP = 49;
	Protobuf3Lexer.LB = 50;
	Protobuf3Lexer.RB = 51;
	Protobuf3Lexer.LC = 52;
	Protobuf3Lexer.RC = 53;
	Protobuf3Lexer.LT = 54;
	Protobuf3Lexer.GT = 55;
	Protobuf3Lexer.DOT = 56;
	Protobuf3Lexer.COMMA = 57;
	Protobuf3Lexer.COLON = 58;
	Protobuf3Lexer.PLUS = 59;
	Protobuf3Lexer.MINUS = 60;
	Protobuf3Lexer.STR_LIT = 61;
	Protobuf3Lexer.BOOL_LIT = 62;
	Protobuf3Lexer.FLOAT_LIT = 63;
	Protobuf3Lexer.INT_LIT = 64;
	Protobuf3Lexer.IDENTIFIER = 65;
	Protobuf3Lexer.WS = 66;
	Protobuf3Lexer.LINE_COMMENT = 67;
	Protobuf3Lexer.COMMENT = 68;
} (Protobuf3Lexer$1));

var Protobuf3Lexer = /*@__PURE__*/getDefaultExportFromCjs(Protobuf3Lexer$1);

var Protobuf3Parser$1 = {};

var Protobuf3Listener$1 = {};

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// This class defines a complete listener for a parse tree produced by Protobuf3Parser.
	var Protobuf3Listener = /*#__PURE__*/function (_antlr4$tree$ParseTre) {
	  _inherits(Protobuf3Listener, _antlr4$tree$ParseTre);

	  var _super = _createSuper(Protobuf3Listener);

	  function Protobuf3Listener() {
	    _classCallCheck(this, Protobuf3Listener);

	    return _super.apply(this, arguments);
	  }

	  _createClass(Protobuf3Listener, [{
	    key: "enterProto",
	    value: // Enter a parse tree produced by Protobuf3Parser#proto.
	    function enterProto(ctx) {} // Exit a parse tree produced by Protobuf3Parser#proto.

	  }, {
	    key: "exitProto",
	    value: function exitProto(ctx) {} // Enter a parse tree produced by Protobuf3Parser#syntax.

	  }, {
	    key: "enterSyntax",
	    value: function enterSyntax(ctx) {} // Exit a parse tree produced by Protobuf3Parser#syntax.

	  }, {
	    key: "exitSyntax",
	    value: function exitSyntax(ctx) {} // Enter a parse tree produced by Protobuf3Parser#importStatement.

	  }, {
	    key: "enterImportStatement",
	    value: function enterImportStatement(ctx) {} // Exit a parse tree produced by Protobuf3Parser#importStatement.

	  }, {
	    key: "exitImportStatement",
	    value: function exitImportStatement(ctx) {} // Enter a parse tree produced by Protobuf3Parser#packageStatement.

	  }, {
	    key: "enterPackageStatement",
	    value: function enterPackageStatement(ctx) {} // Exit a parse tree produced by Protobuf3Parser#packageStatement.

	  }, {
	    key: "exitPackageStatement",
	    value: function exitPackageStatement(ctx) {} // Enter a parse tree produced by Protobuf3Parser#optionStatement.

	  }, {
	    key: "enterOptionStatement",
	    value: function enterOptionStatement(ctx) {} // Exit a parse tree produced by Protobuf3Parser#optionStatement.

	  }, {
	    key: "exitOptionStatement",
	    value: function exitOptionStatement(ctx) {} // Enter a parse tree produced by Protobuf3Parser#optionName.

	  }, {
	    key: "enterOptionName",
	    value: function enterOptionName(ctx) {} // Exit a parse tree produced by Protobuf3Parser#optionName.

	  }, {
	    key: "exitOptionName",
	    value: function exitOptionName(ctx) {} // Enter a parse tree produced by Protobuf3Parser#extendsStatement.

	  }, {
	    key: "enterExtendsStatement",
	    value: function enterExtendsStatement(ctx) {} // Exit a parse tree produced by Protobuf3Parser#extendsStatement.

	  }, {
	    key: "exitExtendsStatement",
	    value: function exitExtendsStatement(ctx) {} // Enter a parse tree produced by Protobuf3Parser#extendedIdentifier.

	  }, {
	    key: "enterExtendedIdentifier",
	    value: function enterExtendedIdentifier(ctx) {} // Exit a parse tree produced by Protobuf3Parser#extendedIdentifier.

	  }, {
	    key: "exitExtendedIdentifier",
	    value: function exitExtendedIdentifier(ctx) {} // Enter a parse tree produced by Protobuf3Parser#field.

	  }, {
	    key: "enterField",
	    value: function enterField(ctx) {} // Exit a parse tree produced by Protobuf3Parser#field.

	  }, {
	    key: "exitField",
	    value: function exitField(ctx) {} // Enter a parse tree produced by Protobuf3Parser#fieldOptions.

	  }, {
	    key: "enterFieldOptions",
	    value: function enterFieldOptions(ctx) {} // Exit a parse tree produced by Protobuf3Parser#fieldOptions.

	  }, {
	    key: "exitFieldOptions",
	    value: function exitFieldOptions(ctx) {} // Enter a parse tree produced by Protobuf3Parser#fieldOption.

	  }, {
	    key: "enterFieldOption",
	    value: function enterFieldOption(ctx) {} // Exit a parse tree produced by Protobuf3Parser#fieldOption.

	  }, {
	    key: "exitFieldOption",
	    value: function exitFieldOption(ctx) {} // Enter a parse tree produced by Protobuf3Parser#fieldNumber.

	  }, {
	    key: "enterFieldNumber",
	    value: function enterFieldNumber(ctx) {} // Exit a parse tree produced by Protobuf3Parser#fieldNumber.

	  }, {
	    key: "exitFieldNumber",
	    value: function exitFieldNumber(ctx) {} // Enter a parse tree produced by Protobuf3Parser#oneof.

	  }, {
	    key: "enterOneof",
	    value: function enterOneof(ctx) {} // Exit a parse tree produced by Protobuf3Parser#oneof.

	  }, {
	    key: "exitOneof",
	    value: function exitOneof(ctx) {} // Enter a parse tree produced by Protobuf3Parser#oneofField.

	  }, {
	    key: "enterOneofField",
	    value: function enterOneofField(ctx) {} // Exit a parse tree produced by Protobuf3Parser#oneofField.

	  }, {
	    key: "exitOneofField",
	    value: function exitOneofField(ctx) {} // Enter a parse tree produced by Protobuf3Parser#mapField.

	  }, {
	    key: "enterMapField",
	    value: function enterMapField(ctx) {} // Exit a parse tree produced by Protobuf3Parser#mapField.

	  }, {
	    key: "exitMapField",
	    value: function exitMapField(ctx) {} // Enter a parse tree produced by Protobuf3Parser#keyType.

	  }, {
	    key: "enterKeyType",
	    value: function enterKeyType(ctx) {} // Exit a parse tree produced by Protobuf3Parser#keyType.

	  }, {
	    key: "exitKeyType",
	    value: function exitKeyType(ctx) {} // Enter a parse tree produced by Protobuf3Parser#type_.

	  }, {
	    key: "enterType_",
	    value: function enterType_(ctx) {} // Exit a parse tree produced by Protobuf3Parser#type_.

	  }, {
	    key: "exitType_",
	    value: function exitType_(ctx) {} // Enter a parse tree produced by Protobuf3Parser#reserved.

	  }, {
	    key: "enterReserved",
	    value: function enterReserved(ctx) {} // Exit a parse tree produced by Protobuf3Parser#reserved.

	  }, {
	    key: "exitReserved",
	    value: function exitReserved(ctx) {} // Enter a parse tree produced by Protobuf3Parser#ranges.

	  }, {
	    key: "enterRanges",
	    value: function enterRanges(ctx) {} // Exit a parse tree produced by Protobuf3Parser#ranges.

	  }, {
	    key: "exitRanges",
	    value: function exitRanges(ctx) {} // Enter a parse tree produced by Protobuf3Parser#range_.

	  }, {
	    key: "enterRange_",
	    value: function enterRange_(ctx) {} // Exit a parse tree produced by Protobuf3Parser#range_.

	  }, {
	    key: "exitRange_",
	    value: function exitRange_(ctx) {} // Enter a parse tree produced by Protobuf3Parser#reservedFieldNames.

	  }, {
	    key: "enterReservedFieldNames",
	    value: function enterReservedFieldNames(ctx) {} // Exit a parse tree produced by Protobuf3Parser#reservedFieldNames.

	  }, {
	    key: "exitReservedFieldNames",
	    value: function exitReservedFieldNames(ctx) {} // Enter a parse tree produced by Protobuf3Parser#topLevelDef.

	  }, {
	    key: "enterTopLevelDef",
	    value: function enterTopLevelDef(ctx) {} // Exit a parse tree produced by Protobuf3Parser#topLevelDef.

	  }, {
	    key: "exitTopLevelDef",
	    value: function exitTopLevelDef(ctx) {} // Enter a parse tree produced by Protobuf3Parser#enumDef.

	  }, {
	    key: "enterEnumDef",
	    value: function enterEnumDef(ctx) {} // Exit a parse tree produced by Protobuf3Parser#enumDef.

	  }, {
	    key: "exitEnumDef",
	    value: function exitEnumDef(ctx) {} // Enter a parse tree produced by Protobuf3Parser#enumBody.

	  }, {
	    key: "enterEnumBody",
	    value: function enterEnumBody(ctx) {} // Exit a parse tree produced by Protobuf3Parser#enumBody.

	  }, {
	    key: "exitEnumBody",
	    value: function exitEnumBody(ctx) {} // Enter a parse tree produced by Protobuf3Parser#enumElement.

	  }, {
	    key: "enterEnumElement",
	    value: function enterEnumElement(ctx) {} // Exit a parse tree produced by Protobuf3Parser#enumElement.

	  }, {
	    key: "exitEnumElement",
	    value: function exitEnumElement(ctx) {} // Enter a parse tree produced by Protobuf3Parser#enumField.

	  }, {
	    key: "enterEnumField",
	    value: function enterEnumField(ctx) {} // Exit a parse tree produced by Protobuf3Parser#enumField.

	  }, {
	    key: "exitEnumField",
	    value: function exitEnumField(ctx) {} // Enter a parse tree produced by Protobuf3Parser#enumValueOptions.

	  }, {
	    key: "enterEnumValueOptions",
	    value: function enterEnumValueOptions(ctx) {} // Exit a parse tree produced by Protobuf3Parser#enumValueOptions.

	  }, {
	    key: "exitEnumValueOptions",
	    value: function exitEnumValueOptions(ctx) {} // Enter a parse tree produced by Protobuf3Parser#enumValueOption.

	  }, {
	    key: "enterEnumValueOption",
	    value: function enterEnumValueOption(ctx) {} // Exit a parse tree produced by Protobuf3Parser#enumValueOption.

	  }, {
	    key: "exitEnumValueOption",
	    value: function exitEnumValueOption(ctx) {} // Enter a parse tree produced by Protobuf3Parser#messageDef.

	  }, {
	    key: "enterMessageDef",
	    value: function enterMessageDef(ctx) {} // Exit a parse tree produced by Protobuf3Parser#messageDef.

	  }, {
	    key: "exitMessageDef",
	    value: function exitMessageDef(ctx) {} // Enter a parse tree produced by Protobuf3Parser#messageBody.

	  }, {
	    key: "enterMessageBody",
	    value: function enterMessageBody(ctx) {} // Exit a parse tree produced by Protobuf3Parser#messageBody.

	  }, {
	    key: "exitMessageBody",
	    value: function exitMessageBody(ctx) {} // Enter a parse tree produced by Protobuf3Parser#messageElement.

	  }, {
	    key: "enterMessageElement",
	    value: function enterMessageElement(ctx) {} // Exit a parse tree produced by Protobuf3Parser#messageElement.

	  }, {
	    key: "exitMessageElement",
	    value: function exitMessageElement(ctx) {} // Enter a parse tree produced by Protobuf3Parser#serviceDef.

	  }, {
	    key: "enterServiceDef",
	    value: function enterServiceDef(ctx) {} // Exit a parse tree produced by Protobuf3Parser#serviceDef.

	  }, {
	    key: "exitServiceDef",
	    value: function exitServiceDef(ctx) {} // Enter a parse tree produced by Protobuf3Parser#serviceElement.

	  }, {
	    key: "enterServiceElement",
	    value: function enterServiceElement(ctx) {} // Exit a parse tree produced by Protobuf3Parser#serviceElement.

	  }, {
	    key: "exitServiceElement",
	    value: function exitServiceElement(ctx) {} // Enter a parse tree produced by Protobuf3Parser#rpc.

	  }, {
	    key: "enterRpc",
	    value: function enterRpc(ctx) {} // Exit a parse tree produced by Protobuf3Parser#rpc.

	  }, {
	    key: "exitRpc",
	    value: function exitRpc(ctx) {} // Enter a parse tree produced by Protobuf3Parser#constant.

	  }, {
	    key: "enterConstant",
	    value: function enterConstant(ctx) {} // Exit a parse tree produced by Protobuf3Parser#constant.

	  }, {
	    key: "exitConstant",
	    value: function exitConstant(ctx) {} // Enter a parse tree produced by Protobuf3Parser#blockLit.

	  }, {
	    key: "enterBlockLit",
	    value: function enterBlockLit(ctx) {} // Exit a parse tree produced by Protobuf3Parser#blockLit.

	  }, {
	    key: "exitBlockLit",
	    value: function exitBlockLit(ctx) {} // Enter a parse tree produced by Protobuf3Parser#emptyStatement.

	  }, {
	    key: "enterEmptyStatement",
	    value: function enterEmptyStatement(ctx) {} // Exit a parse tree produced by Protobuf3Parser#emptyStatement.

	  }, {
	    key: "exitEmptyStatement",
	    value: function exitEmptyStatement(ctx) {} // Enter a parse tree produced by Protobuf3Parser#ident.

	  }, {
	    key: "enterIdent",
	    value: function enterIdent(ctx) {} // Exit a parse tree produced by Protobuf3Parser#ident.

	  }, {
	    key: "exitIdent",
	    value: function exitIdent(ctx) {} // Enter a parse tree produced by Protobuf3Parser#fullIdent.

	  }, {
	    key: "enterFullIdent",
	    value: function enterFullIdent(ctx) {} // Exit a parse tree produced by Protobuf3Parser#fullIdent.

	  }, {
	    key: "exitFullIdent",
	    value: function exitFullIdent(ctx) {} // Enter a parse tree produced by Protobuf3Parser#messageName.

	  }, {
	    key: "enterMessageName",
	    value: function enterMessageName(ctx) {} // Exit a parse tree produced by Protobuf3Parser#messageName.

	  }, {
	    key: "exitMessageName",
	    value: function exitMessageName(ctx) {} // Enter a parse tree produced by Protobuf3Parser#enumName.

	  }, {
	    key: "enterEnumName",
	    value: function enterEnumName(ctx) {} // Exit a parse tree produced by Protobuf3Parser#enumName.

	  }, {
	    key: "exitEnumName",
	    value: function exitEnumName(ctx) {} // Enter a parse tree produced by Protobuf3Parser#fieldName.

	  }, {
	    key: "enterFieldName",
	    value: function enterFieldName(ctx) {} // Exit a parse tree produced by Protobuf3Parser#fieldName.

	  }, {
	    key: "exitFieldName",
	    value: function exitFieldName(ctx) {} // Enter a parse tree produced by Protobuf3Parser#oneofName.

	  }, {
	    key: "enterOneofName",
	    value: function enterOneofName(ctx) {} // Exit a parse tree produced by Protobuf3Parser#oneofName.

	  }, {
	    key: "exitOneofName",
	    value: function exitOneofName(ctx) {} // Enter a parse tree produced by Protobuf3Parser#mapName.

	  }, {
	    key: "enterMapName",
	    value: function enterMapName(ctx) {} // Exit a parse tree produced by Protobuf3Parser#mapName.

	  }, {
	    key: "exitMapName",
	    value: function exitMapName(ctx) {} // Enter a parse tree produced by Protobuf3Parser#serviceName.

	  }, {
	    key: "enterServiceName",
	    value: function enterServiceName(ctx) {} // Exit a parse tree produced by Protobuf3Parser#serviceName.

	  }, {
	    key: "exitServiceName",
	    value: function exitServiceName(ctx) {} // Enter a parse tree produced by Protobuf3Parser#rpcName.

	  }, {
	    key: "enterRpcName",
	    value: function enterRpcName(ctx) {} // Exit a parse tree produced by Protobuf3Parser#rpcName.

	  }, {
	    key: "exitRpcName",
	    value: function exitRpcName(ctx) {} // Enter a parse tree produced by Protobuf3Parser#messageType.

	  }, {
	    key: "enterMessageType",
	    value: function enterMessageType(ctx) {} // Exit a parse tree produced by Protobuf3Parser#messageType.

	  }, {
	    key: "exitMessageType",
	    value: function exitMessageType(ctx) {} // Enter a parse tree produced by Protobuf3Parser#enumType.

	  }, {
	    key: "enterEnumType",
	    value: function enterEnumType(ctx) {} // Exit a parse tree produced by Protobuf3Parser#enumType.

	  }, {
	    key: "exitEnumType",
	    value: function exitEnumType(ctx) {} // Enter a parse tree produced by Protobuf3Parser#intLit.

	  }, {
	    key: "enterIntLit",
	    value: function enterIntLit(ctx) {} // Exit a parse tree produced by Protobuf3Parser#intLit.

	  }, {
	    key: "exitIntLit",
	    value: function exitIntLit(ctx) {} // Enter a parse tree produced by Protobuf3Parser#strLit.

	  }, {
	    key: "enterStrLit",
	    value: function enterStrLit(ctx) {} // Exit a parse tree produced by Protobuf3Parser#strLit.

	  }, {
	    key: "exitStrLit",
	    value: function exitStrLit(ctx) {} // Enter a parse tree produced by Protobuf3Parser#boolLit.

	  }, {
	    key: "enterBoolLit",
	    value: function enterBoolLit(ctx) {} // Exit a parse tree produced by Protobuf3Parser#boolLit.

	  }, {
	    key: "exitBoolLit",
	    value: function exitBoolLit(ctx) {} // Enter a parse tree produced by Protobuf3Parser#floatLit.

	  }, {
	    key: "enterFloatLit",
	    value: function enterFloatLit(ctx) {} // Exit a parse tree produced by Protobuf3Parser#floatLit.

	  }, {
	    key: "exitFloatLit",
	    value: function exitFloatLit(ctx) {} // Enter a parse tree produced by Protobuf3Parser#keywords.

	  }, {
	    key: "enterKeywords",
	    value: function enterKeywords(ctx) {} // Exit a parse tree produced by Protobuf3Parser#keywords.

	  }, {
	    key: "exitKeywords",
	    value: function exitKeywords(ctx) {}
	  }]);

	  return Protobuf3Listener;
	}(_antlr["default"].tree.ParseTreeListener);

	exports["default"] = Protobuf3Listener;
} (Protobuf3Listener$1));

var Protobuf3Listener = /*@__PURE__*/getDefaultExportFromCjs(Protobuf3Listener$1);

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	var _Protobuf3Listener = _interopRequireDefault(Protobuf3Listener$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var serializedATN = ["\x03\u608B\uA72A\u8133\uB9ED\u417C\u3BE7\u7786", "\u5964\x03F\u01EF\x04\x02\t\x02\x04\x03\t\x03\x04\x04", "\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07\t\x07", "\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\x0B\t\x0B\x04\f\t\f", "\x04\r\t\r\x04\x0E\t\x0E\x04\x0F\t\x0F\x04\x10\t\x10", "\x04\x11\t\x11\x04\x12\t\x12\x04\x13\t\x13\x04\x14", "\t\x14\x04\x15\t\x15\x04\x16\t\x16\x04\x17\t\x17", "\x04\x18\t\x18\x04\x19\t\x19\x04\x1A\t\x1A\x04\x1B", "\t\x1B\x04\x1C\t\x1C\x04\x1D\t\x1D\x04\x1E\t\x1E", "\x04\x1F\t\x1F\x04 \t \x04!\t!\x04\"\t\"\x04#\t#\x04", "$\t$\x04%\t%\x04&\t&\x04'\t'\x04(\t(\x04)\t)\x04*\t*\x04", "+\t+\x04,\t,\x04-\t-\x04.\t.\x04/\t/\x040\t0\x041\t1\x04", "2\t2\x043\t3\x044\t4\x045\t5\x046\t6\x03\x02\x03\x02", "\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x07\x02", "t\n\x02\f\x02\x0E\x02w\x0B\x02\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x03\x03\x04\x03\x04\x05\x04\x80", "\n\x04\x03\x04\x03\x04\x03\x04\x03\x05\x03\x05", "\x03\x05\x03\x05\x03\x06\x03\x06\x03\x06\x03\x06", "\x03\x06\x03\x06\x03\x07\x03\x07\x03\x07\x03\x07", "\x03\x07\x03\x07\x05\x07\x95\n\x07\x05\x07\x97", "\n\x07\x03\b\x03\b\x03\b\x03\b\x06\b\x9D\n\b\r\b\x0E", "\b\x9E\x03\b\x03\b\x05\b\xA3\n\b\x03\t\x03\t\x03\n\x05", "\n\xA8\n\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\n", "\x03\n\x05\n\xB2\n\n\x03\n\x03\n\x03\x0B\x03\x0B\x03", "\x0B\x07\x0B\xB9\n\x0B\f\x0B\x0E\x0B\xBC\x0B\x0B", "\x03\f\x03\f\x03\f\x03\f\x03\r\x03\r\x03\x0E\x03\x0E", "\x03\x0E\x03\x0E\x03\x0E\x03\x0E\x07\x0E\xCA\n", "\x0E\f\x0E\x0E\x0E\xCD\x0B\x0E\x03\x0E\x03\x0E", "\x03\x0F\x03\x0F\x03\x0F\x03\x0F\x03\x0F\x03\x0F", "\x03\x0F\x03\x0F\x05\x0F\xD9\n\x0F\x03\x0F\x03", "\x0F\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10\x03", "\x10\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10\x03", "\x10\x03\x10\x05\x10\xEA\n\x10\x03\x10\x03\x10", "\x03\x11\x03\x11\x03\x12\x03\x12\x03\x12\x03\x12", "\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12", "\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12", "\x03\x12\x05\x12\u0101\n\x12\x03\x13\x03\x13\x03", "\x13\x05\x13\u0106\n\x13\x03\x13\x03\x13\x03\x14", "\x03\x14\x03\x14\x07\x14\u010D\n\x14\f\x14\x0E\x14", "\u0110\x0B\x14\x03\x15\x03\x15\x03\x15\x03\x15\x05", "\x15\u0116\n\x15\x05\x15\u0118\n\x15\x03\x16\x03\x16", "\x03\x16\x07\x16\u011D\n\x16\f\x16\x0E\x16\u0120\x0B", "\x16\x03\x17\x03\x17\x03\x17\x05\x17\u0125\n\x17", "\x03\x18\x03\x18\x03\x18\x03\x18\x03\x19\x03\x19", "\x07\x19\u012D\n\x19\f\x19\x0E\x19\u0130\x0B\x19\x03", "\x19\x03\x19\x03\x1A\x03\x1A\x03\x1A\x05\x1A\u0137", "\n\x1A\x03\x1B\x03\x1B\x03\x1B\x05\x1B\u013C\n\x1B", "\x03\x1B\x03\x1B\x05\x1B\u0140\n\x1B\x03\x1B\x03", "\x1B\x03\x1C\x03\x1C\x03\x1C\x03\x1C\x07\x1C\u0148", "\n\x1C\f\x1C\x0E\x1C\u014B\x0B\x1C\x03\x1C\x03\x1C", "\x03\x1D\x03\x1D\x03\x1D\x03\x1D\x03\x1E\x03\x1E", "\x03\x1E\x03\x1E\x03\x1F\x03\x1F\x07\x1F\u0159\n", "\x1F\f\x1F\x0E\x1F\u015C\x0B\x1F\x03\x1F\x03\x1F", "\x03 \x03 \x03 \x03 \x03 \x03 \x03 \x03 \x05 \u0168", "\n \x03!\x03!\x03!\x03!\x07!\u016E\n!\f!\x0E!\u0171\x0B", "!\x03!\x03!\x03\"\x03\"\x03\"\x05\"\u0178\n\"\x03#\x03", "#\x03#\x03#\x05#\u017E\n#\x03#\x03#\x03#\x03#\x03#\x05", "#\u0185\n#\x03#\x03#\x03#\x03#\x03#\x07#\u018C\n#\f#\x0E", "#\u018F\x0B#\x03#\x03#\x05#\u0193\n#\x03$\x03$\x05$\u0197", "\n$\x03$\x03$\x05$\u019B\n$\x03$\x03$\x03$\x03$\x05", "$\u01A1\n$\x03%\x03%\x03%\x03%\x03%\x07%\u01A8\n%\f%\x0E", "%\u01AB\x0B%\x03%\x03%\x03&\x03&\x03'\x03'\x05'\u01B3", "\n'\x03(\x03(\x03(\x07(\u01B8\n(\f(\x0E(\u01BB\x0B(\x03", ")\x03)\x03*\x03*\x03+\x03+\x03,\x03,\x03-\x03-\x03", ".\x03.\x03/\x03/\x030\x050\u01CC\n0\x030\x030\x030\x07", "0\u01D1\n0\f0\x0E0\u01D4\x0B0\x030\x030\x031\x051\u01D9", "\n1\x031\x031\x031\x071\u01DE\n1\f1\x0E1\u01E1\x0B1\x03", "1\x031\x032\x032\x033\x033\x034\x034\x035\x035\x03", "6\x036\x036\x02\x027\x02\x04\x06\b\n\f\x0E\x10\x12", "\x14\x16\x18\x1A\x1C\x1E \"$&(*,.02468:<>@BDFHJLNPRTVXZ", "\\^`bdfhj\x02\t\x03\x02./\x03\x02\x0F\x10\x03\x02", "\x03\x0B\x03\x02\x16!\x03\x02=>\x04\x02./??\x05", "\x02\f\r\x0F-@@\x02\u0207\x02l\x03\x02\x02\x02\x04", "x\x03\x02\x02\x02\x06}\x03\x02\x02\x02\b\x84\x03", "\x02\x02\x02\n\x88\x03\x02\x02\x02\f\x96\x03\x02", "\x02\x02\x0E\x98\x03\x02\x02\x02\x10\xA4\x03\x02", "\x02\x02\x12\xA7\x03\x02\x02\x02\x14\xB5\x03\x02", "\x02\x02\x16\xBD\x03\x02\x02\x02\x18\xC1\x03\x02", "\x02\x02\x1A\xC3\x03\x02\x02\x02\x1C\xD0\x03\x02", "\x02\x02\x1E\xDC\x03\x02\x02\x02 \xED\x03\x02", "\x02\x02\"\u0100\x03\x02\x02\x02$\u0102\x03\x02\x02", "\x02&\u0109\x03\x02\x02\x02(\u0111\x03\x02\x02\x02", "*\u0119\x03\x02\x02\x02,\u0124\x03\x02\x02\x02.\u0126", "\x03\x02\x02\x020\u012A\x03\x02\x02\x022\u0136\x03", "\x02\x02\x024\u0138\x03\x02\x02\x026\u0143\x03\x02", "\x02\x028\u014E\x03\x02\x02\x02:\u0152\x03\x02\x02", "\x02<\u0156\x03\x02\x02\x02>\u0167\x03\x02\x02\x02", "@\u0169\x03\x02\x02\x02B\u0177\x03\x02\x02\x02D\u0179", "\x03\x02\x02\x02F\u01A0\x03\x02\x02\x02H\u01A2\x03", "\x02\x02\x02J\u01AE\x03\x02\x02\x02L\u01B2\x03\x02", "\x02\x02N\u01B4\x03\x02\x02\x02P\u01BC\x03\x02\x02", "\x02R\u01BE\x03\x02\x02\x02T\u01C0\x03\x02\x02\x02", "V\u01C2\x03\x02\x02\x02X\u01C4\x03\x02\x02\x02Z\u01C6", "\x03\x02\x02\x02\\\u01C8\x03\x02\x02\x02^\u01CB\x03", "\x02\x02\x02`\u01D8\x03\x02\x02\x02b\u01E4\x03\x02", "\x02\x02d\u01E6\x03\x02\x02\x02f\u01E8\x03\x02\x02", "\x02h\u01EA\x03\x02\x02\x02j\u01EC\x03\x02\x02\x02", "lu\x05\x04\x03\x02mt\x05\x06\x04\x02nt\x05\b\x05", "\x02ot\x05\n\x06\x02pt\x05\x0E\b\x02qt\x05,\x17\x02", "rt\x05J&\x02sm\x03\x02\x02\x02sn\x03\x02\x02\x02", "so\x03\x02\x02\x02sp\x03\x02\x02\x02sq\x03\x02\x02", "\x02sr\x03\x02\x02\x02tw\x03\x02\x02\x02us\x03\x02", "\x02\x02uv\x03\x02\x02\x02v\x03\x03\x02\x02\x02", "wu\x03\x02\x02\x02xy\x07\f\x02\x02yz\x071\x02\x02", "z{\t\x02\x02\x02{|\x070\x02\x02|\x05\x03\x02\x02", "\x02}\x7F\x07\r\x02\x02~\x80\t\x03\x02\x02\x7F~", "\x03\x02\x02\x02\x7F\x80\x03\x02\x02\x02\x80\x81", "\x03\x02\x02\x02\x81\x82\x05d3\x02\x82\x83\x07", "0\x02\x02\x83\x07\x03\x02\x02\x02\x84\x85\x07", "\x11\x02\x02\x85\x86\x05N(\x02\x86\x87\x070\x02", "\x02\x87\t\x03\x02\x02\x02\x88\x89\x07\x12\x02", "\x02\x89\x8A\x05\f\x07\x02\x8A\x8B\x071\x02\x02", "\x8B\x8C\x05F$\x02\x8C\x8D\x070\x02\x02\x8D\x0B", "\x03\x02\x02\x02\x8E\x97\x05N(\x02\x8F\x90\x07", "2\x02\x02\x90\x91\x05N(\x02\x91\x94\x073\x02\x02", "\x92\x93\x07:\x02\x02\x93\x95\x05N(\x02\x94\x92", "\x03\x02\x02\x02\x94\x95\x03\x02\x02\x02\x95\x97", "\x03\x02\x02\x02\x96\x8E\x03\x02\x02\x02\x96\x8F", "\x03\x02\x02\x02\x97\r\x03\x02\x02\x02\x98\x99", "\x07\x0E\x02\x02\x99\x9A\x05\x10\t\x02\x9A\x9C", "\x076\x02\x02\x9B\x9D\x05\x12\n\x02\x9C\x9B\x03", "\x02\x02\x02\x9D\x9E\x03\x02\x02\x02\x9E\x9C\x03", "\x02\x02\x02\x9E\x9F\x03\x02\x02\x02\x9F\xA0\x03", "\x02\x02\x02\xA0\xA2\x077\x02\x02\xA1\xA3\x07", "0\x02\x02\xA2\xA1\x03\x02\x02\x02\xA2\xA3\x03", "\x02\x02\x02\xA3\x0F\x03\x02\x02\x02\xA4\xA5\t", "\x04\x02\x02\xA5\x11\x03\x02\x02\x02\xA6\xA8\x07", "\x13\x02\x02\xA7\xA6\x03\x02\x02\x02\xA7\xA8\x03", "\x02\x02\x02\xA8\xA9\x03\x02\x02\x02\xA9\xAA\x05", "\"\x12\x02\xAA\xAB\x05T+\x02\xAB\xAC\x071\x02\x02", "\xAC\xB1\x05\x18\r\x02\xAD\xAE\x074\x02\x02\xAE", "\xAF\x05\x14\x0B\x02\xAF\xB0\x075\x02\x02\xB0", "\xB2\x03\x02\x02\x02\xB1\xAD\x03\x02\x02\x02\xB1", "\xB2\x03\x02\x02\x02\xB2\xB3\x03\x02\x02\x02\xB3", "\xB4\x070\x02\x02\xB4\x13\x03\x02\x02\x02\xB5", "\xBA\x05\x16\f\x02\xB6\xB7\x07;\x02\x02\xB7\xB9", "\x05\x16\f\x02\xB8\xB6\x03\x02\x02\x02\xB9\xBC", "\x03\x02\x02\x02\xBA\xB8\x03\x02\x02\x02\xBA\xBB", "\x03\x02\x02\x02\xBB\x15\x03\x02\x02\x02\xBC\xBA", "\x03\x02\x02\x02\xBD\xBE\x05\f\x07\x02\xBE\xBF", "\x071\x02\x02\xBF\xC0\x05F$\x02\xC0\x17\x03\x02", "\x02\x02\xC1\xC2\x05b2\x02\xC2\x19\x03\x02\x02", "\x02\xC3\xC4\x07\x14\x02\x02\xC4\xC5\x05V,\x02", "\xC5\xCB\x076\x02\x02\xC6\xCA\x05\n\x06\x02\xC7", "\xCA\x05\x1C\x0F\x02\xC8\xCA\x05J&\x02\xC9\xC6", "\x03\x02\x02\x02\xC9\xC7\x03\x02\x02\x02\xC9\xC8", "\x03\x02\x02\x02\xCA\xCD\x03\x02\x02\x02\xCB\xC9", "\x03\x02\x02\x02\xCB\xCC\x03\x02\x02\x02\xCC\xCE", "\x03\x02\x02\x02\xCD\xCB\x03\x02\x02\x02\xCE\xCF", "\x077\x02\x02\xCF\x1B\x03\x02\x02\x02\xD0\xD1", "\x05\"\x12\x02\xD1\xD2\x05T+\x02\xD2\xD3\x071\x02", "\x02\xD3\xD8\x05\x18\r\x02\xD4\xD5\x074\x02\x02", "\xD5\xD6\x05\x14\x0B\x02\xD6\xD7\x075\x02\x02", "\xD7\xD9\x03\x02\x02\x02\xD8\xD4\x03\x02\x02\x02", "\xD8\xD9\x03\x02\x02\x02\xD9\xDA\x03\x02\x02\x02", "\xDA\xDB\x070\x02\x02\xDB\x1D\x03\x02\x02\x02", "\xDC\xDD\x07\x15\x02\x02\xDD\xDE\x078\x02\x02", "\xDE\xDF\x05 \x11\x02\xDF\xE0\x07;\x02\x02\xE0", "\xE1\x05\"\x12\x02\xE1\xE2\x079\x02\x02\xE2\xE3", "\x05X-\x02\xE3\xE4\x071\x02\x02\xE4\xE9\x05\x18", "\r\x02\xE5\xE6\x074\x02\x02\xE6\xE7\x05\x14\x0B", "\x02\xE7\xE8\x075\x02\x02\xE8\xEA\x03\x02\x02", "\x02\xE9\xE5\x03\x02\x02\x02\xE9\xEA\x03\x02\x02", "\x02\xEA\xEB\x03\x02\x02\x02\xEB\xEC\x070\x02", "\x02\xEC\x1F\x03\x02\x02\x02\xED\xEE\t\x05\x02", "\x02\xEE!\x03\x02\x02\x02\xEF\u0101\x07\"\x02\x02", "\xF0\u0101\x07#\x02\x02\xF1\u0101\x07\x16\x02\x02", "\xF2\u0101\x07\x17\x02\x02\xF3\u0101\x07\x18\x02\x02", "\xF4\u0101\x07\x19\x02\x02\xF5\u0101\x07\x1A\x02\x02", "\xF6\u0101\x07\x1B\x02\x02\xF7\u0101\x07\x1C\x02\x02", "\xF8\u0101\x07\x1D\x02\x02\xF9\u0101\x07\x1E\x02\x02", "\xFA\u0101\x07\x1F\x02\x02\xFB\u0101\x07 \x02\x02", "\xFC\u0101\x07!\x02\x02\xFD\u0101\x07$\x02\x02\xFE", "\u0101\x05^0\x02\xFF\u0101\x05`1\x02\u0100\xEF\x03\x02", "\x02\x02\u0100\xF0\x03\x02\x02\x02\u0100\xF1\x03\x02", "\x02\x02\u0100\xF2\x03\x02\x02\x02\u0100\xF3\x03\x02", "\x02\x02\u0100\xF4\x03\x02\x02\x02\u0100\xF5\x03\x02", "\x02\x02\u0100\xF6\x03\x02\x02\x02\u0100\xF7\x03\x02", "\x02\x02\u0100\xF8\x03\x02\x02\x02\u0100\xF9\x03\x02", "\x02\x02\u0100\xFA\x03\x02\x02\x02\u0100\xFB\x03\x02", "\x02\x02\u0100\xFC\x03\x02\x02\x02\u0100\xFD\x03\x02", "\x02\x02\u0100\xFE\x03\x02\x02\x02\u0100\xFF\x03\x02", "\x02\x02\u0101#\x03\x02\x02\x02\u0102\u0105\x07%\x02", "\x02\u0103\u0106\x05&\x14\x02\u0104\u0106\x05*\x16\x02", "\u0105\u0103\x03\x02\x02\x02\u0105\u0104\x03\x02\x02\x02", "\u0106\u0107\x03\x02\x02\x02\u0107\u0108\x070\x02\x02", "\u0108%\x03\x02\x02\x02\u0109\u010E\x05(\x15\x02\u010A", "\u010B\x07;\x02\x02\u010B\u010D\x05(\x15\x02\u010C\u010A", "\x03\x02\x02\x02\u010D\u0110\x03\x02\x02\x02\u010E\u010C", "\x03\x02\x02\x02\u010E\u010F\x03\x02\x02\x02\u010F'", "\x03\x02\x02\x02\u0110\u010E\x03\x02\x02\x02\u0111\u0117", "\x05b2\x02\u0112\u0115\x07&\x02\x02\u0113\u0116\x05b2\x02", "\u0114\u0116\x07'\x02\x02\u0115\u0113\x03\x02\x02\x02", "\u0115\u0114\x03\x02\x02\x02\u0116\u0118\x03\x02\x02\x02", "\u0117\u0112\x03\x02\x02\x02\u0117\u0118\x03\x02\x02\x02", "\u0118)\x03\x02\x02\x02\u0119\u011E\x05d3\x02\u011A\u011B", "\x07;\x02\x02\u011B\u011D\x05d3\x02\u011C\u011A\x03\x02", "\x02\x02\u011D\u0120\x03\x02\x02\x02\u011E\u011C\x03\x02", "\x02\x02\u011E\u011F\x03\x02\x02\x02\u011F+\x03\x02", "\x02\x02\u0120\u011E\x03\x02\x02\x02\u0121\u0125\x05:", "\x1E\x02\u0122\u0125\x05.\x18\x02\u0123\u0125\x05@!\x02", "\u0124\u0121\x03\x02\x02\x02\u0124\u0122\x03\x02\x02\x02", "\u0124\u0123\x03\x02\x02\x02\u0125-\x03\x02\x02\x02", "\u0126\u0127\x07(\x02\x02\u0127\u0128\x05R*\x02\u0128\u0129", "\x050\x19\x02\u0129/\x03\x02\x02\x02\u012A\u012E\x07", "6\x02\x02\u012B\u012D\x052\x1A\x02\u012C\u012B\x03\x02", "\x02\x02\u012D\u0130\x03\x02\x02\x02\u012E\u012C\x03\x02", "\x02\x02\u012E\u012F\x03\x02\x02\x02\u012F\u0131\x03\x02", "\x02\x02\u0130\u012E\x03\x02\x02\x02\u0131\u0132\x077", "\x02\x02\u01321\x03\x02\x02\x02\u0133\u0137\x05\n\x06", "\x02\u0134\u0137\x054\x1B\x02\u0135\u0137\x05J&\x02\u0136", "\u0133\x03\x02\x02\x02\u0136\u0134\x03\x02\x02\x02\u0136", "\u0135\x03\x02\x02\x02\u01373\x03\x02\x02\x02\u0138", "\u0139\x05L'\x02\u0139\u013B\x071\x02\x02\u013A\u013C\x07", ">\x02\x02\u013B\u013A\x03\x02\x02\x02\u013B\u013C\x03", "\x02\x02\x02\u013C\u013D\x03\x02\x02\x02\u013D\u013F\x05", "b2\x02\u013E\u0140\x056\x1C\x02\u013F\u013E\x03\x02\x02", "\x02\u013F\u0140\x03\x02\x02\x02\u0140\u0141\x03\x02\x02", "\x02\u0141\u0142\x070\x02\x02\u01425\x03\x02\x02\x02", "\u0143\u0144\x074\x02\x02\u0144\u0149\x058\x1D\x02\u0145", "\u0146\x07;\x02\x02\u0146\u0148\x058\x1D\x02\u0147\u0145", "\x03\x02\x02\x02\u0148\u014B\x03\x02\x02\x02\u0149\u0147", "\x03\x02\x02\x02\u0149\u014A\x03\x02\x02\x02\u014A\u014C", "\x03\x02\x02\x02\u014B\u0149\x03\x02\x02\x02\u014C\u014D", "\x075\x02\x02\u014D7\x03\x02\x02\x02\u014E\u014F\x05", "\f\x07\x02\u014F\u0150\x071\x02\x02\u0150\u0151\x05F$\x02", "\u01519\x03\x02\x02\x02\u0152\u0153\x07)\x02\x02\u0153", "\u0154\x05P)\x02\u0154\u0155\x05<\x1F\x02\u0155;\x03\x02", "\x02\x02\u0156\u015A\x076\x02\x02\u0157\u0159\x05> \x02", "\u0158\u0157\x03\x02\x02\x02\u0159\u015C\x03\x02\x02\x02", "\u015A\u0158\x03\x02\x02\x02\u015A\u015B\x03\x02\x02\x02", "\u015B\u015D\x03\x02\x02\x02\u015C\u015A\x03\x02\x02\x02", "\u015D\u015E\x077\x02\x02\u015E=\x03\x02\x02\x02\u015F", "\u0168\x05\x12\n\x02\u0160\u0168\x05.\x18\x02\u0161\u0168", "\x05:\x1E\x02\u0162\u0168\x05\n\x06\x02\u0163\u0168\x05", "\x1A\x0E\x02\u0164\u0168\x05\x1E\x10\x02\u0165\u0168\x05", "$\x13\x02\u0166\u0168\x05J&\x02\u0167\u015F\x03\x02\x02", "\x02\u0167\u0160\x03\x02\x02\x02\u0167\u0161\x03\x02\x02", "\x02\u0167\u0162\x03\x02\x02\x02\u0167\u0163\x03\x02\x02", "\x02\u0167\u0164\x03\x02\x02\x02\u0167\u0165\x03\x02\x02", "\x02\u0167\u0166\x03\x02\x02\x02\u0168?\x03\x02\x02", "\x02\u0169\u016A\x07*\x02\x02\u016A\u016B\x05Z.\x02\u016B", "\u016F\x076\x02\x02\u016C\u016E\x05B\"\x02\u016D\u016C\x03", "\x02\x02\x02\u016E\u0171\x03\x02\x02\x02\u016F\u016D\x03", "\x02\x02\x02\u016F\u0170\x03\x02\x02\x02\u0170\u0172\x03", "\x02\x02\x02\u0171\u016F\x03\x02\x02\x02\u0172\u0173\x07", "7\x02\x02\u0173A\x03\x02\x02\x02\u0174\u0178\x05\n\x06", "\x02\u0175\u0178\x05D#\x02\u0176\u0178\x05J&\x02\u0177\u0174", "\x03\x02\x02\x02\u0177\u0175\x03\x02\x02\x02\u0177\u0176", "\x03\x02\x02\x02\u0178C\x03\x02\x02\x02\u0179\u017A", "\x07+\x02\x02\u017A\u017B\x05\\/\x02\u017B\u017D\x072\x02", "\x02\u017C\u017E\x07,\x02\x02\u017D\u017C\x03\x02\x02", "\x02\u017D\u017E\x03\x02\x02\x02\u017E\u017F\x03\x02\x02", "\x02\u017F\u0180\x05^0\x02\u0180\u0181\x073\x02\x02\u0181", "\u0182\x07-\x02\x02\u0182\u0184\x072\x02\x02\u0183\u0185", "\x07,\x02\x02\u0184\u0183\x03\x02\x02\x02\u0184\u0185", "\x03\x02\x02\x02\u0185\u0186\x03\x02\x02\x02\u0186\u0187", "\x05^0\x02\u0187\u0192\x073\x02\x02\u0188\u018D\x076\x02", "\x02\u0189\u018C\x05\n\x06\x02\u018A\u018C\x05J&\x02\u018B", "\u0189\x03\x02\x02\x02\u018B\u018A\x03\x02\x02\x02\u018C", "\u018F\x03\x02\x02\x02\u018D\u018B\x03\x02\x02\x02\u018D", "\u018E\x03\x02\x02\x02\u018E\u0190\x03\x02\x02\x02\u018F", "\u018D\x03\x02\x02\x02\u0190\u0193\x077\x02\x02\u0191", "\u0193\x070\x02\x02\u0192\u0188\x03\x02\x02\x02\u0192", "\u0191\x03\x02\x02\x02\u0193E\x03\x02\x02\x02\u0194", "\u01A1\x05N(\x02\u0195\u0197\t\x06\x02\x02\u0196\u0195\x03", "\x02\x02\x02\u0196\u0197\x03\x02\x02\x02\u0197\u0198\x03", "\x02\x02\x02\u0198\u01A1\x05b2\x02\u0199\u019B\t\x06\x02", "\x02\u019A\u0199\x03\x02\x02\x02\u019A\u019B\x03\x02\x02", "\x02\u019B\u019C\x03\x02\x02\x02\u019C\u01A1\x05h5\x02", "\u019D\u01A1\x05d3\x02\u019E\u01A1\x05f4\x02\u019F\u01A1\x05", "H%\x02\u01A0\u0194\x03\x02\x02\x02\u01A0\u0196\x03\x02", "\x02\x02\u01A0\u019A\x03\x02\x02\x02\u01A0\u019D\x03\x02", "\x02\x02\u01A0\u019E\x03\x02\x02\x02\u01A0\u019F\x03\x02", "\x02\x02\u01A1G\x03\x02\x02\x02\u01A2\u01A9\x076\x02", "\x02\u01A3\u01A4\x05L'\x02\u01A4\u01A5\x07<\x02\x02\u01A5", "\u01A6\x05F$\x02\u01A6\u01A8\x03\x02\x02\x02\u01A7\u01A3", "\x03\x02\x02\x02\u01A8\u01AB\x03\x02\x02\x02\u01A9\u01A7", "\x03\x02\x02\x02\u01A9\u01AA\x03\x02\x02\x02\u01AA\u01AC", "\x03\x02\x02\x02\u01AB\u01A9\x03\x02\x02\x02\u01AC\u01AD", "\x077\x02\x02\u01ADI\x03\x02\x02\x02\u01AE\u01AF\x07", "0\x02\x02\u01AFK\x03\x02\x02\x02\u01B0\u01B3\x07C\x02", "\x02\u01B1\u01B3\x05j6\x02\u01B2\u01B0\x03\x02\x02\x02", "\u01B2\u01B1\x03\x02\x02\x02\u01B3M\x03\x02\x02\x02", "\u01B4\u01B9\x05L'\x02\u01B5\u01B6\x07:\x02\x02\u01B6\u01B8", "\x05L'\x02\u01B7\u01B5\x03\x02\x02\x02\u01B8\u01BB\x03", "\x02\x02\x02\u01B9\u01B7\x03\x02\x02\x02\u01B9\u01BA\x03", "\x02\x02\x02\u01BAO\x03\x02\x02\x02\u01BB\u01B9\x03", "\x02\x02\x02\u01BC\u01BD\x05L'\x02\u01BDQ\x03\x02\x02", "\x02\u01BE\u01BF\x05L'\x02\u01BFS\x03\x02\x02\x02\u01C0", "\u01C1\x05L'\x02\u01C1U\x03\x02\x02\x02\u01C2\u01C3\x05", "L'\x02\u01C3W\x03\x02\x02\x02\u01C4\u01C5\x05L'\x02", "\u01C5Y\x03\x02\x02\x02\u01C6\u01C7\x05L'\x02\u01C7[\x03", "\x02\x02\x02\u01C8\u01C9\x05L'\x02\u01C9]\x03\x02\x02", "\x02\u01CA\u01CC\x07:\x02\x02\u01CB\u01CA\x03\x02\x02", "\x02\u01CB\u01CC\x03\x02\x02\x02\u01CC\u01D2\x03\x02\x02", "\x02\u01CD\u01CE\x05L'\x02\u01CE\u01CF\x07:\x02\x02\u01CF", "\u01D1\x03\x02\x02\x02\u01D0\u01CD\x03\x02\x02\x02\u01D1", "\u01D4\x03\x02\x02\x02\u01D2\u01D0\x03\x02\x02\x02\u01D2", "\u01D3\x03\x02\x02\x02\u01D3\u01D5\x03\x02\x02\x02\u01D4", "\u01D2\x03\x02\x02\x02\u01D5\u01D6\x05P)\x02\u01D6_\x03", "\x02\x02\x02\u01D7\u01D9\x07:\x02\x02\u01D8\u01D7\x03", "\x02\x02\x02\u01D8\u01D9\x03\x02\x02\x02\u01D9\u01DF\x03", "\x02\x02\x02\u01DA\u01DB\x05L'\x02\u01DB\u01DC\x07:\x02", "\x02\u01DC\u01DE\x03\x02\x02\x02\u01DD\u01DA\x03\x02\x02", "\x02\u01DE\u01E1\x03\x02\x02\x02\u01DF\u01DD\x03\x02\x02", "\x02\u01DF\u01E0\x03\x02\x02\x02\u01E0\u01E2\x03\x02\x02", "\x02\u01E1\u01DF\x03\x02\x02\x02\u01E2\u01E3\x05R*\x02", "\u01E3a\x03\x02\x02\x02\u01E4\u01E5\x07B\x02\x02\u01E5", "c\x03\x02\x02\x02\u01E6\u01E7\t\x07\x02\x02\u01E7e\x03", "\x02\x02\x02\u01E8\u01E9\x07@\x02\x02\u01E9g\x03\x02", "\x02\x02\u01EA\u01EB\x07A\x02\x02\u01EBi\x03\x02\x02", "\x02\u01EC\u01ED\t\b\x02\x02\u01EDk\x03\x02\x02\x02/s", "u\x7F\x94\x96\x9E\xA2\xA7\xB1\xBA\xC9\xCB\xD8", "\xE9\u0100\u0105\u010E\u0115\u0117\u011E\u0124\u012E\u0136\u013B\u013F", "\u0149\u015A\u0167\u016F\u0177\u017D\u0184\u018B\u018D\u0192\u0196\u019A", "\u01A0\u01A9\u01B2\u01B9\u01CB\u01D2\u01D8\u01DF"].join("");
	var atn = new _antlr["default"].atn.ATNDeserializer().deserialize(serializedATN);
	var decisionsToDFA = atn.decisionToState.map(function (ds, index) {
	  return new _antlr["default"].dfa.DFA(ds, index);
	});
	var sharedContextCache = new _antlr["default"].PredictionContextCache();

	var Protobuf3Parser = /*#__PURE__*/function (_antlr4$Parser) {
	  _inherits(Protobuf3Parser, _antlr4$Parser);

	  var _super = _createSuper(Protobuf3Parser);

	  function Protobuf3Parser(input) {
	    var _this;

	    _classCallCheck(this, Protobuf3Parser);

	    _this = _super.call(this, input);
	    _this._interp = new _antlr["default"].atn.ParserATNSimulator(_assertThisInitialized(_this), atn, decisionsToDFA, sharedContextCache);
	    _this.ruleNames = Protobuf3Parser.ruleNames;
	    _this.literalNames = Protobuf3Parser.literalNames;
	    _this.symbolicNames = Protobuf3Parser.symbolicNames;
	    return _this;
	  }

	  _createClass(Protobuf3Parser, [{
	    key: "atn",
	    get: function get() {
	      return atn;
	    }
	  }, {
	    key: "proto",
	    value: function proto() {
	      var localctx = new ProtoContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 0, Protobuf3Parser.RULE_proto);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 106;
	        this.syntax();
	        this.state = 115;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la & ~0x1f) == 0 && (1 << _la & (1 << Protobuf3Parser.IMPORT | 1 << Protobuf3Parser.EXTEND | 1 << Protobuf3Parser.PACKAGE | 1 << Protobuf3Parser.OPTION)) !== 0 || (_la - 38 & ~0x1f) == 0 && (1 << _la - 38 & (1 << Protobuf3Parser.ENUM - 38 | 1 << Protobuf3Parser.MESSAGE - 38 | 1 << Protobuf3Parser.SERVICE - 38 | 1 << Protobuf3Parser.SEMI - 38)) !== 0) {
	          this.state = 113;

	          this._errHandler.sync(this);

	          switch (this._input.LA(1)) {
	            case Protobuf3Parser.IMPORT:
	              this.state = 107;
	              this.importStatement();
	              break;

	            case Protobuf3Parser.PACKAGE:
	              this.state = 108;
	              this.packageStatement();
	              break;

	            case Protobuf3Parser.OPTION:
	              this.state = 109;
	              this.optionStatement();
	              break;

	            case Protobuf3Parser.EXTEND:
	              this.state = 110;
	              this.extendsStatement();
	              break;

	            case Protobuf3Parser.ENUM:
	            case Protobuf3Parser.MESSAGE:
	            case Protobuf3Parser.SERVICE:
	              this.state = 111;
	              this.topLevelDef();
	              break;

	            case Protobuf3Parser.SEMI:
	              this.state = 112;
	              this.emptyStatement();
	              break;

	            default:
	              throw new _antlr["default"].error.NoViableAltException(this);
	          }

	          this.state = 117;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "syntax",
	    value: function syntax() {
	      var localctx = new SyntaxContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 2, Protobuf3Parser.RULE_syntax);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 118;
	        this.match(Protobuf3Parser.SYNTAX);
	        this.state = 119;
	        this.match(Protobuf3Parser.EQ);
	        this.state = 120;
	        _la = this._input.LA(1);

	        if (!(_la === Protobuf3Parser.PROTO3_LIT_SINGLE || _la === Protobuf3Parser.PROTO3_LIT_DOBULE)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }

	        this.state = 121;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "importStatement",
	    value: function importStatement() {
	      var localctx = new ImportStatementContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 4, Protobuf3Parser.RULE_importStatement);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 123;
	        this.match(Protobuf3Parser.IMPORT);
	        this.state = 125;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.WEAK || _la === Protobuf3Parser.PUBLIC) {
	          this.state = 124;
	          _la = this._input.LA(1);

	          if (!(_la === Protobuf3Parser.WEAK || _la === Protobuf3Parser.PUBLIC)) {
	            this._errHandler.recoverInline(this);
	          } else {
	            this._errHandler.reportMatch(this);

	            this.consume();
	          }
	        }

	        this.state = 127;
	        this.strLit();
	        this.state = 128;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "packageStatement",
	    value: function packageStatement() {
	      var localctx = new PackageStatementContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 6, Protobuf3Parser.RULE_packageStatement);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 130;
	        this.match(Protobuf3Parser.PACKAGE);
	        this.state = 131;
	        this.fullIdent();
	        this.state = 132;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "optionStatement",
	    value: function optionStatement() {
	      var localctx = new OptionStatementContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 8, Protobuf3Parser.RULE_optionStatement);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 134;
	        this.match(Protobuf3Parser.OPTION);
	        this.state = 135;
	        this.optionName();
	        this.state = 136;
	        this.match(Protobuf3Parser.EQ);
	        this.state = 137;
	        this.constant();
	        this.state = 138;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "optionName",
	    value: function optionName() {
	      var localctx = new OptionNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 10, Protobuf3Parser.RULE_optionName);
	      var _la = 0; // Token type

	      try {
	        this.state = 148;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case Protobuf3Parser.SYNTAX:
	          case Protobuf3Parser.IMPORT:
	          case Protobuf3Parser.WEAK:
	          case Protobuf3Parser.PUBLIC:
	          case Protobuf3Parser.PACKAGE:
	          case Protobuf3Parser.OPTION:
	          case Protobuf3Parser.REPEATED:
	          case Protobuf3Parser.ONEOF:
	          case Protobuf3Parser.MAP:
	          case Protobuf3Parser.INT32:
	          case Protobuf3Parser.INT64:
	          case Protobuf3Parser.UINT32:
	          case Protobuf3Parser.UINT64:
	          case Protobuf3Parser.SINT32:
	          case Protobuf3Parser.SINT64:
	          case Protobuf3Parser.FIXED32:
	          case Protobuf3Parser.FIXED64:
	          case Protobuf3Parser.SFIXED32:
	          case Protobuf3Parser.SFIXED64:
	          case Protobuf3Parser.BOOL:
	          case Protobuf3Parser.STRING:
	          case Protobuf3Parser.DOUBLE:
	          case Protobuf3Parser.FLOAT:
	          case Protobuf3Parser.BYTES:
	          case Protobuf3Parser.RESERVED:
	          case Protobuf3Parser.TO:
	          case Protobuf3Parser.MAX:
	          case Protobuf3Parser.ENUM:
	          case Protobuf3Parser.MESSAGE:
	          case Protobuf3Parser.SERVICE:
	          case Protobuf3Parser.RPC:
	          case Protobuf3Parser.STREAM:
	          case Protobuf3Parser.RETURNS:
	          case Protobuf3Parser.BOOL_LIT:
	          case Protobuf3Parser.IDENTIFIER:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 140;
	            this.fullIdent();
	            break;

	          case Protobuf3Parser.LP:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 141;
	            this.match(Protobuf3Parser.LP);
	            this.state = 142;
	            this.fullIdent();
	            this.state = 143;
	            this.match(Protobuf3Parser.RP);
	            this.state = 146;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === Protobuf3Parser.DOT) {
	              this.state = 144;
	              this.match(Protobuf3Parser.DOT);
	              this.state = 145;
	              this.fullIdent();
	            }

	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "extendsStatement",
	    value: function extendsStatement() {
	      var localctx = new ExtendsStatementContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 12, Protobuf3Parser.RULE_extendsStatement);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 150;
	        this.match(Protobuf3Parser.EXTEND);
	        this.state = 151;
	        this.extendedIdentifier();
	        this.state = 152;
	        this.match(Protobuf3Parser.LC);
	        this.state = 154;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 153;
	          this.field();
	          this.state = 156;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la - 10 & ~0x1f) == 0 && (1 << _la - 10 & (1 << Protobuf3Parser.SYNTAX - 10 | 1 << Protobuf3Parser.IMPORT - 10 | 1 << Protobuf3Parser.WEAK - 10 | 1 << Protobuf3Parser.PUBLIC - 10 | 1 << Protobuf3Parser.PACKAGE - 10 | 1 << Protobuf3Parser.OPTION - 10 | 1 << Protobuf3Parser.REPEATED - 10 | 1 << Protobuf3Parser.ONEOF - 10 | 1 << Protobuf3Parser.MAP - 10 | 1 << Protobuf3Parser.INT32 - 10 | 1 << Protobuf3Parser.INT64 - 10 | 1 << Protobuf3Parser.UINT32 - 10 | 1 << Protobuf3Parser.UINT64 - 10 | 1 << Protobuf3Parser.SINT32 - 10 | 1 << Protobuf3Parser.SINT64 - 10 | 1 << Protobuf3Parser.FIXED32 - 10 | 1 << Protobuf3Parser.FIXED64 - 10 | 1 << Protobuf3Parser.SFIXED32 - 10 | 1 << Protobuf3Parser.SFIXED64 - 10 | 1 << Protobuf3Parser.BOOL - 10 | 1 << Protobuf3Parser.STRING - 10 | 1 << Protobuf3Parser.DOUBLE - 10 | 1 << Protobuf3Parser.FLOAT - 10 | 1 << Protobuf3Parser.BYTES - 10 | 1 << Protobuf3Parser.RESERVED - 10 | 1 << Protobuf3Parser.TO - 10 | 1 << Protobuf3Parser.MAX - 10 | 1 << Protobuf3Parser.ENUM - 10 | 1 << Protobuf3Parser.MESSAGE - 10 | 1 << Protobuf3Parser.SERVICE - 10 | 1 << Protobuf3Parser.RPC - 10)) !== 0 || (_la - 42 & ~0x1f) == 0 && (1 << _la - 42 & (1 << Protobuf3Parser.STREAM - 42 | 1 << Protobuf3Parser.RETURNS - 42 | 1 << Protobuf3Parser.DOT - 42 | 1 << Protobuf3Parser.BOOL_LIT - 42 | 1 << Protobuf3Parser.IDENTIFIER - 42)) !== 0);

	        this.state = 158;
	        this.match(Protobuf3Parser.RC);
	        this.state = 160;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 6, this._ctx);

	        if (la_ === 1) {
	          this.state = 159;
	          this.match(Protobuf3Parser.SEMI);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "extendedIdentifier",
	    value: function extendedIdentifier() {
	      var localctx = new ExtendedIdentifierContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 14, Protobuf3Parser.RULE_extendedIdentifier);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 162;
	        _la = this._input.LA(1);

	        if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << Protobuf3Parser.FIELD_OPTIONS | 1 << Protobuf3Parser.ENUM_OPTIONS | 1 << Protobuf3Parser.ENUM_VALUE_OPTIONS | 1 << Protobuf3Parser.EXTENSION_RANGE_OPTIONS | 1 << Protobuf3Parser.MESSAGE_OPTIONS | 1 << Protobuf3Parser.METHOD_OPTIONS | 1 << Protobuf3Parser.SERVICE_OPTIONS | 1 << Protobuf3Parser.FILE_OPTIONS | 1 << Protobuf3Parser.ONEOF_OPTIONS)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "field",
	    value: function field() {
	      var localctx = new FieldContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 16, Protobuf3Parser.RULE_field);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 165;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 7, this._ctx);

	        if (la_ === 1) {
	          this.state = 164;
	          this.match(Protobuf3Parser.REPEATED);
	        }

	        this.state = 167;
	        this.type_();
	        this.state = 168;
	        this.fieldName();
	        this.state = 169;
	        this.match(Protobuf3Parser.EQ);
	        this.state = 170;
	        this.fieldNumber();
	        this.state = 175;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.LB) {
	          this.state = 171;
	          this.match(Protobuf3Parser.LB);
	          this.state = 172;
	          this.fieldOptions();
	          this.state = 173;
	          this.match(Protobuf3Parser.RB);
	        }

	        this.state = 177;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldOptions",
	    value: function fieldOptions() {
	      var localctx = new FieldOptionsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 18, Protobuf3Parser.RULE_fieldOptions);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 179;
	        this.fieldOption();
	        this.state = 184;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === Protobuf3Parser.COMMA) {
	          this.state = 180;
	          this.match(Protobuf3Parser.COMMA);
	          this.state = 181;
	          this.fieldOption();
	          this.state = 186;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldOption",
	    value: function fieldOption() {
	      var localctx = new FieldOptionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 20, Protobuf3Parser.RULE_fieldOption);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 187;
	        this.optionName();
	        this.state = 188;
	        this.match(Protobuf3Parser.EQ);
	        this.state = 189;
	        this.constant();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldNumber",
	    value: function fieldNumber() {
	      var localctx = new FieldNumberContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 22, Protobuf3Parser.RULE_fieldNumber);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 191;
	        this.intLit();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "oneof",
	    value: function oneof() {
	      var localctx = new OneofContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 24, Protobuf3Parser.RULE_oneof);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 193;
	        this.match(Protobuf3Parser.ONEOF);
	        this.state = 194;
	        this.oneofName();
	        this.state = 195;
	        this.match(Protobuf3Parser.LC);
	        this.state = 201;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la - 10 & ~0x1f) == 0 && (1 << _la - 10 & (1 << Protobuf3Parser.SYNTAX - 10 | 1 << Protobuf3Parser.IMPORT - 10 | 1 << Protobuf3Parser.WEAK - 10 | 1 << Protobuf3Parser.PUBLIC - 10 | 1 << Protobuf3Parser.PACKAGE - 10 | 1 << Protobuf3Parser.OPTION - 10 | 1 << Protobuf3Parser.REPEATED - 10 | 1 << Protobuf3Parser.ONEOF - 10 | 1 << Protobuf3Parser.MAP - 10 | 1 << Protobuf3Parser.INT32 - 10 | 1 << Protobuf3Parser.INT64 - 10 | 1 << Protobuf3Parser.UINT32 - 10 | 1 << Protobuf3Parser.UINT64 - 10 | 1 << Protobuf3Parser.SINT32 - 10 | 1 << Protobuf3Parser.SINT64 - 10 | 1 << Protobuf3Parser.FIXED32 - 10 | 1 << Protobuf3Parser.FIXED64 - 10 | 1 << Protobuf3Parser.SFIXED32 - 10 | 1 << Protobuf3Parser.SFIXED64 - 10 | 1 << Protobuf3Parser.BOOL - 10 | 1 << Protobuf3Parser.STRING - 10 | 1 << Protobuf3Parser.DOUBLE - 10 | 1 << Protobuf3Parser.FLOAT - 10 | 1 << Protobuf3Parser.BYTES - 10 | 1 << Protobuf3Parser.RESERVED - 10 | 1 << Protobuf3Parser.TO - 10 | 1 << Protobuf3Parser.MAX - 10 | 1 << Protobuf3Parser.ENUM - 10 | 1 << Protobuf3Parser.MESSAGE - 10 | 1 << Protobuf3Parser.SERVICE - 10 | 1 << Protobuf3Parser.RPC - 10)) !== 0 || (_la - 42 & ~0x1f) == 0 && (1 << _la - 42 & (1 << Protobuf3Parser.STREAM - 42 | 1 << Protobuf3Parser.RETURNS - 42 | 1 << Protobuf3Parser.SEMI - 42 | 1 << Protobuf3Parser.DOT - 42 | 1 << Protobuf3Parser.BOOL_LIT - 42 | 1 << Protobuf3Parser.IDENTIFIER - 42)) !== 0) {
	          this.state = 199;

	          this._errHandler.sync(this);

	          var la_ = this._interp.adaptivePredict(this._input, 10, this._ctx);

	          switch (la_) {
	            case 1:
	              this.state = 196;
	              this.optionStatement();
	              break;

	            case 2:
	              this.state = 197;
	              this.oneofField();
	              break;

	            case 3:
	              this.state = 198;
	              this.emptyStatement();
	              break;
	          }

	          this.state = 203;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 204;
	        this.match(Protobuf3Parser.RC);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "oneofField",
	    value: function oneofField() {
	      var localctx = new OneofFieldContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 26, Protobuf3Parser.RULE_oneofField);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 206;
	        this.type_();
	        this.state = 207;
	        this.fieldName();
	        this.state = 208;
	        this.match(Protobuf3Parser.EQ);
	        this.state = 209;
	        this.fieldNumber();
	        this.state = 214;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.LB) {
	          this.state = 210;
	          this.match(Protobuf3Parser.LB);
	          this.state = 211;
	          this.fieldOptions();
	          this.state = 212;
	          this.match(Protobuf3Parser.RB);
	        }

	        this.state = 216;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "mapField",
	    value: function mapField() {
	      var localctx = new MapFieldContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 28, Protobuf3Parser.RULE_mapField);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 218;
	        this.match(Protobuf3Parser.MAP);
	        this.state = 219;
	        this.match(Protobuf3Parser.LT);
	        this.state = 220;
	        this.keyType();
	        this.state = 221;
	        this.match(Protobuf3Parser.COMMA);
	        this.state = 222;
	        this.type_();
	        this.state = 223;
	        this.match(Protobuf3Parser.GT);
	        this.state = 224;
	        this.mapName();
	        this.state = 225;
	        this.match(Protobuf3Parser.EQ);
	        this.state = 226;
	        this.fieldNumber();
	        this.state = 231;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.LB) {
	          this.state = 227;
	          this.match(Protobuf3Parser.LB);
	          this.state = 228;
	          this.fieldOptions();
	          this.state = 229;
	          this.match(Protobuf3Parser.RB);
	        }

	        this.state = 233;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "keyType",
	    value: function keyType() {
	      var localctx = new KeyTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 30, Protobuf3Parser.RULE_keyType);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 235;
	        _la = this._input.LA(1);

	        if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << Protobuf3Parser.INT32 | 1 << Protobuf3Parser.INT64 | 1 << Protobuf3Parser.UINT32 | 1 << Protobuf3Parser.UINT64 | 1 << Protobuf3Parser.SINT32 | 1 << Protobuf3Parser.SINT64 | 1 << Protobuf3Parser.FIXED32 | 1 << Protobuf3Parser.FIXED64 | 1 << Protobuf3Parser.SFIXED32 | 1 << Protobuf3Parser.SFIXED64 | 1 << Protobuf3Parser.BOOL | 1 << Protobuf3Parser.STRING)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      var localctx = new Type_Context(this, this._ctx, this.state);
	      this.enterRule(localctx, 32, Protobuf3Parser.RULE_type_);

	      try {
	        this.state = 254;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 14, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 237;
	            this.match(Protobuf3Parser.DOUBLE);
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 238;
	            this.match(Protobuf3Parser.FLOAT);
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 239;
	            this.match(Protobuf3Parser.INT32);
	            break;

	          case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 240;
	            this.match(Protobuf3Parser.INT64);
	            break;

	          case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 241;
	            this.match(Protobuf3Parser.UINT32);
	            break;

	          case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 242;
	            this.match(Protobuf3Parser.UINT64);
	            break;

	          case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 243;
	            this.match(Protobuf3Parser.SINT32);
	            break;

	          case 8:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 244;
	            this.match(Protobuf3Parser.SINT64);
	            break;

	          case 9:
	            this.enterOuterAlt(localctx, 9);
	            this.state = 245;
	            this.match(Protobuf3Parser.FIXED32);
	            break;

	          case 10:
	            this.enterOuterAlt(localctx, 10);
	            this.state = 246;
	            this.match(Protobuf3Parser.FIXED64);
	            break;

	          case 11:
	            this.enterOuterAlt(localctx, 11);
	            this.state = 247;
	            this.match(Protobuf3Parser.SFIXED32);
	            break;

	          case 12:
	            this.enterOuterAlt(localctx, 12);
	            this.state = 248;
	            this.match(Protobuf3Parser.SFIXED64);
	            break;

	          case 13:
	            this.enterOuterAlt(localctx, 13);
	            this.state = 249;
	            this.match(Protobuf3Parser.BOOL);
	            break;

	          case 14:
	            this.enterOuterAlt(localctx, 14);
	            this.state = 250;
	            this.match(Protobuf3Parser.STRING);
	            break;

	          case 15:
	            this.enterOuterAlt(localctx, 15);
	            this.state = 251;
	            this.match(Protobuf3Parser.BYTES);
	            break;

	          case 16:
	            this.enterOuterAlt(localctx, 16);
	            this.state = 252;
	            this.messageType();
	            break;

	          case 17:
	            this.enterOuterAlt(localctx, 17);
	            this.state = 253;
	            this.enumType();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "reserved",
	    value: function reserved() {
	      var localctx = new ReservedContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 34, Protobuf3Parser.RULE_reserved);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 256;
	        this.match(Protobuf3Parser.RESERVED);
	        this.state = 259;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case Protobuf3Parser.INT_LIT:
	            this.state = 257;
	            this.ranges();
	            break;

	          case Protobuf3Parser.PROTO3_LIT_SINGLE:
	          case Protobuf3Parser.PROTO3_LIT_DOBULE:
	          case Protobuf3Parser.STR_LIT:
	            this.state = 258;
	            this.reservedFieldNames();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }

	        this.state = 261;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "ranges",
	    value: function ranges() {
	      var localctx = new RangesContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 36, Protobuf3Parser.RULE_ranges);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 263;
	        this.range_();
	        this.state = 268;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === Protobuf3Parser.COMMA) {
	          this.state = 264;
	          this.match(Protobuf3Parser.COMMA);
	          this.state = 265;
	          this.range_();
	          this.state = 270;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "range_",
	    value: function range_() {
	      var localctx = new Range_Context(this, this._ctx, this.state);
	      this.enterRule(localctx, 38, Protobuf3Parser.RULE_range_);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 271;
	        this.intLit();
	        this.state = 277;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.TO) {
	          this.state = 272;
	          this.match(Protobuf3Parser.TO);
	          this.state = 275;

	          this._errHandler.sync(this);

	          switch (this._input.LA(1)) {
	            case Protobuf3Parser.INT_LIT:
	              this.state = 273;
	              this.intLit();
	              break;

	            case Protobuf3Parser.MAX:
	              this.state = 274;
	              this.match(Protobuf3Parser.MAX);
	              break;

	            default:
	              throw new _antlr["default"].error.NoViableAltException(this);
	          }
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "reservedFieldNames",
	    value: function reservedFieldNames() {
	      var localctx = new ReservedFieldNamesContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 40, Protobuf3Parser.RULE_reservedFieldNames);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 279;
	        this.strLit();
	        this.state = 284;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === Protobuf3Parser.COMMA) {
	          this.state = 280;
	          this.match(Protobuf3Parser.COMMA);
	          this.state = 281;
	          this.strLit();
	          this.state = 286;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "topLevelDef",
	    value: function topLevelDef() {
	      var localctx = new TopLevelDefContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 42, Protobuf3Parser.RULE_topLevelDef);

	      try {
	        this.state = 290;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case Protobuf3Parser.MESSAGE:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 287;
	            this.messageDef();
	            break;

	          case Protobuf3Parser.ENUM:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 288;
	            this.enumDef();
	            break;

	          case Protobuf3Parser.SERVICE:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 289;
	            this.serviceDef();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumDef",
	    value: function enumDef() {
	      var localctx = new EnumDefContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 44, Protobuf3Parser.RULE_enumDef);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 292;
	        this.match(Protobuf3Parser.ENUM);
	        this.state = 293;
	        this.enumName();
	        this.state = 294;
	        this.enumBody();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumBody",
	    value: function enumBody() {
	      var localctx = new EnumBodyContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 46, Protobuf3Parser.RULE_enumBody);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 296;
	        this.match(Protobuf3Parser.LC);
	        this.state = 300;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la - 10 & ~0x1f) == 0 && (1 << _la - 10 & (1 << Protobuf3Parser.SYNTAX - 10 | 1 << Protobuf3Parser.IMPORT - 10 | 1 << Protobuf3Parser.WEAK - 10 | 1 << Protobuf3Parser.PUBLIC - 10 | 1 << Protobuf3Parser.PACKAGE - 10 | 1 << Protobuf3Parser.OPTION - 10 | 1 << Protobuf3Parser.REPEATED - 10 | 1 << Protobuf3Parser.ONEOF - 10 | 1 << Protobuf3Parser.MAP - 10 | 1 << Protobuf3Parser.INT32 - 10 | 1 << Protobuf3Parser.INT64 - 10 | 1 << Protobuf3Parser.UINT32 - 10 | 1 << Protobuf3Parser.UINT64 - 10 | 1 << Protobuf3Parser.SINT32 - 10 | 1 << Protobuf3Parser.SINT64 - 10 | 1 << Protobuf3Parser.FIXED32 - 10 | 1 << Protobuf3Parser.FIXED64 - 10 | 1 << Protobuf3Parser.SFIXED32 - 10 | 1 << Protobuf3Parser.SFIXED64 - 10 | 1 << Protobuf3Parser.BOOL - 10 | 1 << Protobuf3Parser.STRING - 10 | 1 << Protobuf3Parser.DOUBLE - 10 | 1 << Protobuf3Parser.FLOAT - 10 | 1 << Protobuf3Parser.BYTES - 10 | 1 << Protobuf3Parser.RESERVED - 10 | 1 << Protobuf3Parser.TO - 10 | 1 << Protobuf3Parser.MAX - 10 | 1 << Protobuf3Parser.ENUM - 10 | 1 << Protobuf3Parser.MESSAGE - 10 | 1 << Protobuf3Parser.SERVICE - 10 | 1 << Protobuf3Parser.RPC - 10)) !== 0 || (_la - 42 & ~0x1f) == 0 && (1 << _la - 42 & (1 << Protobuf3Parser.STREAM - 42 | 1 << Protobuf3Parser.RETURNS - 42 | 1 << Protobuf3Parser.SEMI - 42 | 1 << Protobuf3Parser.BOOL_LIT - 42 | 1 << Protobuf3Parser.IDENTIFIER - 42)) !== 0) {
	          this.state = 297;
	          this.enumElement();
	          this.state = 302;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 303;
	        this.match(Protobuf3Parser.RC);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumElement",
	    value: function enumElement() {
	      var localctx = new EnumElementContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 48, Protobuf3Parser.RULE_enumElement);

	      try {
	        this.state = 308;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 22, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 305;
	            this.optionStatement();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 306;
	            this.enumField();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 307;
	            this.emptyStatement();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumField",
	    value: function enumField() {
	      var localctx = new EnumFieldContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 50, Protobuf3Parser.RULE_enumField);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 310;
	        this.ident();
	        this.state = 311;
	        this.match(Protobuf3Parser.EQ);
	        this.state = 313;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.MINUS) {
	          this.state = 312;
	          this.match(Protobuf3Parser.MINUS);
	        }

	        this.state = 315;
	        this.intLit();
	        this.state = 317;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.LB) {
	          this.state = 316;
	          this.enumValueOptions();
	        }

	        this.state = 319;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValueOptions",
	    value: function enumValueOptions() {
	      var localctx = new EnumValueOptionsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 52, Protobuf3Parser.RULE_enumValueOptions);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 321;
	        this.match(Protobuf3Parser.LB);
	        this.state = 322;
	        this.enumValueOption();
	        this.state = 327;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === Protobuf3Parser.COMMA) {
	          this.state = 323;
	          this.match(Protobuf3Parser.COMMA);
	          this.state = 324;
	          this.enumValueOption();
	          this.state = 329;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 330;
	        this.match(Protobuf3Parser.RB);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValueOption",
	    value: function enumValueOption() {
	      var localctx = new EnumValueOptionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 54, Protobuf3Parser.RULE_enumValueOption);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 332;
	        this.optionName();
	        this.state = 333;
	        this.match(Protobuf3Parser.EQ);
	        this.state = 334;
	        this.constant();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "messageDef",
	    value: function messageDef() {
	      var localctx = new MessageDefContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 56, Protobuf3Parser.RULE_messageDef);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 336;
	        this.match(Protobuf3Parser.MESSAGE);
	        this.state = 337;
	        this.messageName();
	        this.state = 338;
	        this.messageBody();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "messageBody",
	    value: function messageBody() {
	      var localctx = new MessageBodyContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 58, Protobuf3Parser.RULE_messageBody);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 340;
	        this.match(Protobuf3Parser.LC);
	        this.state = 344;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la - 10 & ~0x1f) == 0 && (1 << _la - 10 & (1 << Protobuf3Parser.SYNTAX - 10 | 1 << Protobuf3Parser.IMPORT - 10 | 1 << Protobuf3Parser.WEAK - 10 | 1 << Protobuf3Parser.PUBLIC - 10 | 1 << Protobuf3Parser.PACKAGE - 10 | 1 << Protobuf3Parser.OPTION - 10 | 1 << Protobuf3Parser.REPEATED - 10 | 1 << Protobuf3Parser.ONEOF - 10 | 1 << Protobuf3Parser.MAP - 10 | 1 << Protobuf3Parser.INT32 - 10 | 1 << Protobuf3Parser.INT64 - 10 | 1 << Protobuf3Parser.UINT32 - 10 | 1 << Protobuf3Parser.UINT64 - 10 | 1 << Protobuf3Parser.SINT32 - 10 | 1 << Protobuf3Parser.SINT64 - 10 | 1 << Protobuf3Parser.FIXED32 - 10 | 1 << Protobuf3Parser.FIXED64 - 10 | 1 << Protobuf3Parser.SFIXED32 - 10 | 1 << Protobuf3Parser.SFIXED64 - 10 | 1 << Protobuf3Parser.BOOL - 10 | 1 << Protobuf3Parser.STRING - 10 | 1 << Protobuf3Parser.DOUBLE - 10 | 1 << Protobuf3Parser.FLOAT - 10 | 1 << Protobuf3Parser.BYTES - 10 | 1 << Protobuf3Parser.RESERVED - 10 | 1 << Protobuf3Parser.TO - 10 | 1 << Protobuf3Parser.MAX - 10 | 1 << Protobuf3Parser.ENUM - 10 | 1 << Protobuf3Parser.MESSAGE - 10 | 1 << Protobuf3Parser.SERVICE - 10 | 1 << Protobuf3Parser.RPC - 10)) !== 0 || (_la - 42 & ~0x1f) == 0 && (1 << _la - 42 & (1 << Protobuf3Parser.STREAM - 42 | 1 << Protobuf3Parser.RETURNS - 42 | 1 << Protobuf3Parser.SEMI - 42 | 1 << Protobuf3Parser.DOT - 42 | 1 << Protobuf3Parser.BOOL_LIT - 42 | 1 << Protobuf3Parser.IDENTIFIER - 42)) !== 0) {
	          this.state = 341;
	          this.messageElement();
	          this.state = 346;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 347;
	        this.match(Protobuf3Parser.RC);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "messageElement",
	    value: function messageElement() {
	      var localctx = new MessageElementContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 60, Protobuf3Parser.RULE_messageElement);

	      try {
	        this.state = 357;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 27, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 349;
	            this.field();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 350;
	            this.enumDef();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 351;
	            this.messageDef();
	            break;

	          case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 352;
	            this.optionStatement();
	            break;

	          case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 353;
	            this.oneof();
	            break;

	          case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 354;
	            this.mapField();
	            break;

	          case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 355;
	            this.reserved();
	            break;

	          case 8:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 356;
	            this.emptyStatement();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "serviceDef",
	    value: function serviceDef() {
	      var localctx = new ServiceDefContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 62, Protobuf3Parser.RULE_serviceDef);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 359;
	        this.match(Protobuf3Parser.SERVICE);
	        this.state = 360;
	        this.serviceName();
	        this.state = 361;
	        this.match(Protobuf3Parser.LC);
	        this.state = 365;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la - 16 & ~0x1f) == 0 && (1 << _la - 16 & (1 << Protobuf3Parser.OPTION - 16 | 1 << Protobuf3Parser.RPC - 16 | 1 << Protobuf3Parser.SEMI - 16)) !== 0) {
	          this.state = 362;
	          this.serviceElement();
	          this.state = 367;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 368;
	        this.match(Protobuf3Parser.RC);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "serviceElement",
	    value: function serviceElement() {
	      var localctx = new ServiceElementContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 64, Protobuf3Parser.RULE_serviceElement);

	      try {
	        this.state = 373;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case Protobuf3Parser.OPTION:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 370;
	            this.optionStatement();
	            break;

	          case Protobuf3Parser.RPC:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 371;
	            this.rpc();
	            break;

	          case Protobuf3Parser.SEMI:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 372;
	            this.emptyStatement();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "rpc",
	    value: function rpc() {
	      var localctx = new RpcContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 66, Protobuf3Parser.RULE_rpc);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 375;
	        this.match(Protobuf3Parser.RPC);
	        this.state = 376;
	        this.rpcName();
	        this.state = 377;
	        this.match(Protobuf3Parser.LP);
	        this.state = 379;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 30, this._ctx);

	        if (la_ === 1) {
	          this.state = 378;
	          this.match(Protobuf3Parser.STREAM);
	        }

	        this.state = 381;
	        this.messageType();
	        this.state = 382;
	        this.match(Protobuf3Parser.RP);
	        this.state = 383;
	        this.match(Protobuf3Parser.RETURNS);
	        this.state = 384;
	        this.match(Protobuf3Parser.LP);
	        this.state = 386;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 31, this._ctx);

	        if (la_ === 1) {
	          this.state = 385;
	          this.match(Protobuf3Parser.STREAM);
	        }

	        this.state = 388;
	        this.messageType();
	        this.state = 389;
	        this.match(Protobuf3Parser.RP);
	        this.state = 400;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case Protobuf3Parser.LC:
	            this.state = 390;
	            this.match(Protobuf3Parser.LC);
	            this.state = 395;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            while (_la === Protobuf3Parser.OPTION || _la === Protobuf3Parser.SEMI) {
	              this.state = 393;

	              this._errHandler.sync(this);

	              switch (this._input.LA(1)) {
	                case Protobuf3Parser.OPTION:
	                  this.state = 391;
	                  this.optionStatement();
	                  break;

	                case Protobuf3Parser.SEMI:
	                  this.state = 392;
	                  this.emptyStatement();
	                  break;

	                default:
	                  throw new _antlr["default"].error.NoViableAltException(this);
	              }

	              this.state = 397;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            }

	            this.state = 398;
	            this.match(Protobuf3Parser.RC);
	            break;

	          case Protobuf3Parser.SEMI:
	            this.state = 399;
	            this.match(Protobuf3Parser.SEMI);
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "constant",
	    value: function constant() {
	      var localctx = new ConstantContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 68, Protobuf3Parser.RULE_constant);
	      var _la = 0; // Token type

	      try {
	        this.state = 414;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 37, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 402;
	            this.fullIdent();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 404;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === Protobuf3Parser.PLUS || _la === Protobuf3Parser.MINUS) {
	              this.state = 403;
	              _la = this._input.LA(1);

	              if (!(_la === Protobuf3Parser.PLUS || _la === Protobuf3Parser.MINUS)) {
	                this._errHandler.recoverInline(this);
	              } else {
	                this._errHandler.reportMatch(this);

	                this.consume();
	              }
	            }

	            this.state = 406;
	            this.intLit();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 408;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === Protobuf3Parser.PLUS || _la === Protobuf3Parser.MINUS) {
	              this.state = 407;
	              _la = this._input.LA(1);

	              if (!(_la === Protobuf3Parser.PLUS || _la === Protobuf3Parser.MINUS)) {
	                this._errHandler.recoverInline(this);
	              } else {
	                this._errHandler.reportMatch(this);

	                this.consume();
	              }
	            }

	            this.state = 410;
	            this.floatLit();
	            break;

	          case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 411;
	            this.strLit();
	            break;

	          case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 412;
	            this.boolLit();
	            break;

	          case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 413;
	            this.blockLit();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "blockLit",
	    value: function blockLit() {
	      var localctx = new BlockLitContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 70, Protobuf3Parser.RULE_blockLit);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 416;
	        this.match(Protobuf3Parser.LC);
	        this.state = 423;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la - 10 & ~0x1f) == 0 && (1 << _la - 10 & (1 << Protobuf3Parser.SYNTAX - 10 | 1 << Protobuf3Parser.IMPORT - 10 | 1 << Protobuf3Parser.WEAK - 10 | 1 << Protobuf3Parser.PUBLIC - 10 | 1 << Protobuf3Parser.PACKAGE - 10 | 1 << Protobuf3Parser.OPTION - 10 | 1 << Protobuf3Parser.REPEATED - 10 | 1 << Protobuf3Parser.ONEOF - 10 | 1 << Protobuf3Parser.MAP - 10 | 1 << Protobuf3Parser.INT32 - 10 | 1 << Protobuf3Parser.INT64 - 10 | 1 << Protobuf3Parser.UINT32 - 10 | 1 << Protobuf3Parser.UINT64 - 10 | 1 << Protobuf3Parser.SINT32 - 10 | 1 << Protobuf3Parser.SINT64 - 10 | 1 << Protobuf3Parser.FIXED32 - 10 | 1 << Protobuf3Parser.FIXED64 - 10 | 1 << Protobuf3Parser.SFIXED32 - 10 | 1 << Protobuf3Parser.SFIXED64 - 10 | 1 << Protobuf3Parser.BOOL - 10 | 1 << Protobuf3Parser.STRING - 10 | 1 << Protobuf3Parser.DOUBLE - 10 | 1 << Protobuf3Parser.FLOAT - 10 | 1 << Protobuf3Parser.BYTES - 10 | 1 << Protobuf3Parser.RESERVED - 10 | 1 << Protobuf3Parser.TO - 10 | 1 << Protobuf3Parser.MAX - 10 | 1 << Protobuf3Parser.ENUM - 10 | 1 << Protobuf3Parser.MESSAGE - 10 | 1 << Protobuf3Parser.SERVICE - 10 | 1 << Protobuf3Parser.RPC - 10)) !== 0 || (_la - 42 & ~0x1f) == 0 && (1 << _la - 42 & (1 << Protobuf3Parser.STREAM - 42 | 1 << Protobuf3Parser.RETURNS - 42 | 1 << Protobuf3Parser.BOOL_LIT - 42 | 1 << Protobuf3Parser.IDENTIFIER - 42)) !== 0) {
	          this.state = 417;
	          this.ident();
	          this.state = 418;
	          this.match(Protobuf3Parser.COLON);
	          this.state = 419;
	          this.constant();
	          this.state = 425;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 426;
	        this.match(Protobuf3Parser.RC);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "emptyStatement",
	    value: function emptyStatement() {
	      var localctx = new EmptyStatementContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 72, Protobuf3Parser.RULE_emptyStatement);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 428;
	        this.match(Protobuf3Parser.SEMI);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "ident",
	    value: function ident() {
	      var localctx = new IdentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 74, Protobuf3Parser.RULE_ident);

	      try {
	        this.state = 432;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case Protobuf3Parser.IDENTIFIER:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 430;
	            this.match(Protobuf3Parser.IDENTIFIER);
	            break;

	          case Protobuf3Parser.SYNTAX:
	          case Protobuf3Parser.IMPORT:
	          case Protobuf3Parser.WEAK:
	          case Protobuf3Parser.PUBLIC:
	          case Protobuf3Parser.PACKAGE:
	          case Protobuf3Parser.OPTION:
	          case Protobuf3Parser.REPEATED:
	          case Protobuf3Parser.ONEOF:
	          case Protobuf3Parser.MAP:
	          case Protobuf3Parser.INT32:
	          case Protobuf3Parser.INT64:
	          case Protobuf3Parser.UINT32:
	          case Protobuf3Parser.UINT64:
	          case Protobuf3Parser.SINT32:
	          case Protobuf3Parser.SINT64:
	          case Protobuf3Parser.FIXED32:
	          case Protobuf3Parser.FIXED64:
	          case Protobuf3Parser.SFIXED32:
	          case Protobuf3Parser.SFIXED64:
	          case Protobuf3Parser.BOOL:
	          case Protobuf3Parser.STRING:
	          case Protobuf3Parser.DOUBLE:
	          case Protobuf3Parser.FLOAT:
	          case Protobuf3Parser.BYTES:
	          case Protobuf3Parser.RESERVED:
	          case Protobuf3Parser.TO:
	          case Protobuf3Parser.MAX:
	          case Protobuf3Parser.ENUM:
	          case Protobuf3Parser.MESSAGE:
	          case Protobuf3Parser.SERVICE:
	          case Protobuf3Parser.RPC:
	          case Protobuf3Parser.STREAM:
	          case Protobuf3Parser.RETURNS:
	          case Protobuf3Parser.BOOL_LIT:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 431;
	            this.keywords();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fullIdent",
	    value: function fullIdent() {
	      var localctx = new FullIdentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 76, Protobuf3Parser.RULE_fullIdent);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 434;
	        this.ident();
	        this.state = 439;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === Protobuf3Parser.DOT) {
	          this.state = 435;
	          this.match(Protobuf3Parser.DOT);
	          this.state = 436;
	          this.ident();
	          this.state = 441;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "messageName",
	    value: function messageName() {
	      var localctx = new MessageNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 78, Protobuf3Parser.RULE_messageName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 442;
	        this.ident();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumName",
	    value: function enumName() {
	      var localctx = new EnumNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 80, Protobuf3Parser.RULE_enumName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 444;
	        this.ident();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldName",
	    value: function fieldName() {
	      var localctx = new FieldNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 82, Protobuf3Parser.RULE_fieldName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 446;
	        this.ident();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "oneofName",
	    value: function oneofName() {
	      var localctx = new OneofNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 84, Protobuf3Parser.RULE_oneofName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 448;
	        this.ident();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "mapName",
	    value: function mapName() {
	      var localctx = new MapNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 86, Protobuf3Parser.RULE_mapName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 450;
	        this.ident();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "serviceName",
	    value: function serviceName() {
	      var localctx = new ServiceNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 88, Protobuf3Parser.RULE_serviceName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 452;
	        this.ident();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "rpcName",
	    value: function rpcName() {
	      var localctx = new RpcNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 90, Protobuf3Parser.RULE_rpcName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 454;
	        this.ident();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "messageType",
	    value: function messageType() {
	      var localctx = new MessageTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 92, Protobuf3Parser.RULE_messageType);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 457;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.DOT) {
	          this.state = 456;
	          this.match(Protobuf3Parser.DOT);
	        }

	        this.state = 464;

	        this._errHandler.sync(this);

	        var _alt = this._interp.adaptivePredict(this._input, 42, this._ctx);

	        while (_alt != 2 && _alt != _antlr["default"].atn.ATN.INVALID_ALT_NUMBER) {
	          if (_alt === 1) {
	            this.state = 459;
	            this.ident();
	            this.state = 460;
	            this.match(Protobuf3Parser.DOT);
	          }

	          this.state = 466;

	          this._errHandler.sync(this);

	          _alt = this._interp.adaptivePredict(this._input, 42, this._ctx);
	        }

	        this.state = 467;
	        this.messageName();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumType",
	    value: function enumType() {
	      var localctx = new EnumTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 94, Protobuf3Parser.RULE_enumType);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 470;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === Protobuf3Parser.DOT) {
	          this.state = 469;
	          this.match(Protobuf3Parser.DOT);
	        }

	        this.state = 477;

	        this._errHandler.sync(this);

	        var _alt = this._interp.adaptivePredict(this._input, 44, this._ctx);

	        while (_alt != 2 && _alt != _antlr["default"].atn.ATN.INVALID_ALT_NUMBER) {
	          if (_alt === 1) {
	            this.state = 472;
	            this.ident();
	            this.state = 473;
	            this.match(Protobuf3Parser.DOT);
	          }

	          this.state = 479;

	          this._errHandler.sync(this);

	          _alt = this._interp.adaptivePredict(this._input, 44, this._ctx);
	        }

	        this.state = 480;
	        this.enumName();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "intLit",
	    value: function intLit() {
	      var localctx = new IntLitContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 96, Protobuf3Parser.RULE_intLit);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 482;
	        this.match(Protobuf3Parser.INT_LIT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "strLit",
	    value: function strLit() {
	      var localctx = new StrLitContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 98, Protobuf3Parser.RULE_strLit);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 484;
	        _la = this._input.LA(1);

	        if (!((_la - 44 & ~0x1f) == 0 && (1 << _la - 44 & (1 << Protobuf3Parser.PROTO3_LIT_SINGLE - 44 | 1 << Protobuf3Parser.PROTO3_LIT_DOBULE - 44 | 1 << Protobuf3Parser.STR_LIT - 44)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "boolLit",
	    value: function boolLit() {
	      var localctx = new BoolLitContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 100, Protobuf3Parser.RULE_boolLit);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 486;
	        this.match(Protobuf3Parser.BOOL_LIT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "floatLit",
	    value: function floatLit() {
	      var localctx = new FloatLitContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 102, Protobuf3Parser.RULE_floatLit);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 488;
	        this.match(Protobuf3Parser.FLOAT_LIT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "keywords",
	    value: function keywords() {
	      var localctx = new KeywordsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 104, Protobuf3Parser.RULE_keywords);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 490;
	        _la = this._input.LA(1);

	        if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << Protobuf3Parser.SYNTAX | 1 << Protobuf3Parser.IMPORT | 1 << Protobuf3Parser.WEAK | 1 << Protobuf3Parser.PUBLIC | 1 << Protobuf3Parser.PACKAGE | 1 << Protobuf3Parser.OPTION | 1 << Protobuf3Parser.REPEATED | 1 << Protobuf3Parser.ONEOF | 1 << Protobuf3Parser.MAP | 1 << Protobuf3Parser.INT32 | 1 << Protobuf3Parser.INT64 | 1 << Protobuf3Parser.UINT32 | 1 << Protobuf3Parser.UINT64 | 1 << Protobuf3Parser.SINT32 | 1 << Protobuf3Parser.SINT64 | 1 << Protobuf3Parser.FIXED32 | 1 << Protobuf3Parser.FIXED64 | 1 << Protobuf3Parser.SFIXED32 | 1 << Protobuf3Parser.SFIXED64 | 1 << Protobuf3Parser.BOOL | 1 << Protobuf3Parser.STRING)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << Protobuf3Parser.DOUBLE - 32 | 1 << Protobuf3Parser.FLOAT - 32 | 1 << Protobuf3Parser.BYTES - 32 | 1 << Protobuf3Parser.RESERVED - 32 | 1 << Protobuf3Parser.TO - 32 | 1 << Protobuf3Parser.MAX - 32 | 1 << Protobuf3Parser.ENUM - 32 | 1 << Protobuf3Parser.MESSAGE - 32 | 1 << Protobuf3Parser.SERVICE - 32 | 1 << Protobuf3Parser.RPC - 32 | 1 << Protobuf3Parser.STREAM - 32 | 1 << Protobuf3Parser.RETURNS - 32 | 1 << Protobuf3Parser.BOOL_LIT - 32)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }]);

	  return Protobuf3Parser;
	}(_antlr["default"].Parser);

	exports["default"] = Protobuf3Parser;

	_defineProperty(Protobuf3Parser, "grammarFileName", "Protobuf3.g4");

	_defineProperty(Protobuf3Parser, "literalNames", [null, "'google.protobuf.FieldOptions'", "'google.protobuf.EnumOptions'", "'google.protobuf.EnumValueOptions'", "'google.protobuf.ExtensionRangeOptions'", "'google.protobuf.MessageOptions'", "'google.protobuf.MethodOptions'", "'google.protobuf.ServiceOptions'", "'google.protobuf.FileOptions'", "'google.protobuf.OneofOptions'", "'syntax'", "'import'", "'extend'", "'weak'", "'public'", "'package'", "'option'", "'repeated'", "'oneof'", "'map'", "'int32'", "'int64'", "'uint32'", "'uint64'", "'sint32'", "'sint64'", "'fixed32'", "'fixed64'", "'sfixed32'", "'sfixed64'", "'bool'", "'string'", "'double'", "'float'", "'bytes'", "'reserved'", "'to'", "'max'", "'enum'", "'message'", "'service'", "'rpc'", "'stream'", "'returns'", "'\"proto3\"'", "''proto3''", "';'", "'='", "'('", "')'", "'['", "']'", "'{'", "'}'", "'<'", "'>'", "'.'", "','", "':'", "'+'", "'-'"]);

	_defineProperty(Protobuf3Parser, "symbolicNames", [null, "FIELD_OPTIONS", "ENUM_OPTIONS", "ENUM_VALUE_OPTIONS", "EXTENSION_RANGE_OPTIONS", "MESSAGE_OPTIONS", "METHOD_OPTIONS", "SERVICE_OPTIONS", "FILE_OPTIONS", "ONEOF_OPTIONS", "SYNTAX", "IMPORT", "EXTEND", "WEAK", "PUBLIC", "PACKAGE", "OPTION", "REPEATED", "ONEOF", "MAP", "INT32", "INT64", "UINT32", "UINT64", "SINT32", "SINT64", "FIXED32", "FIXED64", "SFIXED32", "SFIXED64", "BOOL", "STRING", "DOUBLE", "FLOAT", "BYTES", "RESERVED", "TO", "MAX", "ENUM", "MESSAGE", "SERVICE", "RPC", "STREAM", "RETURNS", "PROTO3_LIT_SINGLE", "PROTO3_LIT_DOBULE", "SEMI", "EQ", "LP", "RP", "LB", "RB", "LC", "RC", "LT", "GT", "DOT", "COMMA", "COLON", "PLUS", "MINUS", "STR_LIT", "BOOL_LIT", "FLOAT_LIT", "INT_LIT", "IDENTIFIER", "WS", "LINE_COMMENT", "COMMENT"]);

	_defineProperty(Protobuf3Parser, "ruleNames", ["proto", "syntax", "importStatement", "packageStatement", "optionStatement", "optionName", "extendsStatement", "extendedIdentifier", "field", "fieldOptions", "fieldOption", "fieldNumber", "oneof", "oneofField", "mapField", "keyType", "type_", "reserved", "ranges", "range_", "reservedFieldNames", "topLevelDef", "enumDef", "enumBody", "enumElement", "enumField", "enumValueOptions", "enumValueOption", "messageDef", "messageBody", "messageElement", "serviceDef", "serviceElement", "rpc", "constant", "blockLit", "emptyStatement", "ident", "fullIdent", "messageName", "enumName", "fieldName", "oneofName", "mapName", "serviceName", "rpcName", "messageType", "enumType", "intLit", "strLit", "boolLit", "floatLit", "keywords"]);

	Protobuf3Parser.EOF = _antlr["default"].Token.EOF;
	Protobuf3Parser.FIELD_OPTIONS = 1;
	Protobuf3Parser.ENUM_OPTIONS = 2;
	Protobuf3Parser.ENUM_VALUE_OPTIONS = 3;
	Protobuf3Parser.EXTENSION_RANGE_OPTIONS = 4;
	Protobuf3Parser.MESSAGE_OPTIONS = 5;
	Protobuf3Parser.METHOD_OPTIONS = 6;
	Protobuf3Parser.SERVICE_OPTIONS = 7;
	Protobuf3Parser.FILE_OPTIONS = 8;
	Protobuf3Parser.ONEOF_OPTIONS = 9;
	Protobuf3Parser.SYNTAX = 10;
	Protobuf3Parser.IMPORT = 11;
	Protobuf3Parser.EXTEND = 12;
	Protobuf3Parser.WEAK = 13;
	Protobuf3Parser.PUBLIC = 14;
	Protobuf3Parser.PACKAGE = 15;
	Protobuf3Parser.OPTION = 16;
	Protobuf3Parser.REPEATED = 17;
	Protobuf3Parser.ONEOF = 18;
	Protobuf3Parser.MAP = 19;
	Protobuf3Parser.INT32 = 20;
	Protobuf3Parser.INT64 = 21;
	Protobuf3Parser.UINT32 = 22;
	Protobuf3Parser.UINT64 = 23;
	Protobuf3Parser.SINT32 = 24;
	Protobuf3Parser.SINT64 = 25;
	Protobuf3Parser.FIXED32 = 26;
	Protobuf3Parser.FIXED64 = 27;
	Protobuf3Parser.SFIXED32 = 28;
	Protobuf3Parser.SFIXED64 = 29;
	Protobuf3Parser.BOOL = 30;
	Protobuf3Parser.STRING = 31;
	Protobuf3Parser.DOUBLE = 32;
	Protobuf3Parser.FLOAT = 33;
	Protobuf3Parser.BYTES = 34;
	Protobuf3Parser.RESERVED = 35;
	Protobuf3Parser.TO = 36;
	Protobuf3Parser.MAX = 37;
	Protobuf3Parser.ENUM = 38;
	Protobuf3Parser.MESSAGE = 39;
	Protobuf3Parser.SERVICE = 40;
	Protobuf3Parser.RPC = 41;
	Protobuf3Parser.STREAM = 42;
	Protobuf3Parser.RETURNS = 43;
	Protobuf3Parser.PROTO3_LIT_SINGLE = 44;
	Protobuf3Parser.PROTO3_LIT_DOBULE = 45;
	Protobuf3Parser.SEMI = 46;
	Protobuf3Parser.EQ = 47;
	Protobuf3Parser.LP = 48;
	Protobuf3Parser.RP = 49;
	Protobuf3Parser.LB = 50;
	Protobuf3Parser.RB = 51;
	Protobuf3Parser.LC = 52;
	Protobuf3Parser.RC = 53;
	Protobuf3Parser.LT = 54;
	Protobuf3Parser.GT = 55;
	Protobuf3Parser.DOT = 56;
	Protobuf3Parser.COMMA = 57;
	Protobuf3Parser.COLON = 58;
	Protobuf3Parser.PLUS = 59;
	Protobuf3Parser.MINUS = 60;
	Protobuf3Parser.STR_LIT = 61;
	Protobuf3Parser.BOOL_LIT = 62;
	Protobuf3Parser.FLOAT_LIT = 63;
	Protobuf3Parser.INT_LIT = 64;
	Protobuf3Parser.IDENTIFIER = 65;
	Protobuf3Parser.WS = 66;
	Protobuf3Parser.LINE_COMMENT = 67;
	Protobuf3Parser.COMMENT = 68;
	Protobuf3Parser.RULE_proto = 0;
	Protobuf3Parser.RULE_syntax = 1;
	Protobuf3Parser.RULE_importStatement = 2;
	Protobuf3Parser.RULE_packageStatement = 3;
	Protobuf3Parser.RULE_optionStatement = 4;
	Protobuf3Parser.RULE_optionName = 5;
	Protobuf3Parser.RULE_extendsStatement = 6;
	Protobuf3Parser.RULE_extendedIdentifier = 7;
	Protobuf3Parser.RULE_field = 8;
	Protobuf3Parser.RULE_fieldOptions = 9;
	Protobuf3Parser.RULE_fieldOption = 10;
	Protobuf3Parser.RULE_fieldNumber = 11;
	Protobuf3Parser.RULE_oneof = 12;
	Protobuf3Parser.RULE_oneofField = 13;
	Protobuf3Parser.RULE_mapField = 14;
	Protobuf3Parser.RULE_keyType = 15;
	Protobuf3Parser.RULE_type_ = 16;
	Protobuf3Parser.RULE_reserved = 17;
	Protobuf3Parser.RULE_ranges = 18;
	Protobuf3Parser.RULE_range_ = 19;
	Protobuf3Parser.RULE_reservedFieldNames = 20;
	Protobuf3Parser.RULE_topLevelDef = 21;
	Protobuf3Parser.RULE_enumDef = 22;
	Protobuf3Parser.RULE_enumBody = 23;
	Protobuf3Parser.RULE_enumElement = 24;
	Protobuf3Parser.RULE_enumField = 25;
	Protobuf3Parser.RULE_enumValueOptions = 26;
	Protobuf3Parser.RULE_enumValueOption = 27;
	Protobuf3Parser.RULE_messageDef = 28;
	Protobuf3Parser.RULE_messageBody = 29;
	Protobuf3Parser.RULE_messageElement = 30;
	Protobuf3Parser.RULE_serviceDef = 31;
	Protobuf3Parser.RULE_serviceElement = 32;
	Protobuf3Parser.RULE_rpc = 33;
	Protobuf3Parser.RULE_constant = 34;
	Protobuf3Parser.RULE_blockLit = 35;
	Protobuf3Parser.RULE_emptyStatement = 36;
	Protobuf3Parser.RULE_ident = 37;
	Protobuf3Parser.RULE_fullIdent = 38;
	Protobuf3Parser.RULE_messageName = 39;
	Protobuf3Parser.RULE_enumName = 40;
	Protobuf3Parser.RULE_fieldName = 41;
	Protobuf3Parser.RULE_oneofName = 42;
	Protobuf3Parser.RULE_mapName = 43;
	Protobuf3Parser.RULE_serviceName = 44;
	Protobuf3Parser.RULE_rpcName = 45;
	Protobuf3Parser.RULE_messageType = 46;
	Protobuf3Parser.RULE_enumType = 47;
	Protobuf3Parser.RULE_intLit = 48;
	Protobuf3Parser.RULE_strLit = 49;
	Protobuf3Parser.RULE_boolLit = 50;
	Protobuf3Parser.RULE_floatLit = 51;
	Protobuf3Parser.RULE_keywords = 52;

	var ProtoContext = /*#__PURE__*/function (_antlr4$ParserRuleCon) {
	  _inherits(ProtoContext, _antlr4$ParserRuleCon);

	  var _super2 = _createSuper(ProtoContext);

	  function ProtoContext(parser, parent, invokingState) {
	    var _this2;

	    _classCallCheck(this, ProtoContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this2 = _super2.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this2), "importStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ImportStatementContext);
	      } else {
	        return this.getTypedRuleContext(ImportStatementContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this2), "packageStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(PackageStatementContext);
	      } else {
	        return this.getTypedRuleContext(PackageStatementContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this2), "optionStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(OptionStatementContext);
	      } else {
	        return this.getTypedRuleContext(OptionStatementContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this2), "extendsStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ExtendsStatementContext);
	      } else {
	        return this.getTypedRuleContext(ExtendsStatementContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this2), "topLevelDef", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(TopLevelDefContext);
	      } else {
	        return this.getTypedRuleContext(TopLevelDefContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this2), "emptyStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EmptyStatementContext);
	      } else {
	        return this.getTypedRuleContext(EmptyStatementContext, i);
	      }
	    });

	    _this2.parser = parser;
	    _this2.ruleIndex = Protobuf3Parser.RULE_proto;
	    return _this2;
	  }

	  _createClass(ProtoContext, [{
	    key: "syntax",
	    value: function syntax() {
	      return this.getTypedRuleContext(SyntaxContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterProto(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitProto(this);
	      }
	    }
	  }]);

	  return ProtoContext;
	}(_antlr["default"].ParserRuleContext);

	var SyntaxContext = /*#__PURE__*/function (_antlr4$ParserRuleCon2) {
	  _inherits(SyntaxContext, _antlr4$ParserRuleCon2);

	  var _super3 = _createSuper(SyntaxContext);

	  function SyntaxContext(parser, parent, invokingState) {
	    var _this3;

	    _classCallCheck(this, SyntaxContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this3 = _super3.call(this, parent, invokingState);
	    _this3.parser = parser;
	    _this3.ruleIndex = Protobuf3Parser.RULE_syntax;
	    return _this3;
	  }

	  _createClass(SyntaxContext, [{
	    key: "SYNTAX",
	    value: function SYNTAX() {
	      return this.getToken(Protobuf3Parser.SYNTAX, 0);
	    }
	  }, {
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(Protobuf3Parser.EQ, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "PROTO3_LIT_SINGLE",
	    value: function PROTO3_LIT_SINGLE() {
	      return this.getToken(Protobuf3Parser.PROTO3_LIT_SINGLE, 0);
	    }
	  }, {
	    key: "PROTO3_LIT_DOBULE",
	    value: function PROTO3_LIT_DOBULE() {
	      return this.getToken(Protobuf3Parser.PROTO3_LIT_DOBULE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterSyntax(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitSyntax(this);
	      }
	    }
	  }]);

	  return SyntaxContext;
	}(_antlr["default"].ParserRuleContext);

	var ImportStatementContext = /*#__PURE__*/function (_antlr4$ParserRuleCon3) {
	  _inherits(ImportStatementContext, _antlr4$ParserRuleCon3);

	  var _super4 = _createSuper(ImportStatementContext);

	  function ImportStatementContext(parser, parent, invokingState) {
	    var _this4;

	    _classCallCheck(this, ImportStatementContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this4 = _super4.call(this, parent, invokingState);
	    _this4.parser = parser;
	    _this4.ruleIndex = Protobuf3Parser.RULE_importStatement;
	    return _this4;
	  }

	  _createClass(ImportStatementContext, [{
	    key: "IMPORT",
	    value: function IMPORT() {
	      return this.getToken(Protobuf3Parser.IMPORT, 0);
	    }
	  }, {
	    key: "strLit",
	    value: function strLit() {
	      return this.getTypedRuleContext(StrLitContext, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "WEAK",
	    value: function WEAK() {
	      return this.getToken(Protobuf3Parser.WEAK, 0);
	    }
	  }, {
	    key: "PUBLIC",
	    value: function PUBLIC() {
	      return this.getToken(Protobuf3Parser.PUBLIC, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterImportStatement(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitImportStatement(this);
	      }
	    }
	  }]);

	  return ImportStatementContext;
	}(_antlr["default"].ParserRuleContext);

	var PackageStatementContext = /*#__PURE__*/function (_antlr4$ParserRuleCon4) {
	  _inherits(PackageStatementContext, _antlr4$ParserRuleCon4);

	  var _super5 = _createSuper(PackageStatementContext);

	  function PackageStatementContext(parser, parent, invokingState) {
	    var _this5;

	    _classCallCheck(this, PackageStatementContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this5 = _super5.call(this, parent, invokingState);
	    _this5.parser = parser;
	    _this5.ruleIndex = Protobuf3Parser.RULE_packageStatement;
	    return _this5;
	  }

	  _createClass(PackageStatementContext, [{
	    key: "PACKAGE",
	    value: function PACKAGE() {
	      return this.getToken(Protobuf3Parser.PACKAGE, 0);
	    }
	  }, {
	    key: "fullIdent",
	    value: function fullIdent() {
	      return this.getTypedRuleContext(FullIdentContext, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterPackageStatement(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitPackageStatement(this);
	      }
	    }
	  }]);

	  return PackageStatementContext;
	}(_antlr["default"].ParserRuleContext);

	var OptionStatementContext = /*#__PURE__*/function (_antlr4$ParserRuleCon5) {
	  _inherits(OptionStatementContext, _antlr4$ParserRuleCon5);

	  var _super6 = _createSuper(OptionStatementContext);

	  function OptionStatementContext(parser, parent, invokingState) {
	    var _this6;

	    _classCallCheck(this, OptionStatementContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this6 = _super6.call(this, parent, invokingState);
	    _this6.parser = parser;
	    _this6.ruleIndex = Protobuf3Parser.RULE_optionStatement;
	    return _this6;
	  }

	  _createClass(OptionStatementContext, [{
	    key: "OPTION",
	    value: function OPTION() {
	      return this.getToken(Protobuf3Parser.OPTION, 0);
	    }
	  }, {
	    key: "optionName",
	    value: function optionName() {
	      return this.getTypedRuleContext(OptionNameContext, 0);
	    }
	  }, {
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(Protobuf3Parser.EQ, 0);
	    }
	  }, {
	    key: "constant",
	    value: function constant() {
	      return this.getTypedRuleContext(ConstantContext, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterOptionStatement(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitOptionStatement(this);
	      }
	    }
	  }]);

	  return OptionStatementContext;
	}(_antlr["default"].ParserRuleContext);

	var OptionNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon6) {
	  _inherits(OptionNameContext, _antlr4$ParserRuleCon6);

	  var _super7 = _createSuper(OptionNameContext);

	  function OptionNameContext(parser, parent, invokingState) {
	    var _this7;

	    _classCallCheck(this, OptionNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this7 = _super7.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this7), "fullIdent", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(FullIdentContext);
	      } else {
	        return this.getTypedRuleContext(FullIdentContext, i);
	      }
	    });

	    _this7.parser = parser;
	    _this7.ruleIndex = Protobuf3Parser.RULE_optionName;
	    return _this7;
	  }

	  _createClass(OptionNameContext, [{
	    key: "LP",
	    value: function LP() {
	      return this.getToken(Protobuf3Parser.LP, 0);
	    }
	  }, {
	    key: "RP",
	    value: function RP() {
	      return this.getToken(Protobuf3Parser.RP, 0);
	    }
	  }, {
	    key: "DOT",
	    value: function DOT() {
	      return this.getToken(Protobuf3Parser.DOT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterOptionName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitOptionName(this);
	      }
	    }
	  }]);

	  return OptionNameContext;
	}(_antlr["default"].ParserRuleContext);

	var ExtendsStatementContext = /*#__PURE__*/function (_antlr4$ParserRuleCon7) {
	  _inherits(ExtendsStatementContext, _antlr4$ParserRuleCon7);

	  var _super8 = _createSuper(ExtendsStatementContext);

	  function ExtendsStatementContext(parser, parent, invokingState) {
	    var _this8;

	    _classCallCheck(this, ExtendsStatementContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this8 = _super8.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this8), "field", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(FieldContext);
	      } else {
	        return this.getTypedRuleContext(FieldContext, i);
	      }
	    });

	    _this8.parser = parser;
	    _this8.ruleIndex = Protobuf3Parser.RULE_extendsStatement;
	    return _this8;
	  }

	  _createClass(ExtendsStatementContext, [{
	    key: "EXTEND",
	    value: function EXTEND() {
	      return this.getToken(Protobuf3Parser.EXTEND, 0);
	    }
	  }, {
	    key: "extendedIdentifier",
	    value: function extendedIdentifier() {
	      return this.getTypedRuleContext(ExtendedIdentifierContext, 0);
	    }
	  }, {
	    key: "LC",
	    value: function LC() {
	      return this.getToken(Protobuf3Parser.LC, 0);
	    }
	  }, {
	    key: "RC",
	    value: function RC() {
	      return this.getToken(Protobuf3Parser.RC, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterExtendsStatement(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitExtendsStatement(this);
	      }
	    }
	  }]);

	  return ExtendsStatementContext;
	}(_antlr["default"].ParserRuleContext);

	var ExtendedIdentifierContext = /*#__PURE__*/function (_antlr4$ParserRuleCon8) {
	  _inherits(ExtendedIdentifierContext, _antlr4$ParserRuleCon8);

	  var _super9 = _createSuper(ExtendedIdentifierContext);

	  function ExtendedIdentifierContext(parser, parent, invokingState) {
	    var _this9;

	    _classCallCheck(this, ExtendedIdentifierContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this9 = _super9.call(this, parent, invokingState);
	    _this9.parser = parser;
	    _this9.ruleIndex = Protobuf3Parser.RULE_extendedIdentifier;
	    return _this9;
	  }

	  _createClass(ExtendedIdentifierContext, [{
	    key: "FIELD_OPTIONS",
	    value: function FIELD_OPTIONS() {
	      return this.getToken(Protobuf3Parser.FIELD_OPTIONS, 0);
	    }
	  }, {
	    key: "ENUM_OPTIONS",
	    value: function ENUM_OPTIONS() {
	      return this.getToken(Protobuf3Parser.ENUM_OPTIONS, 0);
	    }
	  }, {
	    key: "ENUM_VALUE_OPTIONS",
	    value: function ENUM_VALUE_OPTIONS() {
	      return this.getToken(Protobuf3Parser.ENUM_VALUE_OPTIONS, 0);
	    }
	  }, {
	    key: "EXTENSION_RANGE_OPTIONS",
	    value: function EXTENSION_RANGE_OPTIONS() {
	      return this.getToken(Protobuf3Parser.EXTENSION_RANGE_OPTIONS, 0);
	    }
	  }, {
	    key: "MESSAGE_OPTIONS",
	    value: function MESSAGE_OPTIONS() {
	      return this.getToken(Protobuf3Parser.MESSAGE_OPTIONS, 0);
	    }
	  }, {
	    key: "METHOD_OPTIONS",
	    value: function METHOD_OPTIONS() {
	      return this.getToken(Protobuf3Parser.METHOD_OPTIONS, 0);
	    }
	  }, {
	    key: "SERVICE_OPTIONS",
	    value: function SERVICE_OPTIONS() {
	      return this.getToken(Protobuf3Parser.SERVICE_OPTIONS, 0);
	    }
	  }, {
	    key: "FILE_OPTIONS",
	    value: function FILE_OPTIONS() {
	      return this.getToken(Protobuf3Parser.FILE_OPTIONS, 0);
	    }
	  }, {
	    key: "ONEOF_OPTIONS",
	    value: function ONEOF_OPTIONS() {
	      return this.getToken(Protobuf3Parser.ONEOF_OPTIONS, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterExtendedIdentifier(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitExtendedIdentifier(this);
	      }
	    }
	  }]);

	  return ExtendedIdentifierContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldContext = /*#__PURE__*/function (_antlr4$ParserRuleCon9) {
	  _inherits(FieldContext, _antlr4$ParserRuleCon9);

	  var _super10 = _createSuper(FieldContext);

	  function FieldContext(parser, parent, invokingState) {
	    var _this10;

	    _classCallCheck(this, FieldContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this10 = _super10.call(this, parent, invokingState);
	    _this10.parser = parser;
	    _this10.ruleIndex = Protobuf3Parser.RULE_field;
	    return _this10;
	  }

	  _createClass(FieldContext, [{
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "fieldName",
	    value: function fieldName() {
	      return this.getTypedRuleContext(FieldNameContext, 0);
	    }
	  }, {
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(Protobuf3Parser.EQ, 0);
	    }
	  }, {
	    key: "fieldNumber",
	    value: function fieldNumber() {
	      return this.getTypedRuleContext(FieldNumberContext, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "REPEATED",
	    value: function REPEATED() {
	      return this.getToken(Protobuf3Parser.REPEATED, 0);
	    }
	  }, {
	    key: "LB",
	    value: function LB() {
	      return this.getToken(Protobuf3Parser.LB, 0);
	    }
	  }, {
	    key: "fieldOptions",
	    value: function fieldOptions() {
	      return this.getTypedRuleContext(FieldOptionsContext, 0);
	    }
	  }, {
	    key: "RB",
	    value: function RB() {
	      return this.getToken(Protobuf3Parser.RB, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterField(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitField(this);
	      }
	    }
	  }]);

	  return FieldContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldOptionsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon10) {
	  _inherits(FieldOptionsContext, _antlr4$ParserRuleCon10);

	  var _super11 = _createSuper(FieldOptionsContext);

	  function FieldOptionsContext(parser, parent, invokingState) {
	    var _this11;

	    _classCallCheck(this, FieldOptionsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this11 = _super11.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this11), "fieldOption", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(FieldOptionContext);
	      } else {
	        return this.getTypedRuleContext(FieldOptionContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this11), "COMMA", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.COMMA);
	      } else {
	        return this.getToken(Protobuf3Parser.COMMA, i);
	      }
	    });

	    _this11.parser = parser;
	    _this11.ruleIndex = Protobuf3Parser.RULE_fieldOptions;
	    return _this11;
	  }

	  _createClass(FieldOptionsContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterFieldOptions(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitFieldOptions(this);
	      }
	    }
	  }]);

	  return FieldOptionsContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldOptionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon11) {
	  _inherits(FieldOptionContext, _antlr4$ParserRuleCon11);

	  var _super12 = _createSuper(FieldOptionContext);

	  function FieldOptionContext(parser, parent, invokingState) {
	    var _this12;

	    _classCallCheck(this, FieldOptionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this12 = _super12.call(this, parent, invokingState);
	    _this12.parser = parser;
	    _this12.ruleIndex = Protobuf3Parser.RULE_fieldOption;
	    return _this12;
	  }

	  _createClass(FieldOptionContext, [{
	    key: "optionName",
	    value: function optionName() {
	      return this.getTypedRuleContext(OptionNameContext, 0);
	    }
	  }, {
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(Protobuf3Parser.EQ, 0);
	    }
	  }, {
	    key: "constant",
	    value: function constant() {
	      return this.getTypedRuleContext(ConstantContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterFieldOption(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitFieldOption(this);
	      }
	    }
	  }]);

	  return FieldOptionContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldNumberContext = /*#__PURE__*/function (_antlr4$ParserRuleCon12) {
	  _inherits(FieldNumberContext, _antlr4$ParserRuleCon12);

	  var _super13 = _createSuper(FieldNumberContext);

	  function FieldNumberContext(parser, parent, invokingState) {
	    var _this13;

	    _classCallCheck(this, FieldNumberContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this13 = _super13.call(this, parent, invokingState);
	    _this13.parser = parser;
	    _this13.ruleIndex = Protobuf3Parser.RULE_fieldNumber;
	    return _this13;
	  }

	  _createClass(FieldNumberContext, [{
	    key: "intLit",
	    value: function intLit() {
	      return this.getTypedRuleContext(IntLitContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterFieldNumber(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitFieldNumber(this);
	      }
	    }
	  }]);

	  return FieldNumberContext;
	}(_antlr["default"].ParserRuleContext);

	var OneofContext = /*#__PURE__*/function (_antlr4$ParserRuleCon13) {
	  _inherits(OneofContext, _antlr4$ParserRuleCon13);

	  var _super14 = _createSuper(OneofContext);

	  function OneofContext(parser, parent, invokingState) {
	    var _this14;

	    _classCallCheck(this, OneofContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this14 = _super14.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this14), "optionStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(OptionStatementContext);
	      } else {
	        return this.getTypedRuleContext(OptionStatementContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this14), "oneofField", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(OneofFieldContext);
	      } else {
	        return this.getTypedRuleContext(OneofFieldContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this14), "emptyStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EmptyStatementContext);
	      } else {
	        return this.getTypedRuleContext(EmptyStatementContext, i);
	      }
	    });

	    _this14.parser = parser;
	    _this14.ruleIndex = Protobuf3Parser.RULE_oneof;
	    return _this14;
	  }

	  _createClass(OneofContext, [{
	    key: "ONEOF",
	    value: function ONEOF() {
	      return this.getToken(Protobuf3Parser.ONEOF, 0);
	    }
	  }, {
	    key: "oneofName",
	    value: function oneofName() {
	      return this.getTypedRuleContext(OneofNameContext, 0);
	    }
	  }, {
	    key: "LC",
	    value: function LC() {
	      return this.getToken(Protobuf3Parser.LC, 0);
	    }
	  }, {
	    key: "RC",
	    value: function RC() {
	      return this.getToken(Protobuf3Parser.RC, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterOneof(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitOneof(this);
	      }
	    }
	  }]);

	  return OneofContext;
	}(_antlr["default"].ParserRuleContext);

	var OneofFieldContext = /*#__PURE__*/function (_antlr4$ParserRuleCon14) {
	  _inherits(OneofFieldContext, _antlr4$ParserRuleCon14);

	  var _super15 = _createSuper(OneofFieldContext);

	  function OneofFieldContext(parser, parent, invokingState) {
	    var _this15;

	    _classCallCheck(this, OneofFieldContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this15 = _super15.call(this, parent, invokingState);
	    _this15.parser = parser;
	    _this15.ruleIndex = Protobuf3Parser.RULE_oneofField;
	    return _this15;
	  }

	  _createClass(OneofFieldContext, [{
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "fieldName",
	    value: function fieldName() {
	      return this.getTypedRuleContext(FieldNameContext, 0);
	    }
	  }, {
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(Protobuf3Parser.EQ, 0);
	    }
	  }, {
	    key: "fieldNumber",
	    value: function fieldNumber() {
	      return this.getTypedRuleContext(FieldNumberContext, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "LB",
	    value: function LB() {
	      return this.getToken(Protobuf3Parser.LB, 0);
	    }
	  }, {
	    key: "fieldOptions",
	    value: function fieldOptions() {
	      return this.getTypedRuleContext(FieldOptionsContext, 0);
	    }
	  }, {
	    key: "RB",
	    value: function RB() {
	      return this.getToken(Protobuf3Parser.RB, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterOneofField(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitOneofField(this);
	      }
	    }
	  }]);

	  return OneofFieldContext;
	}(_antlr["default"].ParserRuleContext);

	var MapFieldContext = /*#__PURE__*/function (_antlr4$ParserRuleCon15) {
	  _inherits(MapFieldContext, _antlr4$ParserRuleCon15);

	  var _super16 = _createSuper(MapFieldContext);

	  function MapFieldContext(parser, parent, invokingState) {
	    var _this16;

	    _classCallCheck(this, MapFieldContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this16 = _super16.call(this, parent, invokingState);
	    _this16.parser = parser;
	    _this16.ruleIndex = Protobuf3Parser.RULE_mapField;
	    return _this16;
	  }

	  _createClass(MapFieldContext, [{
	    key: "MAP",
	    value: function MAP() {
	      return this.getToken(Protobuf3Parser.MAP, 0);
	    }
	  }, {
	    key: "LT",
	    value: function LT() {
	      return this.getToken(Protobuf3Parser.LT, 0);
	    }
	  }, {
	    key: "keyType",
	    value: function keyType() {
	      return this.getTypedRuleContext(KeyTypeContext, 0);
	    }
	  }, {
	    key: "COMMA",
	    value: function COMMA() {
	      return this.getToken(Protobuf3Parser.COMMA, 0);
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "GT",
	    value: function GT() {
	      return this.getToken(Protobuf3Parser.GT, 0);
	    }
	  }, {
	    key: "mapName",
	    value: function mapName() {
	      return this.getTypedRuleContext(MapNameContext, 0);
	    }
	  }, {
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(Protobuf3Parser.EQ, 0);
	    }
	  }, {
	    key: "fieldNumber",
	    value: function fieldNumber() {
	      return this.getTypedRuleContext(FieldNumberContext, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "LB",
	    value: function LB() {
	      return this.getToken(Protobuf3Parser.LB, 0);
	    }
	  }, {
	    key: "fieldOptions",
	    value: function fieldOptions() {
	      return this.getTypedRuleContext(FieldOptionsContext, 0);
	    }
	  }, {
	    key: "RB",
	    value: function RB() {
	      return this.getToken(Protobuf3Parser.RB, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterMapField(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitMapField(this);
	      }
	    }
	  }]);

	  return MapFieldContext;
	}(_antlr["default"].ParserRuleContext);

	var KeyTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon16) {
	  _inherits(KeyTypeContext, _antlr4$ParserRuleCon16);

	  var _super17 = _createSuper(KeyTypeContext);

	  function KeyTypeContext(parser, parent, invokingState) {
	    var _this17;

	    _classCallCheck(this, KeyTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this17 = _super17.call(this, parent, invokingState);
	    _this17.parser = parser;
	    _this17.ruleIndex = Protobuf3Parser.RULE_keyType;
	    return _this17;
	  }

	  _createClass(KeyTypeContext, [{
	    key: "INT32",
	    value: function INT32() {
	      return this.getToken(Protobuf3Parser.INT32, 0);
	    }
	  }, {
	    key: "INT64",
	    value: function INT64() {
	      return this.getToken(Protobuf3Parser.INT64, 0);
	    }
	  }, {
	    key: "UINT32",
	    value: function UINT32() {
	      return this.getToken(Protobuf3Parser.UINT32, 0);
	    }
	  }, {
	    key: "UINT64",
	    value: function UINT64() {
	      return this.getToken(Protobuf3Parser.UINT64, 0);
	    }
	  }, {
	    key: "SINT32",
	    value: function SINT32() {
	      return this.getToken(Protobuf3Parser.SINT32, 0);
	    }
	  }, {
	    key: "SINT64",
	    value: function SINT64() {
	      return this.getToken(Protobuf3Parser.SINT64, 0);
	    }
	  }, {
	    key: "FIXED32",
	    value: function FIXED32() {
	      return this.getToken(Protobuf3Parser.FIXED32, 0);
	    }
	  }, {
	    key: "FIXED64",
	    value: function FIXED64() {
	      return this.getToken(Protobuf3Parser.FIXED64, 0);
	    }
	  }, {
	    key: "SFIXED32",
	    value: function SFIXED32() {
	      return this.getToken(Protobuf3Parser.SFIXED32, 0);
	    }
	  }, {
	    key: "SFIXED64",
	    value: function SFIXED64() {
	      return this.getToken(Protobuf3Parser.SFIXED64, 0);
	    }
	  }, {
	    key: "BOOL",
	    value: function BOOL() {
	      return this.getToken(Protobuf3Parser.BOOL, 0);
	    }
	  }, {
	    key: "STRING",
	    value: function STRING() {
	      return this.getToken(Protobuf3Parser.STRING, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterKeyType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitKeyType(this);
	      }
	    }
	  }]);

	  return KeyTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var Type_Context = /*#__PURE__*/function (_antlr4$ParserRuleCon17) {
	  _inherits(Type_Context, _antlr4$ParserRuleCon17);

	  var _super18 = _createSuper(Type_Context);

	  function Type_Context(parser, parent, invokingState) {
	    var _this18;

	    _classCallCheck(this, Type_Context);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this18 = _super18.call(this, parent, invokingState);
	    _this18.parser = parser;
	    _this18.ruleIndex = Protobuf3Parser.RULE_type_;
	    return _this18;
	  }

	  _createClass(Type_Context, [{
	    key: "DOUBLE",
	    value: function DOUBLE() {
	      return this.getToken(Protobuf3Parser.DOUBLE, 0);
	    }
	  }, {
	    key: "FLOAT",
	    value: function FLOAT() {
	      return this.getToken(Protobuf3Parser.FLOAT, 0);
	    }
	  }, {
	    key: "INT32",
	    value: function INT32() {
	      return this.getToken(Protobuf3Parser.INT32, 0);
	    }
	  }, {
	    key: "INT64",
	    value: function INT64() {
	      return this.getToken(Protobuf3Parser.INT64, 0);
	    }
	  }, {
	    key: "UINT32",
	    value: function UINT32() {
	      return this.getToken(Protobuf3Parser.UINT32, 0);
	    }
	  }, {
	    key: "UINT64",
	    value: function UINT64() {
	      return this.getToken(Protobuf3Parser.UINT64, 0);
	    }
	  }, {
	    key: "SINT32",
	    value: function SINT32() {
	      return this.getToken(Protobuf3Parser.SINT32, 0);
	    }
	  }, {
	    key: "SINT64",
	    value: function SINT64() {
	      return this.getToken(Protobuf3Parser.SINT64, 0);
	    }
	  }, {
	    key: "FIXED32",
	    value: function FIXED32() {
	      return this.getToken(Protobuf3Parser.FIXED32, 0);
	    }
	  }, {
	    key: "FIXED64",
	    value: function FIXED64() {
	      return this.getToken(Protobuf3Parser.FIXED64, 0);
	    }
	  }, {
	    key: "SFIXED32",
	    value: function SFIXED32() {
	      return this.getToken(Protobuf3Parser.SFIXED32, 0);
	    }
	  }, {
	    key: "SFIXED64",
	    value: function SFIXED64() {
	      return this.getToken(Protobuf3Parser.SFIXED64, 0);
	    }
	  }, {
	    key: "BOOL",
	    value: function BOOL() {
	      return this.getToken(Protobuf3Parser.BOOL, 0);
	    }
	  }, {
	    key: "STRING",
	    value: function STRING() {
	      return this.getToken(Protobuf3Parser.STRING, 0);
	    }
	  }, {
	    key: "BYTES",
	    value: function BYTES() {
	      return this.getToken(Protobuf3Parser.BYTES, 0);
	    }
	  }, {
	    key: "messageType",
	    value: function messageType() {
	      return this.getTypedRuleContext(MessageTypeContext, 0);
	    }
	  }, {
	    key: "enumType",
	    value: function enumType() {
	      return this.getTypedRuleContext(EnumTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterType_(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitType_(this);
	      }
	    }
	  }]);

	  return Type_Context;
	}(_antlr["default"].ParserRuleContext);

	var ReservedContext = /*#__PURE__*/function (_antlr4$ParserRuleCon18) {
	  _inherits(ReservedContext, _antlr4$ParserRuleCon18);

	  var _super19 = _createSuper(ReservedContext);

	  function ReservedContext(parser, parent, invokingState) {
	    var _this19;

	    _classCallCheck(this, ReservedContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this19 = _super19.call(this, parent, invokingState);
	    _this19.parser = parser;
	    _this19.ruleIndex = Protobuf3Parser.RULE_reserved;
	    return _this19;
	  }

	  _createClass(ReservedContext, [{
	    key: "RESERVED",
	    value: function RESERVED() {
	      return this.getToken(Protobuf3Parser.RESERVED, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "ranges",
	    value: function ranges() {
	      return this.getTypedRuleContext(RangesContext, 0);
	    }
	  }, {
	    key: "reservedFieldNames",
	    value: function reservedFieldNames() {
	      return this.getTypedRuleContext(ReservedFieldNamesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterReserved(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitReserved(this);
	      }
	    }
	  }]);

	  return ReservedContext;
	}(_antlr["default"].ParserRuleContext);

	var RangesContext = /*#__PURE__*/function (_antlr4$ParserRuleCon19) {
	  _inherits(RangesContext, _antlr4$ParserRuleCon19);

	  var _super20 = _createSuper(RangesContext);

	  function RangesContext(parser, parent, invokingState) {
	    var _this20;

	    _classCallCheck(this, RangesContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this20 = _super20.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this20), "range_", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(Range_Context);
	      } else {
	        return this.getTypedRuleContext(Range_Context, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this20), "COMMA", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.COMMA);
	      } else {
	        return this.getToken(Protobuf3Parser.COMMA, i);
	      }
	    });

	    _this20.parser = parser;
	    _this20.ruleIndex = Protobuf3Parser.RULE_ranges;
	    return _this20;
	  }

	  _createClass(RangesContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterRanges(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitRanges(this);
	      }
	    }
	  }]);

	  return RangesContext;
	}(_antlr["default"].ParserRuleContext);

	var Range_Context = /*#__PURE__*/function (_antlr4$ParserRuleCon20) {
	  _inherits(Range_Context, _antlr4$ParserRuleCon20);

	  var _super21 = _createSuper(Range_Context);

	  function Range_Context(parser, parent, invokingState) {
	    var _this21;

	    _classCallCheck(this, Range_Context);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this21 = _super21.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this21), "intLit", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(IntLitContext);
	      } else {
	        return this.getTypedRuleContext(IntLitContext, i);
	      }
	    });

	    _this21.parser = parser;
	    _this21.ruleIndex = Protobuf3Parser.RULE_range_;
	    return _this21;
	  }

	  _createClass(Range_Context, [{
	    key: "TO",
	    value: function TO() {
	      return this.getToken(Protobuf3Parser.TO, 0);
	    }
	  }, {
	    key: "MAX",
	    value: function MAX() {
	      return this.getToken(Protobuf3Parser.MAX, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterRange_(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitRange_(this);
	      }
	    }
	  }]);

	  return Range_Context;
	}(_antlr["default"].ParserRuleContext);

	var ReservedFieldNamesContext = /*#__PURE__*/function (_antlr4$ParserRuleCon21) {
	  _inherits(ReservedFieldNamesContext, _antlr4$ParserRuleCon21);

	  var _super22 = _createSuper(ReservedFieldNamesContext);

	  function ReservedFieldNamesContext(parser, parent, invokingState) {
	    var _this22;

	    _classCallCheck(this, ReservedFieldNamesContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this22 = _super22.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this22), "strLit", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(StrLitContext);
	      } else {
	        return this.getTypedRuleContext(StrLitContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this22), "COMMA", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.COMMA);
	      } else {
	        return this.getToken(Protobuf3Parser.COMMA, i);
	      }
	    });

	    _this22.parser = parser;
	    _this22.ruleIndex = Protobuf3Parser.RULE_reservedFieldNames;
	    return _this22;
	  }

	  _createClass(ReservedFieldNamesContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterReservedFieldNames(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitReservedFieldNames(this);
	      }
	    }
	  }]);

	  return ReservedFieldNamesContext;
	}(_antlr["default"].ParserRuleContext);

	var TopLevelDefContext = /*#__PURE__*/function (_antlr4$ParserRuleCon22) {
	  _inherits(TopLevelDefContext, _antlr4$ParserRuleCon22);

	  var _super23 = _createSuper(TopLevelDefContext);

	  function TopLevelDefContext(parser, parent, invokingState) {
	    var _this23;

	    _classCallCheck(this, TopLevelDefContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this23 = _super23.call(this, parent, invokingState);
	    _this23.parser = parser;
	    _this23.ruleIndex = Protobuf3Parser.RULE_topLevelDef;
	    return _this23;
	  }

	  _createClass(TopLevelDefContext, [{
	    key: "messageDef",
	    value: function messageDef() {
	      return this.getTypedRuleContext(MessageDefContext, 0);
	    }
	  }, {
	    key: "enumDef",
	    value: function enumDef() {
	      return this.getTypedRuleContext(EnumDefContext, 0);
	    }
	  }, {
	    key: "serviceDef",
	    value: function serviceDef() {
	      return this.getTypedRuleContext(ServiceDefContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterTopLevelDef(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitTopLevelDef(this);
	      }
	    }
	  }]);

	  return TopLevelDefContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumDefContext = /*#__PURE__*/function (_antlr4$ParserRuleCon23) {
	  _inherits(EnumDefContext, _antlr4$ParserRuleCon23);

	  var _super24 = _createSuper(EnumDefContext);

	  function EnumDefContext(parser, parent, invokingState) {
	    var _this24;

	    _classCallCheck(this, EnumDefContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this24 = _super24.call(this, parent, invokingState);
	    _this24.parser = parser;
	    _this24.ruleIndex = Protobuf3Parser.RULE_enumDef;
	    return _this24;
	  }

	  _createClass(EnumDefContext, [{
	    key: "ENUM",
	    value: function ENUM() {
	      return this.getToken(Protobuf3Parser.ENUM, 0);
	    }
	  }, {
	    key: "enumName",
	    value: function enumName() {
	      return this.getTypedRuleContext(EnumNameContext, 0);
	    }
	  }, {
	    key: "enumBody",
	    value: function enumBody() {
	      return this.getTypedRuleContext(EnumBodyContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEnumDef(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEnumDef(this);
	      }
	    }
	  }]);

	  return EnumDefContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumBodyContext = /*#__PURE__*/function (_antlr4$ParserRuleCon24) {
	  _inherits(EnumBodyContext, _antlr4$ParserRuleCon24);

	  var _super25 = _createSuper(EnumBodyContext);

	  function EnumBodyContext(parser, parent, invokingState) {
	    var _this25;

	    _classCallCheck(this, EnumBodyContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this25 = _super25.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this25), "enumElement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EnumElementContext);
	      } else {
	        return this.getTypedRuleContext(EnumElementContext, i);
	      }
	    });

	    _this25.parser = parser;
	    _this25.ruleIndex = Protobuf3Parser.RULE_enumBody;
	    return _this25;
	  }

	  _createClass(EnumBodyContext, [{
	    key: "LC",
	    value: function LC() {
	      return this.getToken(Protobuf3Parser.LC, 0);
	    }
	  }, {
	    key: "RC",
	    value: function RC() {
	      return this.getToken(Protobuf3Parser.RC, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEnumBody(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEnumBody(this);
	      }
	    }
	  }]);

	  return EnumBodyContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumElementContext = /*#__PURE__*/function (_antlr4$ParserRuleCon25) {
	  _inherits(EnumElementContext, _antlr4$ParserRuleCon25);

	  var _super26 = _createSuper(EnumElementContext);

	  function EnumElementContext(parser, parent, invokingState) {
	    var _this26;

	    _classCallCheck(this, EnumElementContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this26 = _super26.call(this, parent, invokingState);
	    _this26.parser = parser;
	    _this26.ruleIndex = Protobuf3Parser.RULE_enumElement;
	    return _this26;
	  }

	  _createClass(EnumElementContext, [{
	    key: "optionStatement",
	    value: function optionStatement() {
	      return this.getTypedRuleContext(OptionStatementContext, 0);
	    }
	  }, {
	    key: "enumField",
	    value: function enumField() {
	      return this.getTypedRuleContext(EnumFieldContext, 0);
	    }
	  }, {
	    key: "emptyStatement",
	    value: function emptyStatement() {
	      return this.getTypedRuleContext(EmptyStatementContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEnumElement(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEnumElement(this);
	      }
	    }
	  }]);

	  return EnumElementContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumFieldContext = /*#__PURE__*/function (_antlr4$ParserRuleCon26) {
	  _inherits(EnumFieldContext, _antlr4$ParserRuleCon26);

	  var _super27 = _createSuper(EnumFieldContext);

	  function EnumFieldContext(parser, parent, invokingState) {
	    var _this27;

	    _classCallCheck(this, EnumFieldContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this27 = _super27.call(this, parent, invokingState);
	    _this27.parser = parser;
	    _this27.ruleIndex = Protobuf3Parser.RULE_enumField;
	    return _this27;
	  }

	  _createClass(EnumFieldContext, [{
	    key: "ident",
	    value: function ident() {
	      return this.getTypedRuleContext(IdentContext, 0);
	    }
	  }, {
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(Protobuf3Parser.EQ, 0);
	    }
	  }, {
	    key: "intLit",
	    value: function intLit() {
	      return this.getTypedRuleContext(IntLitContext, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "MINUS",
	    value: function MINUS() {
	      return this.getToken(Protobuf3Parser.MINUS, 0);
	    }
	  }, {
	    key: "enumValueOptions",
	    value: function enumValueOptions() {
	      return this.getTypedRuleContext(EnumValueOptionsContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEnumField(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEnumField(this);
	      }
	    }
	  }]);

	  return EnumFieldContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValueOptionsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon27) {
	  _inherits(EnumValueOptionsContext, _antlr4$ParserRuleCon27);

	  var _super28 = _createSuper(EnumValueOptionsContext);

	  function EnumValueOptionsContext(parser, parent, invokingState) {
	    var _this28;

	    _classCallCheck(this, EnumValueOptionsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this28 = _super28.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this28), "enumValueOption", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EnumValueOptionContext);
	      } else {
	        return this.getTypedRuleContext(EnumValueOptionContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this28), "COMMA", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.COMMA);
	      } else {
	        return this.getToken(Protobuf3Parser.COMMA, i);
	      }
	    });

	    _this28.parser = parser;
	    _this28.ruleIndex = Protobuf3Parser.RULE_enumValueOptions;
	    return _this28;
	  }

	  _createClass(EnumValueOptionsContext, [{
	    key: "LB",
	    value: function LB() {
	      return this.getToken(Protobuf3Parser.LB, 0);
	    }
	  }, {
	    key: "RB",
	    value: function RB() {
	      return this.getToken(Protobuf3Parser.RB, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEnumValueOptions(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEnumValueOptions(this);
	      }
	    }
	  }]);

	  return EnumValueOptionsContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValueOptionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon28) {
	  _inherits(EnumValueOptionContext, _antlr4$ParserRuleCon28);

	  var _super29 = _createSuper(EnumValueOptionContext);

	  function EnumValueOptionContext(parser, parent, invokingState) {
	    var _this29;

	    _classCallCheck(this, EnumValueOptionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this29 = _super29.call(this, parent, invokingState);
	    _this29.parser = parser;
	    _this29.ruleIndex = Protobuf3Parser.RULE_enumValueOption;
	    return _this29;
	  }

	  _createClass(EnumValueOptionContext, [{
	    key: "optionName",
	    value: function optionName() {
	      return this.getTypedRuleContext(OptionNameContext, 0);
	    }
	  }, {
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(Protobuf3Parser.EQ, 0);
	    }
	  }, {
	    key: "constant",
	    value: function constant() {
	      return this.getTypedRuleContext(ConstantContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEnumValueOption(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEnumValueOption(this);
	      }
	    }
	  }]);

	  return EnumValueOptionContext;
	}(_antlr["default"].ParserRuleContext);

	var MessageDefContext = /*#__PURE__*/function (_antlr4$ParserRuleCon29) {
	  _inherits(MessageDefContext, _antlr4$ParserRuleCon29);

	  var _super30 = _createSuper(MessageDefContext);

	  function MessageDefContext(parser, parent, invokingState) {
	    var _this30;

	    _classCallCheck(this, MessageDefContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this30 = _super30.call(this, parent, invokingState);
	    _this30.parser = parser;
	    _this30.ruleIndex = Protobuf3Parser.RULE_messageDef;
	    return _this30;
	  }

	  _createClass(MessageDefContext, [{
	    key: "MESSAGE",
	    value: function MESSAGE() {
	      return this.getToken(Protobuf3Parser.MESSAGE, 0);
	    }
	  }, {
	    key: "messageName",
	    value: function messageName() {
	      return this.getTypedRuleContext(MessageNameContext, 0);
	    }
	  }, {
	    key: "messageBody",
	    value: function messageBody() {
	      return this.getTypedRuleContext(MessageBodyContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterMessageDef(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitMessageDef(this);
	      }
	    }
	  }]);

	  return MessageDefContext;
	}(_antlr["default"].ParserRuleContext);

	var MessageBodyContext = /*#__PURE__*/function (_antlr4$ParserRuleCon30) {
	  _inherits(MessageBodyContext, _antlr4$ParserRuleCon30);

	  var _super31 = _createSuper(MessageBodyContext);

	  function MessageBodyContext(parser, parent, invokingState) {
	    var _this31;

	    _classCallCheck(this, MessageBodyContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this31 = _super31.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this31), "messageElement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(MessageElementContext);
	      } else {
	        return this.getTypedRuleContext(MessageElementContext, i);
	      }
	    });

	    _this31.parser = parser;
	    _this31.ruleIndex = Protobuf3Parser.RULE_messageBody;
	    return _this31;
	  }

	  _createClass(MessageBodyContext, [{
	    key: "LC",
	    value: function LC() {
	      return this.getToken(Protobuf3Parser.LC, 0);
	    }
	  }, {
	    key: "RC",
	    value: function RC() {
	      return this.getToken(Protobuf3Parser.RC, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterMessageBody(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitMessageBody(this);
	      }
	    }
	  }]);

	  return MessageBodyContext;
	}(_antlr["default"].ParserRuleContext);

	var MessageElementContext = /*#__PURE__*/function (_antlr4$ParserRuleCon31) {
	  _inherits(MessageElementContext, _antlr4$ParserRuleCon31);

	  var _super32 = _createSuper(MessageElementContext);

	  function MessageElementContext(parser, parent, invokingState) {
	    var _this32;

	    _classCallCheck(this, MessageElementContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this32 = _super32.call(this, parent, invokingState);
	    _this32.parser = parser;
	    _this32.ruleIndex = Protobuf3Parser.RULE_messageElement;
	    return _this32;
	  }

	  _createClass(MessageElementContext, [{
	    key: "field",
	    value: function field() {
	      return this.getTypedRuleContext(FieldContext, 0);
	    }
	  }, {
	    key: "enumDef",
	    value: function enumDef() {
	      return this.getTypedRuleContext(EnumDefContext, 0);
	    }
	  }, {
	    key: "messageDef",
	    value: function messageDef() {
	      return this.getTypedRuleContext(MessageDefContext, 0);
	    }
	  }, {
	    key: "optionStatement",
	    value: function optionStatement() {
	      return this.getTypedRuleContext(OptionStatementContext, 0);
	    }
	  }, {
	    key: "oneof",
	    value: function oneof() {
	      return this.getTypedRuleContext(OneofContext, 0);
	    }
	  }, {
	    key: "mapField",
	    value: function mapField() {
	      return this.getTypedRuleContext(MapFieldContext, 0);
	    }
	  }, {
	    key: "reserved",
	    value: function reserved() {
	      return this.getTypedRuleContext(ReservedContext, 0);
	    }
	  }, {
	    key: "emptyStatement",
	    value: function emptyStatement() {
	      return this.getTypedRuleContext(EmptyStatementContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterMessageElement(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitMessageElement(this);
	      }
	    }
	  }]);

	  return MessageElementContext;
	}(_antlr["default"].ParserRuleContext);

	var ServiceDefContext = /*#__PURE__*/function (_antlr4$ParserRuleCon32) {
	  _inherits(ServiceDefContext, _antlr4$ParserRuleCon32);

	  var _super33 = _createSuper(ServiceDefContext);

	  function ServiceDefContext(parser, parent, invokingState) {
	    var _this33;

	    _classCallCheck(this, ServiceDefContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this33 = _super33.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this33), "serviceElement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ServiceElementContext);
	      } else {
	        return this.getTypedRuleContext(ServiceElementContext, i);
	      }
	    });

	    _this33.parser = parser;
	    _this33.ruleIndex = Protobuf3Parser.RULE_serviceDef;
	    return _this33;
	  }

	  _createClass(ServiceDefContext, [{
	    key: "SERVICE",
	    value: function SERVICE() {
	      return this.getToken(Protobuf3Parser.SERVICE, 0);
	    }
	  }, {
	    key: "serviceName",
	    value: function serviceName() {
	      return this.getTypedRuleContext(ServiceNameContext, 0);
	    }
	  }, {
	    key: "LC",
	    value: function LC() {
	      return this.getToken(Protobuf3Parser.LC, 0);
	    }
	  }, {
	    key: "RC",
	    value: function RC() {
	      return this.getToken(Protobuf3Parser.RC, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterServiceDef(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitServiceDef(this);
	      }
	    }
	  }]);

	  return ServiceDefContext;
	}(_antlr["default"].ParserRuleContext);

	var ServiceElementContext = /*#__PURE__*/function (_antlr4$ParserRuleCon33) {
	  _inherits(ServiceElementContext, _antlr4$ParserRuleCon33);

	  var _super34 = _createSuper(ServiceElementContext);

	  function ServiceElementContext(parser, parent, invokingState) {
	    var _this34;

	    _classCallCheck(this, ServiceElementContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this34 = _super34.call(this, parent, invokingState);
	    _this34.parser = parser;
	    _this34.ruleIndex = Protobuf3Parser.RULE_serviceElement;
	    return _this34;
	  }

	  _createClass(ServiceElementContext, [{
	    key: "optionStatement",
	    value: function optionStatement() {
	      return this.getTypedRuleContext(OptionStatementContext, 0);
	    }
	  }, {
	    key: "rpc",
	    value: function rpc() {
	      return this.getTypedRuleContext(RpcContext, 0);
	    }
	  }, {
	    key: "emptyStatement",
	    value: function emptyStatement() {
	      return this.getTypedRuleContext(EmptyStatementContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterServiceElement(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitServiceElement(this);
	      }
	    }
	  }]);

	  return ServiceElementContext;
	}(_antlr["default"].ParserRuleContext);

	var RpcContext = /*#__PURE__*/function (_antlr4$ParserRuleCon34) {
	  _inherits(RpcContext, _antlr4$ParserRuleCon34);

	  var _super35 = _createSuper(RpcContext);

	  function RpcContext(parser, parent, invokingState) {
	    var _this35;

	    _classCallCheck(this, RpcContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this35 = _super35.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this35), "LP", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.LP);
	      } else {
	        return this.getToken(Protobuf3Parser.LP, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this35), "messageType", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(MessageTypeContext);
	      } else {
	        return this.getTypedRuleContext(MessageTypeContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this35), "RP", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.RP);
	      } else {
	        return this.getToken(Protobuf3Parser.RP, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this35), "STREAM", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.STREAM);
	      } else {
	        return this.getToken(Protobuf3Parser.STREAM, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this35), "optionStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(OptionStatementContext);
	      } else {
	        return this.getTypedRuleContext(OptionStatementContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this35), "emptyStatement", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EmptyStatementContext);
	      } else {
	        return this.getTypedRuleContext(EmptyStatementContext, i);
	      }
	    });

	    _this35.parser = parser;
	    _this35.ruleIndex = Protobuf3Parser.RULE_rpc;
	    return _this35;
	  }

	  _createClass(RpcContext, [{
	    key: "RPC",
	    value: function RPC() {
	      return this.getToken(Protobuf3Parser.RPC, 0);
	    }
	  }, {
	    key: "rpcName",
	    value: function rpcName() {
	      return this.getTypedRuleContext(RpcNameContext, 0);
	    }
	  }, {
	    key: "RETURNS",
	    value: function RETURNS() {
	      return this.getToken(Protobuf3Parser.RETURNS, 0);
	    }
	  }, {
	    key: "LC",
	    value: function LC() {
	      return this.getToken(Protobuf3Parser.LC, 0);
	    }
	  }, {
	    key: "RC",
	    value: function RC() {
	      return this.getToken(Protobuf3Parser.RC, 0);
	    }
	  }, {
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterRpc(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitRpc(this);
	      }
	    }
	  }]);

	  return RpcContext;
	}(_antlr["default"].ParserRuleContext);

	var ConstantContext = /*#__PURE__*/function (_antlr4$ParserRuleCon35) {
	  _inherits(ConstantContext, _antlr4$ParserRuleCon35);

	  var _super36 = _createSuper(ConstantContext);

	  function ConstantContext(parser, parent, invokingState) {
	    var _this36;

	    _classCallCheck(this, ConstantContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this36 = _super36.call(this, parent, invokingState);
	    _this36.parser = parser;
	    _this36.ruleIndex = Protobuf3Parser.RULE_constant;
	    return _this36;
	  }

	  _createClass(ConstantContext, [{
	    key: "fullIdent",
	    value: function fullIdent() {
	      return this.getTypedRuleContext(FullIdentContext, 0);
	    }
	  }, {
	    key: "intLit",
	    value: function intLit() {
	      return this.getTypedRuleContext(IntLitContext, 0);
	    }
	  }, {
	    key: "MINUS",
	    value: function MINUS() {
	      return this.getToken(Protobuf3Parser.MINUS, 0);
	    }
	  }, {
	    key: "PLUS",
	    value: function PLUS() {
	      return this.getToken(Protobuf3Parser.PLUS, 0);
	    }
	  }, {
	    key: "floatLit",
	    value: function floatLit() {
	      return this.getTypedRuleContext(FloatLitContext, 0);
	    }
	  }, {
	    key: "strLit",
	    value: function strLit() {
	      return this.getTypedRuleContext(StrLitContext, 0);
	    }
	  }, {
	    key: "boolLit",
	    value: function boolLit() {
	      return this.getTypedRuleContext(BoolLitContext, 0);
	    }
	  }, {
	    key: "blockLit",
	    value: function blockLit() {
	      return this.getTypedRuleContext(BlockLitContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterConstant(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitConstant(this);
	      }
	    }
	  }]);

	  return ConstantContext;
	}(_antlr["default"].ParserRuleContext);

	var BlockLitContext = /*#__PURE__*/function (_antlr4$ParserRuleCon36) {
	  _inherits(BlockLitContext, _antlr4$ParserRuleCon36);

	  var _super37 = _createSuper(BlockLitContext);

	  function BlockLitContext(parser, parent, invokingState) {
	    var _this37;

	    _classCallCheck(this, BlockLitContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this37 = _super37.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this37), "ident", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(IdentContext);
	      } else {
	        return this.getTypedRuleContext(IdentContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this37), "COLON", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.COLON);
	      } else {
	        return this.getToken(Protobuf3Parser.COLON, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this37), "constant", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ConstantContext);
	      } else {
	        return this.getTypedRuleContext(ConstantContext, i);
	      }
	    });

	    _this37.parser = parser;
	    _this37.ruleIndex = Protobuf3Parser.RULE_blockLit;
	    return _this37;
	  }

	  _createClass(BlockLitContext, [{
	    key: "LC",
	    value: function LC() {
	      return this.getToken(Protobuf3Parser.LC, 0);
	    }
	  }, {
	    key: "RC",
	    value: function RC() {
	      return this.getToken(Protobuf3Parser.RC, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterBlockLit(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitBlockLit(this);
	      }
	    }
	  }]);

	  return BlockLitContext;
	}(_antlr["default"].ParserRuleContext);

	var EmptyStatementContext = /*#__PURE__*/function (_antlr4$ParserRuleCon37) {
	  _inherits(EmptyStatementContext, _antlr4$ParserRuleCon37);

	  var _super38 = _createSuper(EmptyStatementContext);

	  function EmptyStatementContext(parser, parent, invokingState) {
	    var _this38;

	    _classCallCheck(this, EmptyStatementContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this38 = _super38.call(this, parent, invokingState);
	    _this38.parser = parser;
	    _this38.ruleIndex = Protobuf3Parser.RULE_emptyStatement;
	    return _this38;
	  }

	  _createClass(EmptyStatementContext, [{
	    key: "SEMI",
	    value: function SEMI() {
	      return this.getToken(Protobuf3Parser.SEMI, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEmptyStatement(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEmptyStatement(this);
	      }
	    }
	  }]);

	  return EmptyStatementContext;
	}(_antlr["default"].ParserRuleContext);

	var IdentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon38) {
	  _inherits(IdentContext, _antlr4$ParserRuleCon38);

	  var _super39 = _createSuper(IdentContext);

	  function IdentContext(parser, parent, invokingState) {
	    var _this39;

	    _classCallCheck(this, IdentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this39 = _super39.call(this, parent, invokingState);
	    _this39.parser = parser;
	    _this39.ruleIndex = Protobuf3Parser.RULE_ident;
	    return _this39;
	  }

	  _createClass(IdentContext, [{
	    key: "IDENTIFIER",
	    value: function IDENTIFIER() {
	      return this.getToken(Protobuf3Parser.IDENTIFIER, 0);
	    }
	  }, {
	    key: "keywords",
	    value: function keywords() {
	      return this.getTypedRuleContext(KeywordsContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterIdent(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitIdent(this);
	      }
	    }
	  }]);

	  return IdentContext;
	}(_antlr["default"].ParserRuleContext);

	var FullIdentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon39) {
	  _inherits(FullIdentContext, _antlr4$ParserRuleCon39);

	  var _super40 = _createSuper(FullIdentContext);

	  function FullIdentContext(parser, parent, invokingState) {
	    var _this40;

	    _classCallCheck(this, FullIdentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this40 = _super40.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this40), "ident", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(IdentContext);
	      } else {
	        return this.getTypedRuleContext(IdentContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this40), "DOT", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.DOT);
	      } else {
	        return this.getToken(Protobuf3Parser.DOT, i);
	      }
	    });

	    _this40.parser = parser;
	    _this40.ruleIndex = Protobuf3Parser.RULE_fullIdent;
	    return _this40;
	  }

	  _createClass(FullIdentContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterFullIdent(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitFullIdent(this);
	      }
	    }
	  }]);

	  return FullIdentContext;
	}(_antlr["default"].ParserRuleContext);

	var MessageNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon40) {
	  _inherits(MessageNameContext, _antlr4$ParserRuleCon40);

	  var _super41 = _createSuper(MessageNameContext);

	  function MessageNameContext(parser, parent, invokingState) {
	    var _this41;

	    _classCallCheck(this, MessageNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this41 = _super41.call(this, parent, invokingState);
	    _this41.parser = parser;
	    _this41.ruleIndex = Protobuf3Parser.RULE_messageName;
	    return _this41;
	  }

	  _createClass(MessageNameContext, [{
	    key: "ident",
	    value: function ident() {
	      return this.getTypedRuleContext(IdentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterMessageName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitMessageName(this);
	      }
	    }
	  }]);

	  return MessageNameContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon41) {
	  _inherits(EnumNameContext, _antlr4$ParserRuleCon41);

	  var _super42 = _createSuper(EnumNameContext);

	  function EnumNameContext(parser, parent, invokingState) {
	    var _this42;

	    _classCallCheck(this, EnumNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this42 = _super42.call(this, parent, invokingState);
	    _this42.parser = parser;
	    _this42.ruleIndex = Protobuf3Parser.RULE_enumName;
	    return _this42;
	  }

	  _createClass(EnumNameContext, [{
	    key: "ident",
	    value: function ident() {
	      return this.getTypedRuleContext(IdentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEnumName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEnumName(this);
	      }
	    }
	  }]);

	  return EnumNameContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon42) {
	  _inherits(FieldNameContext, _antlr4$ParserRuleCon42);

	  var _super43 = _createSuper(FieldNameContext);

	  function FieldNameContext(parser, parent, invokingState) {
	    var _this43;

	    _classCallCheck(this, FieldNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this43 = _super43.call(this, parent, invokingState);
	    _this43.parser = parser;
	    _this43.ruleIndex = Protobuf3Parser.RULE_fieldName;
	    return _this43;
	  }

	  _createClass(FieldNameContext, [{
	    key: "ident",
	    value: function ident() {
	      return this.getTypedRuleContext(IdentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterFieldName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitFieldName(this);
	      }
	    }
	  }]);

	  return FieldNameContext;
	}(_antlr["default"].ParserRuleContext);

	var OneofNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon43) {
	  _inherits(OneofNameContext, _antlr4$ParserRuleCon43);

	  var _super44 = _createSuper(OneofNameContext);

	  function OneofNameContext(parser, parent, invokingState) {
	    var _this44;

	    _classCallCheck(this, OneofNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this44 = _super44.call(this, parent, invokingState);
	    _this44.parser = parser;
	    _this44.ruleIndex = Protobuf3Parser.RULE_oneofName;
	    return _this44;
	  }

	  _createClass(OneofNameContext, [{
	    key: "ident",
	    value: function ident() {
	      return this.getTypedRuleContext(IdentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterOneofName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitOneofName(this);
	      }
	    }
	  }]);

	  return OneofNameContext;
	}(_antlr["default"].ParserRuleContext);

	var MapNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon44) {
	  _inherits(MapNameContext, _antlr4$ParserRuleCon44);

	  var _super45 = _createSuper(MapNameContext);

	  function MapNameContext(parser, parent, invokingState) {
	    var _this45;

	    _classCallCheck(this, MapNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this45 = _super45.call(this, parent, invokingState);
	    _this45.parser = parser;
	    _this45.ruleIndex = Protobuf3Parser.RULE_mapName;
	    return _this45;
	  }

	  _createClass(MapNameContext, [{
	    key: "ident",
	    value: function ident() {
	      return this.getTypedRuleContext(IdentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterMapName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitMapName(this);
	      }
	    }
	  }]);

	  return MapNameContext;
	}(_antlr["default"].ParserRuleContext);

	var ServiceNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon45) {
	  _inherits(ServiceNameContext, _antlr4$ParserRuleCon45);

	  var _super46 = _createSuper(ServiceNameContext);

	  function ServiceNameContext(parser, parent, invokingState) {
	    var _this46;

	    _classCallCheck(this, ServiceNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this46 = _super46.call(this, parent, invokingState);
	    _this46.parser = parser;
	    _this46.ruleIndex = Protobuf3Parser.RULE_serviceName;
	    return _this46;
	  }

	  _createClass(ServiceNameContext, [{
	    key: "ident",
	    value: function ident() {
	      return this.getTypedRuleContext(IdentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterServiceName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitServiceName(this);
	      }
	    }
	  }]);

	  return ServiceNameContext;
	}(_antlr["default"].ParserRuleContext);

	var RpcNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon46) {
	  _inherits(RpcNameContext, _antlr4$ParserRuleCon46);

	  var _super47 = _createSuper(RpcNameContext);

	  function RpcNameContext(parser, parent, invokingState) {
	    var _this47;

	    _classCallCheck(this, RpcNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this47 = _super47.call(this, parent, invokingState);
	    _this47.parser = parser;
	    _this47.ruleIndex = Protobuf3Parser.RULE_rpcName;
	    return _this47;
	  }

	  _createClass(RpcNameContext, [{
	    key: "ident",
	    value: function ident() {
	      return this.getTypedRuleContext(IdentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterRpcName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitRpcName(this);
	      }
	    }
	  }]);

	  return RpcNameContext;
	}(_antlr["default"].ParserRuleContext);

	var MessageTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon47) {
	  _inherits(MessageTypeContext, _antlr4$ParserRuleCon47);

	  var _super48 = _createSuper(MessageTypeContext);

	  function MessageTypeContext(parser, parent, invokingState) {
	    var _this48;

	    _classCallCheck(this, MessageTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this48 = _super48.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this48), "DOT", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.DOT);
	      } else {
	        return this.getToken(Protobuf3Parser.DOT, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this48), "ident", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(IdentContext);
	      } else {
	        return this.getTypedRuleContext(IdentContext, i);
	      }
	    });

	    _this48.parser = parser;
	    _this48.ruleIndex = Protobuf3Parser.RULE_messageType;
	    return _this48;
	  }

	  _createClass(MessageTypeContext, [{
	    key: "messageName",
	    value: function messageName() {
	      return this.getTypedRuleContext(MessageNameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterMessageType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitMessageType(this);
	      }
	    }
	  }]);

	  return MessageTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon48) {
	  _inherits(EnumTypeContext, _antlr4$ParserRuleCon48);

	  var _super49 = _createSuper(EnumTypeContext);

	  function EnumTypeContext(parser, parent, invokingState) {
	    var _this49;

	    _classCallCheck(this, EnumTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this49 = _super49.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this49), "DOT", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(Protobuf3Parser.DOT);
	      } else {
	        return this.getToken(Protobuf3Parser.DOT, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this49), "ident", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(IdentContext);
	      } else {
	        return this.getTypedRuleContext(IdentContext, i);
	      }
	    });

	    _this49.parser = parser;
	    _this49.ruleIndex = Protobuf3Parser.RULE_enumType;
	    return _this49;
	  }

	  _createClass(EnumTypeContext, [{
	    key: "enumName",
	    value: function enumName() {
	      return this.getTypedRuleContext(EnumNameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterEnumType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitEnumType(this);
	      }
	    }
	  }]);

	  return EnumTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var IntLitContext = /*#__PURE__*/function (_antlr4$ParserRuleCon49) {
	  _inherits(IntLitContext, _antlr4$ParserRuleCon49);

	  var _super50 = _createSuper(IntLitContext);

	  function IntLitContext(parser, parent, invokingState) {
	    var _this50;

	    _classCallCheck(this, IntLitContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this50 = _super50.call(this, parent, invokingState);
	    _this50.parser = parser;
	    _this50.ruleIndex = Protobuf3Parser.RULE_intLit;
	    return _this50;
	  }

	  _createClass(IntLitContext, [{
	    key: "INT_LIT",
	    value: function INT_LIT() {
	      return this.getToken(Protobuf3Parser.INT_LIT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterIntLit(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitIntLit(this);
	      }
	    }
	  }]);

	  return IntLitContext;
	}(_antlr["default"].ParserRuleContext);

	var StrLitContext = /*#__PURE__*/function (_antlr4$ParserRuleCon50) {
	  _inherits(StrLitContext, _antlr4$ParserRuleCon50);

	  var _super51 = _createSuper(StrLitContext);

	  function StrLitContext(parser, parent, invokingState) {
	    var _this51;

	    _classCallCheck(this, StrLitContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this51 = _super51.call(this, parent, invokingState);
	    _this51.parser = parser;
	    _this51.ruleIndex = Protobuf3Parser.RULE_strLit;
	    return _this51;
	  }

	  _createClass(StrLitContext, [{
	    key: "STR_LIT",
	    value: function STR_LIT() {
	      return this.getToken(Protobuf3Parser.STR_LIT, 0);
	    }
	  }, {
	    key: "PROTO3_LIT_SINGLE",
	    value: function PROTO3_LIT_SINGLE() {
	      return this.getToken(Protobuf3Parser.PROTO3_LIT_SINGLE, 0);
	    }
	  }, {
	    key: "PROTO3_LIT_DOBULE",
	    value: function PROTO3_LIT_DOBULE() {
	      return this.getToken(Protobuf3Parser.PROTO3_LIT_DOBULE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterStrLit(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitStrLit(this);
	      }
	    }
	  }]);

	  return StrLitContext;
	}(_antlr["default"].ParserRuleContext);

	var BoolLitContext = /*#__PURE__*/function (_antlr4$ParserRuleCon51) {
	  _inherits(BoolLitContext, _antlr4$ParserRuleCon51);

	  var _super52 = _createSuper(BoolLitContext);

	  function BoolLitContext(parser, parent, invokingState) {
	    var _this52;

	    _classCallCheck(this, BoolLitContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this52 = _super52.call(this, parent, invokingState);
	    _this52.parser = parser;
	    _this52.ruleIndex = Protobuf3Parser.RULE_boolLit;
	    return _this52;
	  }

	  _createClass(BoolLitContext, [{
	    key: "BOOL_LIT",
	    value: function BOOL_LIT() {
	      return this.getToken(Protobuf3Parser.BOOL_LIT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterBoolLit(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitBoolLit(this);
	      }
	    }
	  }]);

	  return BoolLitContext;
	}(_antlr["default"].ParserRuleContext);

	var FloatLitContext = /*#__PURE__*/function (_antlr4$ParserRuleCon52) {
	  _inherits(FloatLitContext, _antlr4$ParserRuleCon52);

	  var _super53 = _createSuper(FloatLitContext);

	  function FloatLitContext(parser, parent, invokingState) {
	    var _this53;

	    _classCallCheck(this, FloatLitContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this53 = _super53.call(this, parent, invokingState);
	    _this53.parser = parser;
	    _this53.ruleIndex = Protobuf3Parser.RULE_floatLit;
	    return _this53;
	  }

	  _createClass(FloatLitContext, [{
	    key: "FLOAT_LIT",
	    value: function FLOAT_LIT() {
	      return this.getToken(Protobuf3Parser.FLOAT_LIT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterFloatLit(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitFloatLit(this);
	      }
	    }
	  }]);

	  return FloatLitContext;
	}(_antlr["default"].ParserRuleContext);

	var KeywordsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon53) {
	  _inherits(KeywordsContext, _antlr4$ParserRuleCon53);

	  var _super54 = _createSuper(KeywordsContext);

	  function KeywordsContext(parser, parent, invokingState) {
	    var _this54;

	    _classCallCheck(this, KeywordsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this54 = _super54.call(this, parent, invokingState);
	    _this54.parser = parser;
	    _this54.ruleIndex = Protobuf3Parser.RULE_keywords;
	    return _this54;
	  }

	  _createClass(KeywordsContext, [{
	    key: "SYNTAX",
	    value: function SYNTAX() {
	      return this.getToken(Protobuf3Parser.SYNTAX, 0);
	    }
	  }, {
	    key: "IMPORT",
	    value: function IMPORT() {
	      return this.getToken(Protobuf3Parser.IMPORT, 0);
	    }
	  }, {
	    key: "WEAK",
	    value: function WEAK() {
	      return this.getToken(Protobuf3Parser.WEAK, 0);
	    }
	  }, {
	    key: "PUBLIC",
	    value: function PUBLIC() {
	      return this.getToken(Protobuf3Parser.PUBLIC, 0);
	    }
	  }, {
	    key: "PACKAGE",
	    value: function PACKAGE() {
	      return this.getToken(Protobuf3Parser.PACKAGE, 0);
	    }
	  }, {
	    key: "OPTION",
	    value: function OPTION() {
	      return this.getToken(Protobuf3Parser.OPTION, 0);
	    }
	  }, {
	    key: "REPEATED",
	    value: function REPEATED() {
	      return this.getToken(Protobuf3Parser.REPEATED, 0);
	    }
	  }, {
	    key: "ONEOF",
	    value: function ONEOF() {
	      return this.getToken(Protobuf3Parser.ONEOF, 0);
	    }
	  }, {
	    key: "MAP",
	    value: function MAP() {
	      return this.getToken(Protobuf3Parser.MAP, 0);
	    }
	  }, {
	    key: "INT32",
	    value: function INT32() {
	      return this.getToken(Protobuf3Parser.INT32, 0);
	    }
	  }, {
	    key: "INT64",
	    value: function INT64() {
	      return this.getToken(Protobuf3Parser.INT64, 0);
	    }
	  }, {
	    key: "UINT32",
	    value: function UINT32() {
	      return this.getToken(Protobuf3Parser.UINT32, 0);
	    }
	  }, {
	    key: "UINT64",
	    value: function UINT64() {
	      return this.getToken(Protobuf3Parser.UINT64, 0);
	    }
	  }, {
	    key: "SINT32",
	    value: function SINT32() {
	      return this.getToken(Protobuf3Parser.SINT32, 0);
	    }
	  }, {
	    key: "SINT64",
	    value: function SINT64() {
	      return this.getToken(Protobuf3Parser.SINT64, 0);
	    }
	  }, {
	    key: "FIXED32",
	    value: function FIXED32() {
	      return this.getToken(Protobuf3Parser.FIXED32, 0);
	    }
	  }, {
	    key: "FIXED64",
	    value: function FIXED64() {
	      return this.getToken(Protobuf3Parser.FIXED64, 0);
	    }
	  }, {
	    key: "SFIXED32",
	    value: function SFIXED32() {
	      return this.getToken(Protobuf3Parser.SFIXED32, 0);
	    }
	  }, {
	    key: "SFIXED64",
	    value: function SFIXED64() {
	      return this.getToken(Protobuf3Parser.SFIXED64, 0);
	    }
	  }, {
	    key: "BOOL",
	    value: function BOOL() {
	      return this.getToken(Protobuf3Parser.BOOL, 0);
	    }
	  }, {
	    key: "STRING",
	    value: function STRING() {
	      return this.getToken(Protobuf3Parser.STRING, 0);
	    }
	  }, {
	    key: "DOUBLE",
	    value: function DOUBLE() {
	      return this.getToken(Protobuf3Parser.DOUBLE, 0);
	    }
	  }, {
	    key: "FLOAT",
	    value: function FLOAT() {
	      return this.getToken(Protobuf3Parser.FLOAT, 0);
	    }
	  }, {
	    key: "BYTES",
	    value: function BYTES() {
	      return this.getToken(Protobuf3Parser.BYTES, 0);
	    }
	  }, {
	    key: "RESERVED",
	    value: function RESERVED() {
	      return this.getToken(Protobuf3Parser.RESERVED, 0);
	    }
	  }, {
	    key: "TO",
	    value: function TO() {
	      return this.getToken(Protobuf3Parser.TO, 0);
	    }
	  }, {
	    key: "MAX",
	    value: function MAX() {
	      return this.getToken(Protobuf3Parser.MAX, 0);
	    }
	  }, {
	    key: "ENUM",
	    value: function ENUM() {
	      return this.getToken(Protobuf3Parser.ENUM, 0);
	    }
	  }, {
	    key: "MESSAGE",
	    value: function MESSAGE() {
	      return this.getToken(Protobuf3Parser.MESSAGE, 0);
	    }
	  }, {
	    key: "SERVICE",
	    value: function SERVICE() {
	      return this.getToken(Protobuf3Parser.SERVICE, 0);
	    }
	  }, {
	    key: "RPC",
	    value: function RPC() {
	      return this.getToken(Protobuf3Parser.RPC, 0);
	    }
	  }, {
	    key: "STREAM",
	    value: function STREAM() {
	      return this.getToken(Protobuf3Parser.STREAM, 0);
	    }
	  }, {
	    key: "RETURNS",
	    value: function RETURNS() {
	      return this.getToken(Protobuf3Parser.RETURNS, 0);
	    }
	  }, {
	    key: "BOOL_LIT",
	    value: function BOOL_LIT() {
	      return this.getToken(Protobuf3Parser.BOOL_LIT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.enterKeywords(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _Protobuf3Listener["default"]) {
	        listener.exitKeywords(this);
	      }
	    }
	  }]);

	  return KeywordsContext;
	}(_antlr["default"].ParserRuleContext);

	Protobuf3Parser.ProtoContext = ProtoContext;
	Protobuf3Parser.SyntaxContext = SyntaxContext;
	Protobuf3Parser.ImportStatementContext = ImportStatementContext;
	Protobuf3Parser.PackageStatementContext = PackageStatementContext;
	Protobuf3Parser.OptionStatementContext = OptionStatementContext;
	Protobuf3Parser.OptionNameContext = OptionNameContext;
	Protobuf3Parser.ExtendsStatementContext = ExtendsStatementContext;
	Protobuf3Parser.ExtendedIdentifierContext = ExtendedIdentifierContext;
	Protobuf3Parser.FieldContext = FieldContext;
	Protobuf3Parser.FieldOptionsContext = FieldOptionsContext;
	Protobuf3Parser.FieldOptionContext = FieldOptionContext;
	Protobuf3Parser.FieldNumberContext = FieldNumberContext;
	Protobuf3Parser.OneofContext = OneofContext;
	Protobuf3Parser.OneofFieldContext = OneofFieldContext;
	Protobuf3Parser.MapFieldContext = MapFieldContext;
	Protobuf3Parser.KeyTypeContext = KeyTypeContext;
	Protobuf3Parser.Type_Context = Type_Context;
	Protobuf3Parser.ReservedContext = ReservedContext;
	Protobuf3Parser.RangesContext = RangesContext;
	Protobuf3Parser.Range_Context = Range_Context;
	Protobuf3Parser.ReservedFieldNamesContext = ReservedFieldNamesContext;
	Protobuf3Parser.TopLevelDefContext = TopLevelDefContext;
	Protobuf3Parser.EnumDefContext = EnumDefContext;
	Protobuf3Parser.EnumBodyContext = EnumBodyContext;
	Protobuf3Parser.EnumElementContext = EnumElementContext;
	Protobuf3Parser.EnumFieldContext = EnumFieldContext;
	Protobuf3Parser.EnumValueOptionsContext = EnumValueOptionsContext;
	Protobuf3Parser.EnumValueOptionContext = EnumValueOptionContext;
	Protobuf3Parser.MessageDefContext = MessageDefContext;
	Protobuf3Parser.MessageBodyContext = MessageBodyContext;
	Protobuf3Parser.MessageElementContext = MessageElementContext;
	Protobuf3Parser.ServiceDefContext = ServiceDefContext;
	Protobuf3Parser.ServiceElementContext = ServiceElementContext;
	Protobuf3Parser.RpcContext = RpcContext;
	Protobuf3Parser.ConstantContext = ConstantContext;
	Protobuf3Parser.BlockLitContext = BlockLitContext;
	Protobuf3Parser.EmptyStatementContext = EmptyStatementContext;
	Protobuf3Parser.IdentContext = IdentContext;
	Protobuf3Parser.FullIdentContext = FullIdentContext;
	Protobuf3Parser.MessageNameContext = MessageNameContext;
	Protobuf3Parser.EnumNameContext = EnumNameContext;
	Protobuf3Parser.FieldNameContext = FieldNameContext;
	Protobuf3Parser.OneofNameContext = OneofNameContext;
	Protobuf3Parser.MapNameContext = MapNameContext;
	Protobuf3Parser.ServiceNameContext = ServiceNameContext;
	Protobuf3Parser.RpcNameContext = RpcNameContext;
	Protobuf3Parser.MessageTypeContext = MessageTypeContext;
	Protobuf3Parser.EnumTypeContext = EnumTypeContext;
	Protobuf3Parser.IntLitContext = IntLitContext;
	Protobuf3Parser.StrLitContext = StrLitContext;
	Protobuf3Parser.BoolLitContext = BoolLitContext;
	Protobuf3Parser.FloatLitContext = FloatLitContext;
	Protobuf3Parser.KeywordsContext = KeywordsContext;
} (Protobuf3Parser$1));

var Protobuf3Parser = /*@__PURE__*/getDefaultExportFromCjs(Protobuf3Parser$1);

class Protobuf3ASTBuilderCB$1 extends Protobuf3Listener {

    visitTerminal(node) {
        this.cb.visitTerminal(node, this.parser);
    }

    visitErrorNode(node) {
        this.cb.visitErrorNode(node, this.parser);
    }

    enterEveryRule(node) {
        this.cb.enterEveryRule(node, this.parser);
    }

    exitEveryRule(node) {
        this.cb.exitEveryRule();
    }

    run(input, cb) {
        this.cb = cb;
        const chars = new antlr4.InputStream(input);
        const lexer = new Protobuf3Lexer(chars);
        const tokens = new antlr4.CommonTokenStream(lexer);
        this.parser = new Protobuf3Parser(tokens);
        this.parser.buildParseTrees = true;
        const tree = this.parser.proto();
        antlr4.tree.ParseTreeWalker.DEFAULT.walk(this, tree);
    }
}

var protobuf3cb_m = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Protobuf3ASTBuilderCB: Protobuf3ASTBuilderCB$1
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(protobuf3cb_m);

var GraphQLFederationLexer = {};

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var serializedATN = ["\x03\u608B\uA72A\u8133\uB9ED\u417C\u3BE7\u7786", "\u5964\x02q\u0489\b\x01\b\x01\b\x01\x04\x02\t\x02\x04", "\x03\t\x03\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t", "\x06\x04\x07\t\x07\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04", "\x0B\t\x0B\x04\f\t\f\x04\r\t\r\x04\x0E\t\x0E\x04\x0F", "\t\x0F\x04\x10\t\x10\x04\x11\t\x11\x04\x12\t\x12", "\x04\x13\t\x13\x04\x14\t\x14\x04\x15\t\x15\x04\x16", "\t\x16\x04\x17\t\x17\x04\x18\t\x18\x04\x19\t\x19", "\x04\x1A\t\x1A\x04\x1B\t\x1B\x04\x1C\t\x1C\x04\x1D", "\t\x1D\x04\x1E\t\x1E\x04\x1F\t\x1F\x04 \t \x04!\t", "!\x04\"\t\"\x04#\t#\x04$\t$\x04%\t%\x04&\t&\x04'\t'\x04", "(\t(\x04)\t)\x04*\t*\x04+\t+\x04,\t,\x04-\t-\x04.\t.\x04", "/\t/\x040\t0\x041\t1\x042\t2\x043\t3\x044\t4\x045\t5\x04", "6\t6\x047\t7\x048\t8\x049\t9\x04:\t:\x04;\t;\x04<\t<\x04", "=\t=\x04>\t>\x04?\t?\x04@\t@\x04A\tA\x04B\tB\x04C\tC\x04", "D\tD\x04E\tE\x04F\tF\x04G\tG\x04H\tH\x04I\tI\x04J\tJ\x04", "K\tK\x04L\tL\x04M\tM\x04N\tN\x04O\tO\x04P\tP\x04Q\tQ\x04", "R\tR\x04S\tS\x04T\tT\x04U\tU\x04V\tV\x04W\tW\x04X\tX\x04", "Y\tY\x04Z\tZ\x04[\t[\x04\\\t\\\x04]\t]\x04^\t^\x04_\t_\x04", "`\t`\x04a\ta\x04b\tb\x04c\tc\x04d\td\x04e\te\x04f\tf\x04", "g\tg\x04h\th\x04i\ti\x04j\tj\x04k\tk\x04l\tl\x04m\tm\x04", "n\tn\x04o\to\x04p\tp\x04q\tq\x04r\tr\x04s\ts\x04t\tt\x04", "u\tu\x04v\tv\x04w\tw\x04x\tx\x04y\ty\x04z\tz\x04{\t{\x04", "|\t|\x04}\t}\x04~\t~\x04\x7F\t\x7F\x03\x02\x03\x02", "\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02", "\x03\x02\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03\x04", "\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04", "\x03\x04\x03\x04\x03\x04\x03\x04\x03\x05\x03\x05", "\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05\x03\x05", "\x03\x05\x03\x05\x03\x05\x03\x05\x03\x06\x03\x06", "\x03\x06\x03\x06\x03\x06\x03\x06\x03\x06\x03\x07", "\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07", "\x03\x07\x03\x07\x03\x07\x03\x07\x03\b\x03\b\x03", "\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03\b\x03", "\b\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03\t\x03", "\n\x03\n\x03\n\x03\n\x03\n\x03\n\x03\x0B\x03\x0B\x03", "\x0B\x03\x0B\x03\x0B\x03\f\x03\f\x03\f\x03\f\x03", "\f\x03\r\x03\r\x03\r\x03\r\x03\r\x03\r\x03\r\x03\x0E", "\x03\x0E\x03\x0E\x03\x0E\x03\x0E\x03\x0E\x03\x0E", "\x03\x0E\x03\x0E\x03\x0E\x03\x0F\x03\x0F\x03\x0F", "\x03\x0F\x03\x0F\x03\x0F\x03\x0F\x03\x0F\x03\x0F", "\x03\x0F\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10", "\x03\x10\x03\x10\x03\x11\x03\x11\x03\x11\x03\x11", "\x03\x11\x03\x11\x03\x12\x03\x12\x03\x12\x03\x12", "\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12", "\x03\x12\x03\x13\x03\x13\x03\x13\x03\x13\x03\x13", "\x03\x13\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14", "\x03\x14\x03\x14\x03\x14\x03\x14\x03\x15\x03\x15", "\x03\x15\x03\x15\x03\x15\x03\x15\x03\x15\x03\x15", "\x03\x15\x03\x15\x03\x15\x03\x15\x03\x15\x03\x16", "\x03\x16\x03\x16\x03\x16\x03\x16\x03\x16\x03\x16", "\x03\x17\x03\x17\x03\x17\x03\x17\x03\x17\x03\x17", "\x03\x17\x03\x17\x03\x17\x03\x18\x03\x18\x03\x18", "\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19", "\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x1A", "\x03\x1A\x03\x1A\x03\x1A\x03\x1A\x03\x1A\x03\x1B", "\x03\x1B\x03\x1B\x03\x1B\x03\x1B\x03\x1C\x03\x1C", "\x03\x1C\x03\x1C\x03\x1C\x03\x1D\x03\x1D\x03\x1D", "\x03\x1D\x03\x1D\x03\x1D\x03\x1D\x03\x1E\x03\x1E", "\x03\x1E\x03\x1E\x03\x1E\x03\x1E\x03\x1E\x03\x1E", "\x03\x1E\x03\x1E\x03\x1F\x03\x1F\x03\x1F\x03\x1F", "\x03\x1F\x03\x1F\x03\x1F\x03\x1F\x03\x1F\x03\x1F", "\x03 \x03 \x03 \x03 \x03 \x03 \x03 \x03!\x03!\x03", "!\x03!\x03!\x03!\x03\"\x03\"\x03\"\x03\"\x03\"\x03", "\"\x03\"\x03\"\x03\"\x03\"\x03\"\x03#\x03#\x03#\x03", "#\x03#\x03#\x03$\x03$\x03$\x03$\x03$\x03$\x03$\x03", "$\x03$\x03%\x03%\x03%\x03%\x03%\x03%\x03%\x03%\x03", "%\x03%\x03%\x03%\x03%\x03&\x03&\x03&\x03&\x03&\x03", "&\x03&\x03'\x03'\x03'\x03'\x03'\x03'\x03'\x03", "'\x03'\x03(\x03(\x03(\x03(\x03(\x03(\x03)\x03)\x03", ")\x03)\x03)\x03)\x03)\x03)\x03)\x03)\x03)\x03)\x03", ")\x03)\x03)\x03)\x03)\x03)\x03)\x03)\x03*\x03*\x03", "*\x03*\x03*\x03*\x03*\x03*\x03*\x03*\x03*\x03*\x03", "*\x03*\x03*\x03*\x03+\x03+\x03+\x03+\x03+\x03+\x03", "+\x03+\x03+\x03+\x03+\x03+\x03+\x03+\x03+\x03+\x03", ",\x03,\x03,\x03,\x03,\x03,\x03,\x03,\x03,\x03,\x03", ",\x03,\x03,\x03,\x03,\x03,\x03,\x03,\x03,\x03,\x03", "-\x03-\x03-\x03-\x03-\x03-\x03-\x03.\x03.\x03.\x03", ".\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03", ".\x03.\x03.\x03.\x03/\x03/\x03/\x03/\x03/\x03/\x03", "/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03", "/\x03/\x03/\x03/\x030\x030\x030\x030\x030\x030\x03", "0\x030\x030\x030\x030\x031\x031\x031\x031\x031\x03", "1\x031\x031\x031\x031\x031\x031\x031\x032\x032\x03", "2\x032\x032\x032\x032\x032\x032\x032\x032\x032\x03", "2\x032\x032\x032\x032\x032\x032\x032\x032\x032\x03", "2\x033\x033\x034\x034\x035\x035\x036\x036\x037\x03", "7\x038\x038\x039\x039\x03:\x03:\x03;\x03;\x03<\x03", "<\x03=\x03=\x03=\x03=\x03>\x03>\x03?\x03?\x03@\x03", "@\x03A\x03A\x03B\x03B\x03B\x03B\x03B\x03C\x03C\x03", "C\x03C\x03C\x03C\x03D\x03D\x03D\x03D\x03D\x03E\x03", "E\x07E\u031F\nE\fE\x0EE\u0322\x0BE\x03F\x03F\x07F\u0326", "\nF\fF\x0EF\u0329\x0BF\x03F\x03F\x03G\x03G\x03G\x03", "G\x03G\x07G\u0332\nG\fG\x0EG\u0335\x0BG\x03G\x03G\x03", "G\x03G\x03H\x03H\x05H\u033D\nH\x03I\x03I\x03I\x05I\u0342", "\nI\x03J\x03J\x03J\x03J\x03J\x03J\x03K\x03K\x03L\x03", "L\x03L\x03L\x03L\x03L\x03L\x03L\x03L\x03L\x05L\u0356", "\nL\x03M\x05M\u0359\nM\x03M\x03M\x05M\u035D\nM\x03M\x03", "M\x07M\u0361\nM\fM\x0EM\u0364\x0BM\x05M\u0366\nM\x03N\x03", "N\x03O\x03O\x03P\x03P\x06P\u036E\nP\rP\x0EP\u036F\x03", "Q\x03Q\x05Q\u0374\nQ\x03Q\x06Q\u0377\nQ\rQ\x0EQ\u0378\x03", "R\x03R\x03S\x03S\x03T\x03T\x03U\x06U\u0382\nU\rU\x0E", "U\u0383\x03U\x03U\x03V\x03V\x03V\x03V\x03W\x03W\x07", "W\u038E\nW\fW\x0EW\u0391\x0BW\x03W\x03W\x03X\x03X\x03", "X\x05X\u0398\nX\x03X\x03X\x03Y\x03Y\x03Y\x03Y\x03Z\x03", "Z\x03[\x03[\x03[\x03[\x03[\x03[\x03\\\x03\\\x03\\", "\x03\\\x03\\\x03\\\x03\\\x03]\x03]\x03]\x03]\x03]", "\x03^\x03^\x03^\x03^\x03^\x03^\x03^\x03^\x03^\x03", "^\x03^\x03_\x03_\x03_\x03_\x03_\x03`\x03`\x03`\x03", "`\x03`\x03`\x03a\x06a\u03CB\na\ra\x0Ea\u03CC\x03a\x03", "a\x03b\x03b\x07b\u03D3\nb\fb\x0Eb\u03D6\x0Bb\x03c\x03", "c\x03d\x03d\x03e\x03e\x03f\x03f\x03g\x03g\x03h\x03", "h\x03h\x03h\x03i\x03i\x03i\x03i\x03i\x03i\x03j\x03", "j\x03j\x03j\x03j\x03k\x03k\x03k\x03k\x03k\x03l\x03", "l\x03l\x03l\x03l\x03l\x03l\x03m\x03m\x03m\x03m\x03", "m\x03m\x03m\x03m\x03m\x03m\x03n\x03n\x03n\x03n\x03", "n\x03n\x03n\x03n\x03n\x03n\x03o\x03o\x03o\x03o\x03", "o\x03o\x03o\x03p\x03p\x03p\x03p\x03p\x03p\x03q\x03", "q\x03q\x03q\x03q\x03q\x03q\x03q\x03q\x03q\x03q\x03", "r\x03r\x03r\x03r\x03r\x03r\x03s\x03s\x03s\x03s\x03", "s\x03s\x03s\x03s\x03s\x03t\x03t\x03t\x03t\x03t\x03", "t\x03t\x03t\x03t\x03t\x03t\x03t\x03t\x03u\x03u\x03", "u\x03u\x03u\x03u\x03u\x03v\x03v\x03v\x03v\x03v\x03", "v\x03v\x03v\x03v\x03w\x03w\x03w\x03x\x03x\x03x\x03", "x\x03x\x03x\x03x\x03x\x03x\x03x\x03x\x03y\x03y\x03", "y\x03y\x03z\x03z\x07z\u0469\nz\fz\x0Ez\u046C\x0Bz\x03", "z\x03z\x03z\x03z\x03{\x03{\x05{\u0474\n{\x03|\x03|\x03", "|\x05|\u0479\n|\x03}\x03}\x03}\x03}\x03}\x03}\x03~\x03", "~\x03\x7F\x06\x7F\u0484\n\x7F\r\x7F\x0E\x7F\u0485\x03", "\x7F\x03\x7F\x03\u0333\x02\x80\x05\x03\x07\x04\t", "\x05\x0B\x06\r\x07\x0F\b\x11\t\x13\n\x15\x0B\x17", "\f\x19\r\x1B\x0E\x1D\x0F\x1F\x10!\x11#\x12%\x13", "'\x14)\x15+\x16-\x17/\x181\x193\x1A5\x1B7\x1C9\x1D", ";\x1E=\x1F? A!C\"E#G$I%K&M'O(Q)S*U+W,Y-[.]/_0a1c2e3g4i5k6m7o8q", "9s:u;w<y={>}?\x7F@\x81A\x83B\x85C\x87D\x89E\x8BF\x8D", "G\x8FH\x91\x02\x93\x02\x95\x02\x97\x02\x99I\x9B", "J\x9D\x02\x9F\x02\xA1\x02\xA3\x02\xA5\x02\xA7", "\x02\xA9\x02\xABK\xADL\xAFM\xB1N\xB3O\xB5P\xB7Q", "\xB9R\xBBS\xBDT\xBFU\xC1V\xC3W\xC5X\xC7Y\xC9Z\xCB", "[\xCD\\\xCF]\xD1^\xD3_\xD5`\xD7a\xD9b\xDBc\xDDd\xDF", "e\xE1f\xE3g\xE5h\xE7i\xE9j\xEBk\xEDl\xEFm\xF1n\xF3", "o\xF5p\xF7\x02\xF9\x02\xFB\x02\xFD\x02\xFFq\x05", "\x02\x03\x04\x0F\x05\x02C\\aac|\x06\x022;C\\aac|\x04", "\x02$$^^\n\x02$$11^^ddhhppttvv\x05\x022;CHch\x03\x023;\x03", "\x022;\x04\x02GGgg\x04\x02--//\x05\x02\x0B\f\x0F\x0F", "\"\"\x04\x02\f\f\x0F\x0F\x03\x02\"\"\x04\x02++^^\x02", "\u048F\x02\x05\x03\x02\x02\x02\x02\x07\x03\x02\x02", "\x02\x02\t\x03\x02\x02\x02\x02\x0B\x03\x02\x02", "\x02\x02\r\x03\x02\x02\x02\x02\x0F\x03\x02\x02", "\x02\x02\x11\x03\x02\x02\x02\x02\x13\x03\x02\x02", "\x02\x02\x15\x03\x02\x02\x02\x02\x17\x03\x02\x02", "\x02\x02\x19\x03\x02\x02\x02\x02\x1B\x03\x02\x02", "\x02\x02\x1D\x03\x02\x02\x02\x02\x1F\x03\x02\x02", "\x02\x02!\x03\x02\x02\x02\x02#\x03\x02\x02\x02", "\x02%\x03\x02\x02\x02\x02'\x03\x02\x02\x02\x02", ")\x03\x02\x02\x02\x02+\x03\x02\x02\x02\x02-\x03", "\x02\x02\x02\x02/\x03\x02\x02\x02\x021\x03\x02", "\x02\x02\x023\x03\x02\x02\x02\x025\x03\x02\x02", "\x02\x027\x03\x02\x02\x02\x029\x03\x02\x02\x02", "\x02;\x03\x02\x02\x02\x02=\x03\x02\x02\x02\x02", "?\x03\x02\x02\x02\x02A\x03\x02\x02\x02\x02C\x03", "\x02\x02\x02\x02E\x03\x02\x02\x02\x02G\x03\x02", "\x02\x02\x02I\x03\x02\x02\x02\x02K\x03\x02\x02", "\x02\x02M\x03\x02\x02\x02\x02O\x03\x02\x02\x02", "\x02Q\x03\x02\x02\x02\x02S\x03\x02\x02\x02\x02", "U\x03\x02\x02\x02\x02W\x03\x02\x02\x02\x02Y\x03", "\x02\x02\x02\x02[\x03\x02\x02\x02\x02]\x03\x02", "\x02\x02\x02_\x03\x02\x02\x02\x02a\x03\x02\x02", "\x02\x02c\x03\x02\x02\x02\x02e\x03\x02\x02\x02", "\x02g\x03\x02\x02\x02\x02i\x03\x02\x02\x02\x02", "k\x03\x02\x02\x02\x02m\x03\x02\x02\x02\x02o\x03", "\x02\x02\x02\x02q\x03\x02\x02\x02\x02s\x03\x02", "\x02\x02\x02u\x03\x02\x02\x02\x02w\x03\x02\x02", "\x02\x02y\x03\x02\x02\x02\x02{\x03\x02\x02\x02", "\x02}\x03\x02\x02\x02\x02\x7F\x03\x02\x02\x02", "\x02\x81\x03\x02\x02\x02\x02\x83\x03\x02\x02\x02", "\x02\x85\x03\x02\x02\x02\x02\x87\x03\x02\x02\x02", "\x02\x89\x03\x02\x02\x02\x02\x8B\x03\x02\x02\x02", "\x02\x8D\x03\x02\x02\x02\x02\x8F\x03\x02\x02\x02", "\x02\x99\x03\x02\x02\x02\x02\x9B\x03\x02\x02\x02", "\x02\xAB\x03\x02\x02\x02\x02\xAD\x03\x02\x02\x02", "\x02\xAF\x03\x02\x02\x02\x02\xB1\x03\x02\x02\x02", "\x02\xB3\x03\x02\x02\x02\x02\xB5\x03\x02\x02\x02", "\x02\xB7\x03\x02\x02\x02\x03\xB9\x03\x02\x02\x02", "\x03\xBB\x03\x02\x02\x02\x03\xBD\x03\x02\x02\x02", "\x03\xBF\x03\x02\x02\x02\x03\xC1\x03\x02\x02\x02", "\x03\xC3\x03\x02\x02\x02\x03\xC5\x03\x02\x02\x02", "\x03\xC7\x03\x02\x02\x02\x03\xC9\x03\x02\x02\x02", "\x03\xCB\x03\x02\x02\x02\x03\xCD\x03\x02\x02\x02", "\x03\xCF\x03\x02\x02\x02\x03\xD1\x03\x02\x02\x02", "\x03\xD3\x03\x02\x02\x02\x03\xD5\x03\x02\x02\x02", "\x03\xD7\x03\x02\x02\x02\x03\xD9\x03\x02\x02\x02", "\x03\xDB\x03\x02\x02\x02\x03\xDD\x03\x02\x02\x02", "\x03\xDF\x03\x02\x02\x02\x03\xE1\x03\x02\x02\x02", "\x03\xE3\x03\x02\x02\x02\x03\xE5\x03\x02\x02\x02", "\x03\xE7\x03\x02\x02\x02\x03\xE9\x03\x02\x02\x02", "\x03\xEB\x03\x02\x02\x02\x03\xED\x03\x02\x02\x02", "\x03\xEF\x03\x02\x02\x02\x03\xF1\x03\x02\x02\x02", "\x03\xF3\x03\x02\x02\x02\x04\xF5\x03\x02\x02\x02", "\x04\xFF\x03\x02\x02\x02\x05\u0101\x03\x02\x02\x02", "\x07\u010B\x03\x02\x02\x02\t\u0119\x03\x02\x02\x02", "\x0B\u0125\x03\x02\x02\x02\r\u0131\x03\x02\x02\x02", "\x0F\u0138\x03\x02\x02\x02\x11\u0143\x03\x02\x02\x02", "\x13\u014F\x03\x02\x02\x02\x15\u0157\x03\x02\x02\x02", "\x17\u015D\x03\x02\x02\x02\x19\u0162\x03\x02\x02\x02", "\x1B\u0167\x03\x02\x02\x02\x1D\u016E\x03\x02\x02\x02", "\x1F\u0178\x03\x02\x02\x02!\u0182\x03\x02\x02\x02", "#\u0189\x03\x02\x02\x02%\u018F\x03\x02\x02\x02'\u019A", "\x03\x02\x02\x02)\u01A0\x03\x02\x02\x02+\u01A9\x03", "\x02\x02\x02-\u01B6\x03\x02\x02\x02/\u01BD\x03\x02", "\x02\x021\u01C6\x03\x02\x02\x023\u01C9\x03\x02\x02", "\x025\u01D4\x03\x02\x02\x027\u01DA\x03\x02\x02\x02", "9\u01DF\x03\x02\x02\x02;\u01E4\x03\x02\x02\x02=\u01EB", "\x03\x02\x02\x02?\u01F5\x03\x02\x02\x02A\u01FF\x03", "\x02\x02\x02C\u0206\x03\x02\x02\x02E\u020C\x03\x02", "\x02\x02G\u0217\x03\x02\x02\x02I\u021D\x03\x02\x02", "\x02K\u0226\x03\x02\x02\x02M\u0233\x03\x02\x02\x02", "O\u023A\x03\x02\x02\x02Q\u0243\x03\x02\x02\x02S\u0249", "\x03\x02\x02\x02U\u025D\x03\x02\x02\x02W\u026D\x03", "\x02\x02\x02Y\u027D\x03\x02\x02\x02[\u0291\x03\x02", "\x02\x02]\u0298\x03\x02\x02\x02_\u02A9\x03\x02\x02", "\x02a\u02BD\x03\x02\x02\x02c\u02C8\x03\x02\x02\x02", "e\u02D5\x03\x02\x02\x02g\u02EC\x03\x02\x02\x02i\u02EE", "\x03\x02\x02\x02k\u02F0\x03\x02\x02\x02m\u02F2\x03", "\x02\x02\x02o\u02F4\x03\x02\x02\x02q\u02F6\x03\x02", "\x02\x02s\u02F8\x03\x02\x02\x02u\u02FA\x03\x02\x02", "\x02w\u02FC\x03\x02\x02\x02y\u02FE\x03\x02\x02\x02", "{\u0300\x03\x02\x02\x02}\u0304\x03\x02\x02\x02\x7F", "\u0306\x03\x02\x02\x02\x81\u0308\x03\x02\x02\x02\x83", "\u030A\x03\x02\x02\x02\x85\u030C\x03\x02\x02\x02\x87", "\u0311\x03\x02\x02\x02\x89\u0317\x03\x02\x02\x02\x8B", "\u031C\x03\x02\x02\x02\x8D\u0323\x03\x02\x02\x02\x8F", "\u032C\x03\x02\x02\x02\x91\u033C\x03\x02\x02\x02\x93", "\u033E\x03\x02\x02\x02\x95\u0343\x03\x02\x02\x02\x97", "\u0349\x03\x02\x02\x02\x99\u0355\x03\x02\x02\x02\x9B", "\u0365\x03\x02\x02\x02\x9D\u0367\x03\x02\x02\x02\x9F", "\u0369\x03\x02\x02\x02\xA1\u036B\x03\x02\x02\x02\xA3", "\u0371\x03\x02\x02\x02\xA5\u037A\x03\x02\x02\x02\xA7", "\u037C\x03\x02\x02\x02\xA9\u037E\x03\x02\x02\x02\xAB", "\u0381\x03\x02\x02\x02\xAD\u0387\x03\x02\x02\x02\xAF", "\u038B\x03\x02\x02\x02\xB1\u0397\x03\x02\x02\x02\xB3", "\u039B\x03\x02\x02\x02\xB5\u039F\x03\x02\x02\x02\xB7", "\u03A1\x03\x02\x02\x02\xB9\u03A7\x03\x02\x02\x02\xBB", "\u03AE\x03\x02\x02\x02\xBD\u03B3\x03\x02\x02\x02\xBF", "\u03BE\x03\x02\x02\x02\xC1\u03C3\x03\x02\x02\x02\xC3", "\u03CA\x03\x02\x02\x02\xC5\u03D0\x03\x02\x02\x02\xC7", "\u03D7\x03\x02\x02\x02\xC9\u03D9\x03\x02\x02\x02\xCB", "\u03DB\x03\x02\x02\x02\xCD\u03DD\x03\x02\x02\x02\xCF", "\u03DF\x03\x02\x02\x02\xD1\u03E1\x03\x02\x02\x02\xD3", "\u03E5\x03\x02\x02\x02\xD5\u03EB\x03\x02\x02\x02\xD7", "\u03F0\x03\x02\x02\x02\xD9\u03F5\x03\x02\x02\x02\xDB", "\u03FC\x03\x02\x02\x02\xDD\u0406\x03\x02\x02\x02\xDF", "\u0410\x03\x02\x02\x02\xE1\u0417\x03\x02\x02\x02\xE3", "\u041D\x03\x02\x02\x02\xE5\u0428\x03\x02\x02\x02\xE7", "\u042E\x03\x02\x02\x02\xE9\u0437\x03\x02\x02\x02\xEB", "\u0444\x03\x02\x02\x02\xED\u044B\x03\x02\x02\x02\xEF", "\u0454\x03\x02\x02\x02\xF1\u0457\x03\x02\x02\x02\xF3", "\u0462\x03\x02\x02\x02\xF5\u0466\x03\x02\x02\x02\xF7", "\u0473\x03\x02\x02\x02\xF9\u0475\x03\x02\x02\x02\xFB", "\u047A\x03\x02\x02\x02\xFD\u0480\x03\x02\x02\x02\xFF", "\u0483\x03\x02\x02\x02\u0101\u0102\x07B\x02\x02\u0102", "\u0103\x07g\x02\x02\u0103\u0104\x07z\x02\x02\u0104\u0105", "\x07v\x02\x02\u0105\u0106\x07g\x02\x02\u0106\u0107\x07", "t\x02\x02\u0107\u0108\x07p\x02\x02\u0108\u0109\x07c\x02", "\x02\u0109\u010A\x07n\x02\x02\u010A\x06\x03\x02\x02", "\x02\u010B\u010C\x07B\x02\x02\u010C\u010D\x07k\x02\x02", "\u010D\u010E\x07p\x02\x02\u010E\u010F\x07c\x02\x02\u010F", "\u0110\x07e\x02\x02\u0110\u0111\x07e\x02\x02\u0111\u0112", "\x07g\x02\x02\u0112\u0113\x07u\x02\x02\u0113\u0114\x07", "u\x02\x02\u0114\u0115\x07k\x02\x02\u0115\u0116\x07d\x02", "\x02\u0116\u0117\x07n\x02\x02\u0117\u0118\x07g\x02\x02", "\u0118\b\x03\x02\x02\x02\u0119\u011A\x07B\x02\x02\u011A", "\u011B\x07t\x02\x02\u011B\u011C\x07g\x02\x02\u011C\u011D", "\x07s\x02\x02\u011D\u011E\x07w\x02\x02\u011E\u011F\x07", "k\x02\x02\u011F\u0120\x07t\x02\x02\u0120\u0121\x07g\x02", "\x02\u0121\u0122\x07u\x02\x02\u0122\u0123\x03\x02\x02", "\x02\u0123\u0124\b\x04\x02\x02\u0124\n\x03\x02\x02\x02", "\u0125\u0126\x07B\x02\x02\u0126\u0127\x07r\x02\x02\u0127", "\u0128\x07t\x02\x02\u0128\u0129\x07q\x02\x02\u0129\u012A", "\x07x\x02\x02\u012A\u012B\x07k\x02\x02\u012B\u012C\x07", "f\x02\x02\u012C\u012D\x07g\x02\x02\u012D\u012E\x07u\x02", "\x02\u012E\u012F\x03\x02\x02\x02\u012F\u0130\b\x05\x02", "\x02\u0130\f\x03\x02\x02\x02\u0131\u0132\x07B\x02\x02", "\u0132\u0133\x07m\x02\x02\u0133\u0134\x07g\x02\x02\u0134", "\u0135\x07{\x02\x02\u0135\u0136\x03\x02\x02\x02\u0136", "\u0137\b\x06\x02\x02\u0137\x0E\x03\x02\x02\x02\u0138", "\u0139\x07B\x02\x02\u0139\u013A\x07u\x02\x02\u013A\u013B", "\x07j\x02\x02\u013B\u013C\x07c\x02\x02\u013C\u013D\x07", "t\x02\x02\u013D\u013E\x07g\x02\x02\u013E\u013F\x07c\x02", "\x02\u013F\u0140\x07d\x02\x02\u0140\u0141\x07n\x02\x02", "\u0141\u0142\x07g\x02\x02\u0142\x10\x03\x02\x02\x02", "\u0143\u0144\x07B\x02\x02\u0144\u0145\x07q\x02\x02\u0145", "\u0146\x07x\x02\x02\u0146\u0147\x07g\x02\x02\u0147\u0148", "\x07t\x02\x02\u0148\u0149\x07t\x02\x02\u0149\u014A\x07", "k\x02\x02\u014A\u014B\x07f\x02\x02\u014B\u014C\x07g\x02", "\x02\u014C\u014D\x03\x02\x02\x02\u014D\u014E\b\b\x02\x02", "\u014E\x12\x03\x02\x02\x02\u014F\u0150\x07B\x02\x02", "\u0150\u0151\x07n\x02\x02\u0151\u0152\x07k\x02\x02\u0152", "\u0153\x07p\x02\x02\u0153\u0154\x07m\x02\x02\u0154\u0155", "\x03\x02\x02\x02\u0155\u0156\b\t\x03\x02\u0156\x14\x03", "\x02\x02\x02\u0157\u0158\x07k\x02\x02\u0158\u0159\x07", "p\x02\x02\u0159\u015A\x07r\x02\x02\u015A\u015B\x07w\x02", "\x02\u015B\u015C\x07v\x02\x02\u015C\x16\x03\x02\x02", "\x02\u015D\u015E\x07v\x02\x02\u015E\u015F\x07{\x02\x02", "\u015F\u0160\x07r\x02\x02\u0160\u0161\x07g\x02\x02\u0161", "\x18\x03\x02\x02\x02\u0162\u0163\x07g\x02\x02\u0163", "\u0164\x07p\x02\x02\u0164\u0165\x07w\x02\x02\u0165\u0166", "\x07o\x02\x02\u0166\x1A\x03\x02\x02\x02\u0167\u0168", "\x07u\x02\x02\u0168\u0169\x07e\x02\x02\u0169\u016A\x07", "c\x02\x02\u016A\u016B\x07n\x02\x02\u016B\u016C\x07c\x02", "\x02\u016C\u016D\x07t\x02\x02\u016D\x1C\x03\x02\x02", "\x02\u016E\u016F\x07k\x02\x02\u016F\u0170\x07p\x02\x02", "\u0170\u0171\x07v\x02\x02\u0171\u0172\x07g\x02\x02\u0172", "\u0173\x07t\x02\x02\u0173\u0174\x07h\x02\x02\u0174\u0175", "\x07c\x02\x02\u0175\u0176\x07e\x02\x02\u0176\u0177\x07", "g\x02\x02\u0177\x1E\x03\x02\x02\x02\u0178\u0179\x07", "f\x02\x02\u0179\u017A\x07k\x02\x02\u017A\u017B\x07t\x02", "\x02\u017B\u017C\x07g\x02\x02\u017C\u017D\x07e\x02\x02", "\u017D\u017E\x07v\x02\x02\u017E\u017F\x07k\x02\x02\u017F", "\u0180\x07x\x02\x02\u0180\u0181\x07g\x02\x02\u0181 \x03", "\x02\x02\x02\u0182\u0183\x07g\x02\x02\u0183\u0184\x07", "z\x02\x02\u0184\u0185\x07v\x02\x02\u0185\u0186\x07g\x02", "\x02\u0186\u0187\x07p\x02\x02\u0187\u0188\x07f\x02\x02", "\u0188\"\x03\x02\x02\x02\u0189\u018A\x07w\x02\x02\u018A", "\u018B\x07p\x02\x02\u018B\u018C\x07k\x02\x02\u018C\u018D", "\x07q\x02\x02\u018D\u018E\x07p\x02\x02\u018E$\x03\x02", "\x02\x02\u018F\u0190\x07k\x02\x02\u0190\u0191\x07o\x02", "\x02\u0191\u0192\x07r\x02\x02\u0192\u0193\x07n\x02\x02", "\u0193\u0194\x07g\x02\x02\u0194\u0195\x07o\x02\x02\u0195", "\u0196\x07g\x02\x02\u0196\u0197\x07p\x02\x02\u0197\u0198", "\x07v\x02\x02\u0198\u0199\x07u\x02\x02\u0199&\x03\x02", "\x02\x02\u019A\u019B\x07s\x02\x02\u019B\u019C\x07w\x02", "\x02\u019C\u019D\x07g\x02\x02\u019D\u019E\x07t\x02\x02", "\u019E\u019F\x07{\x02\x02\u019F(\x03\x02\x02\x02\u01A0", "\u01A1\x07o\x02\x02\u01A1\u01A2\x07w\x02\x02\u01A2\u01A3", "\x07v\x02\x02\u01A3\u01A4\x07c\x02\x02\u01A4\u01A5\x07", "v\x02\x02\u01A5\u01A6\x07k\x02\x02\u01A6\u01A7\x07q\x02", "\x02\u01A7\u01A8\x07p\x02\x02\u01A8*\x03\x02\x02\x02", "\u01A9\u01AA\x07u\x02\x02\u01AA\u01AB\x07w\x02\x02\u01AB", "\u01AC\x07d\x02\x02\u01AC\u01AD\x07u\x02\x02\u01AD\u01AE", "\x07e\x02\x02\u01AE\u01AF\x07t\x02\x02\u01AF\u01B0\x07", "k\x02\x02\u01B0\u01B1\x07r\x02\x02\u01B1\u01B2\x07v\x02", "\x02\u01B2\u01B3\x07k\x02\x02\u01B3\u01B4\x07q\x02\x02", "\u01B4\u01B5\x07p\x02\x02\u01B5,\x03\x02\x02\x02\u01B6", "\u01B7\x07u\x02\x02\u01B7\u01B8\x07e\x02\x02\u01B8\u01B9", "\x07j\x02\x02\u01B9\u01BA\x07g\x02\x02\u01BA\u01BB\x07", "o\x02\x02\u01BB\u01BC\x07c\x02\x02\u01BC.\x03\x02\x02", "\x02\u01BD\u01BE\x07h\x02\x02\u01BE\u01BF\x07t\x02\x02", "\u01BF\u01C0\x07c\x02\x02\u01C0\u01C1\x07i\x02\x02\u01C1", "\u01C2\x07o\x02\x02\u01C2\u01C3\x07g\x02\x02\u01C3\u01C4", "\x07p\x02\x02\u01C4\u01C5\x07v\x02\x02\u01C50\x03\x02", "\x02\x02\u01C6\u01C7\x07q\x02\x02\u01C7\u01C8\x07p\x02", "\x02\u01C82\x03\x02\x02\x02\u01C9\u01CA\x07t\x02\x02", "\u01CA\u01CB\x07g\x02\x02\u01CB\u01CC\x07r\x02\x02\u01CC", "\u01CD\x07g\x02\x02\u01CD\u01CE\x07c\x02\x02\u01CE\u01CF", "\x07v\x02\x02\u01CF\u01D0\x07c\x02\x02\u01D0\u01D1\x07", "d\x02\x02\u01D1\u01D2\x07n\x02\x02\u01D2\u01D3\x07g\x02", "\x02\u01D34\x03\x02\x02\x02\u01D4\u01D5\x07K\x02\x02", "\u01D5\u01D6\x07P\x02\x02\u01D6\u01D7\x07R\x02\x02\u01D7", "\u01D8\x07W\x02\x02\u01D8\u01D9\x07V\x02\x02\u01D96\x03", "\x02\x02\x02\u01DA\u01DB\x07V\x02\x02\u01DB\u01DC\x07", "[\x02\x02\u01DC\u01DD\x07R\x02\x02\u01DD\u01DE\x07G\x02", "\x02\u01DE8\x03\x02\x02\x02\u01DF\u01E0\x07G\x02\x02", "\u01E0\u01E1\x07P\x02\x02\u01E1\u01E2\x07W\x02\x02\u01E2", "\u01E3\x07O\x02\x02\u01E3:\x03\x02\x02\x02\u01E4\u01E5", "\x07U\x02\x02\u01E5\u01E6\x07E\x02\x02\u01E6\u01E7\x07", "C\x02\x02\u01E7\u01E8\x07N\x02\x02\u01E8\u01E9\x07C\x02", "\x02\u01E9\u01EA\x07T\x02\x02\u01EA<\x03\x02\x02\x02", "\u01EB\u01EC\x07K\x02\x02\u01EC\u01ED\x07P\x02\x02\u01ED", "\u01EE\x07V\x02\x02\u01EE\u01EF\x07G\x02\x02\u01EF\u01F0", "\x07T\x02\x02\u01F0\u01F1\x07H\x02\x02\u01F1\u01F2\x07", "C\x02\x02\u01F2\u01F3\x07E\x02\x02\u01F3\u01F4\x07G\x02", "\x02\u01F4>\x03\x02\x02\x02\u01F5\u01F6\x07F\x02\x02", "\u01F6\u01F7\x07K\x02\x02\u01F7\u01F8\x07T\x02\x02\u01F8", "\u01F9\x07G\x02\x02\u01F9\u01FA\x07E\x02\x02\u01FA\u01FB", "\x07V\x02\x02\u01FB\u01FC\x07K\x02\x02\u01FC\u01FD\x07", "X\x02\x02\u01FD\u01FE\x07G\x02\x02\u01FE@\x03\x02\x02", "\x02\u01FF\u0200\x07G\x02\x02\u0200\u0201\x07Z\x02\x02", "\u0201\u0202\x07V\x02\x02\u0202\u0203\x07G\x02\x02\u0203", "\u0204\x07P\x02\x02\u0204\u0205\x07F\x02\x02\u0205B\x03", "\x02\x02\x02\u0206\u0207\x07W\x02\x02\u0207\u0208\x07", "P\x02\x02\u0208\u0209\x07K\x02\x02\u0209\u020A\x07Q\x02", "\x02\u020A\u020B\x07P\x02\x02\u020BD\x03\x02\x02\x02", "\u020C\u020D\x07K\x02\x02\u020D\u020E\x07O\x02\x02\u020E", "\u020F\x07R\x02\x02\u020F\u0210\x07N\x02\x02\u0210\u0211", "\x07G\x02\x02\u0211\u0212\x07O\x02\x02\u0212\u0213\x07", "G\x02\x02\u0213\u0214\x07P\x02\x02\u0214\u0215\x07V\x02", "\x02\u0215\u0216\x07U\x02\x02\u0216F\x03\x02\x02\x02", "\u0217\u0218\x07S\x02\x02\u0218\u0219\x07W\x02\x02\u0219", "\u021A\x07G\x02\x02\u021A\u021B\x07T\x02\x02\u021B\u021C", "\x07[\x02\x02\u021CH\x03\x02\x02\x02\u021D\u021E\x07", "O\x02\x02\u021E\u021F\x07W\x02\x02\u021F\u0220\x07V\x02", "\x02\u0220\u0221\x07C\x02\x02\u0221\u0222\x07V\x02\x02", "\u0222\u0223\x07K\x02\x02\u0223\u0224\x07Q\x02\x02\u0224", "\u0225\x07P\x02\x02\u0225J\x03\x02\x02\x02\u0226\u0227", "\x07U\x02\x02\u0227\u0228\x07W\x02\x02\u0228\u0229\x07", "D\x02\x02\u0229\u022A\x07U\x02\x02\u022A\u022B\x07E\x02", "\x02\u022B\u022C\x07T\x02\x02\u022C\u022D\x07K\x02\x02", "\u022D\u022E\x07R\x02\x02\u022E\u022F\x07V\x02\x02\u022F", "\u0230\x07K\x02\x02\u0230\u0231\x07Q\x02\x02\u0231\u0232", "\x07P\x02\x02\u0232L\x03\x02\x02\x02\u0233\u0234\x07", "U\x02\x02\u0234\u0235\x07E\x02\x02\u0235\u0236\x07J\x02", "\x02\u0236\u0237\x07G\x02\x02\u0237\u0238\x07O\x02\x02", "\u0238\u0239\x07C\x02\x02\u0239N\x03\x02\x02\x02\u023A", "\u023B\x07H\x02\x02\u023B\u023C\x07T\x02\x02\u023C\u023D", "\x07C\x02\x02\u023D\u023E\x07I\x02\x02\u023E\u023F\x07", "O\x02\x02\u023F\u0240\x07G\x02\x02\u0240\u0241\x07P\x02", "\x02\u0241\u0242\x07V\x02\x02\u0242P\x03\x02\x02\x02", "\u0243\u0244\x07H\x02\x02\u0244\u0245\x07K\x02\x02\u0245", "\u0246\x07G\x02\x02\u0246\u0247\x07N\x02\x02\u0247\u0248", "\x07F\x02\x02\u0248R\x03\x02\x02\x02\u0249\u024A\x07", "H\x02\x02\u024A\u024B\x07T\x02\x02\u024B\u024C\x07C\x02", "\x02\u024C\u024D\x07I\x02\x02\u024D\u024E\x07O\x02\x02", "\u024E\u024F\x07G\x02\x02\u024F\u0250\x07P\x02\x02\u0250", "\u0251\x07V\x02\x02\u0251\u0252\x07a\x02\x02\u0252\u0253", "\x07F\x02\x02\u0253\u0254\x07G\x02\x02\u0254\u0255\x07", "H\x02\x02\u0255\u0256\x07K\x02\x02\u0256\u0257\x07P\x02", "\x02\u0257\u0258\x07K\x02\x02\u0258\u0259\x07V\x02\x02", "\u0259\u025A\x07K\x02\x02\u025A\u025B\x07Q\x02\x02\u025B", "\u025C\x07P\x02\x02\u025CT\x03\x02\x02\x02\u025D\u025E", "\x07H\x02\x02\u025E\u025F\x07T\x02\x02\u025F\u0260\x07", "C\x02\x02\u0260\u0261\x07I\x02\x02\u0261\u0262\x07O\x02", "\x02\u0262\u0263\x07G\x02\x02\u0263\u0264\x07P\x02\x02", "\u0264\u0265\x07V\x02\x02\u0265\u0266\x07a\x02\x02\u0266", "\u0267\x07U\x02\x02\u0267\u0268\x07R\x02\x02\u0268\u0269", "\x07T\x02\x02\u0269\u026A\x07G\x02\x02\u026A\u026B\x07", "C\x02\x02\u026B\u026C\x07F\x02\x02\u026CV\x03\x02\x02", "\x02\u026D\u026E\x07K\x02\x02\u026E\u026F\x07P\x02\x02", "\u026F\u0270\x07N\x02\x02\u0270\u0271\x07K\x02\x02\u0271", "\u0272\x07P\x02\x02\u0272\u0273\x07G\x02\x02\u0273\u0274", "\x07a\x02\x02\u0274\u0275\x07H\x02\x02\u0275\u0276\x07", "T\x02\x02\u0276\u0277\x07C\x02\x02\u0277\u0278\x07I\x02", "\x02\u0278\u0279\x07O\x02\x02\u0279\u027A\x07G\x02\x02", "\u027A\u027B\x07P\x02\x02\u027B\u027C\x07V\x02\x02\u027C", "X\x03\x02\x02\x02\u027D\u027E\x07X\x02\x02\u027E\u027F", "\x07C\x02\x02\u027F\u0280\x07T\x02\x02\u0280\u0281\x07", "K\x02\x02\u0281\u0282\x07C\x02\x02\u0282\u0283\x07D\x02", "\x02\u0283\u0284\x07N\x02\x02\u0284\u0285\x07G\x02\x02", "\u0285\u0286\x07a\x02\x02\u0286\u0287\x07F\x02\x02\u0287", "\u0288\x07G\x02\x02\u0288\u0289\x07H\x02\x02\u0289\u028A", "\x07K\x02\x02\u028A\u028B\x07P\x02\x02\u028B\u028C\x07", "K\x02\x02\u028C\u028D\x07V\x02\x02\u028D\u028E\x07K\x02", "\x02\u028E\u028F\x07Q\x02\x02\u028F\u0290\x07P\x02\x02", "\u0290Z\x03\x02\x02\x02\u0291\u0292\x07Q\x02\x02\u0292", "\u0293\x07D\x02\x02\u0293\u0294\x07L\x02\x02\u0294\u0295", "\x07G\x02\x02\u0295\u0296\x07E\x02\x02\u0296\u0297\x07", "V\x02\x02\u0297\\\x03\x02\x02\x02\u0298\u0299\x07H\x02", "\x02\u0299\u029A\x07K\x02\x02\u029A\u029B\x07G\x02\x02", "\u029B\u029C\x07N\x02\x02\u029C\u029D\x07F\x02\x02\u029D", "\u029E\x07a\x02\x02\u029E\u029F\x07F\x02\x02\u029F\u02A0", "\x07G\x02\x02\u02A0\u02A1\x07H\x02\x02\u02A1\u02A2\x07", "K\x02\x02\u02A2\u02A3\x07P\x02\x02\u02A3\u02A4\x07K\x02", "\x02\u02A4\u02A5\x07V\x02\x02\u02A5\u02A6\x07K\x02\x02", "\u02A6\u02A7\x07Q\x02\x02\u02A7\u02A8\x07P\x02\x02\u02A8", "^\x03\x02\x02\x02\u02A9\u02AA\x07C\x02\x02\u02AA\u02AB", "\x07T\x02\x02\u02AB\u02AC\x07I\x02\x02\u02AC\u02AD\x07", "W\x02\x02\u02AD\u02AE\x07O\x02\x02\u02AE\u02AF\x07G\x02", "\x02\u02AF\u02B0\x07P\x02\x02\u02B0\u02B1\x07V\x02\x02", "\u02B1\u02B2\x07a\x02\x02\u02B2\u02B3\x07F\x02\x02\u02B3", "\u02B4\x07G\x02\x02\u02B4\u02B5\x07H\x02\x02\u02B5\u02B6", "\x07K\x02\x02\u02B6\u02B7\x07P\x02\x02\u02B7\u02B8\x07", "K\x02\x02\u02B8\u02B9\x07V\x02\x02\u02B9\u02BA\x07K\x02", "\x02\u02BA\u02BB\x07Q\x02\x02\u02BB\u02BC\x07P\x02\x02", "\u02BC`\x03\x02\x02\x02\u02BD\u02BE\x07G\x02\x02\u02BE", "\u02BF\x07P\x02\x02\u02BF\u02C0\x07W\x02\x02\u02C0\u02C1", "\x07O\x02\x02\u02C1\u02C2\x07a\x02\x02\u02C2\u02C3\x07", "X\x02\x02\u02C3\u02C4\x07C\x02\x02\u02C4\u02C5\x07N\x02", "\x02\u02C5\u02C6\x07W\x02\x02\u02C6\u02C7\x07G\x02\x02", "\u02C7b\x03\x02\x02\x02\u02C8\u02C9\x07K\x02\x02\u02C9", "\u02CA\x07P\x02\x02\u02CA\u02CB\x07R\x02\x02\u02CB\u02CC", "\x07W\x02\x02\u02CC\u02CD\x07V\x02\x02\u02CD\u02CE\x07", "a\x02\x02\u02CE\u02CF\x07Q\x02\x02\u02CF\u02D0\x07D\x02", "\x02\u02D0\u02D1\x07L\x02\x02\u02D1\u02D2\x07G\x02\x02", "\u02D2\u02D3\x07E\x02\x02\u02D3\u02D4\x07V\x02\x02\u02D4", "d\x03\x02\x02\x02\u02D5\u02D6\x07K\x02\x02\u02D6\u02D7", "\x07P\x02\x02\u02D7\u02D8\x07R\x02\x02\u02D8\u02D9\x07", "W\x02\x02\u02D9\u02DA\x07V\x02\x02\u02DA\u02DB\x07a\x02", "\x02\u02DB\u02DC\x07H\x02\x02\u02DC\u02DD\x07K\x02\x02", "\u02DD\u02DE\x07G\x02\x02\u02DE\u02DF\x07N\x02\x02\u02DF", "\u02E0\x07F\x02\x02\u02E0\u02E1\x07a\x02\x02\u02E1\u02E2", "\x07F\x02\x02\u02E2\u02E3\x07G\x02\x02\u02E3\u02E4\x07", "H\x02\x02\u02E4\u02E5\x07K\x02\x02\u02E5\u02E6\x07P\x02", "\x02\u02E6\u02E7\x07K\x02\x02\u02E7\u02E8\x07V\x02\x02", "\u02E8\u02E9\x07K\x02\x02\u02E9\u02EA\x07Q\x02\x02\u02EA", "\u02EB\x07P\x02\x02\u02EBf\x03\x02\x02\x02\u02EC\u02ED", "\x07}\x02\x02\u02EDh\x03\x02\x02\x02\u02EE\u02EF\x07", "\x7F\x02\x02\u02EFj\x03\x02\x02\x02\u02F0\u02F1\x07", "]\x02\x02\u02F1l\x03\x02\x02\x02\u02F2\u02F3\x07_\x02", "\x02\u02F3n\x03\x02\x02\x02\u02F4\u02F5\x07*\x02\x02", "\u02F5p\x03\x02\x02\x02\u02F6\u02F7\x07+\x02\x02\u02F7", "r\x03\x02\x02\x02\u02F8\u02F9\x07B\x02\x02\u02F9t\x03", "\x02\x02\x02\u02FA\u02FB\x07(\x02\x02\u02FBv\x03\x02", "\x02\x02\u02FC\u02FD\x07?\x02\x02\u02FDx\x03\x02\x02", "\x02\u02FE\u02FF\x07<\x02\x02\u02FFz\x03\x02\x02\x02", "\u0300\u0301\x070\x02\x02\u0301\u0302\x070\x02\x02\u0302", "\u0303\x070\x02\x02\u0303|\x03\x02\x02\x02\u0304\u0305", "\x07#\x02\x02\u0305~\x03\x02\x02\x02\u0306\u0307\x07", "~\x02\x02\u0307\x80\x03\x02\x02\x02\u0308\u0309\x07", "&\x02\x02\u0309\x82\x03\x02\x02\x02\u030A\u030B\x07", "$\x02\x02\u030B\x84\x03\x02\x02\x02\u030C\u030D\x07", "v\x02\x02\u030D\u030E\x07t\x02\x02\u030E\u030F\x07w\x02", "\x02\u030F\u0310\x07g\x02\x02\u0310\x86\x03\x02\x02", "\x02\u0311\u0312\x07h\x02\x02\u0312\u0313\x07c\x02\x02", "\u0313\u0314\x07n\x02\x02\u0314\u0315\x07u\x02\x02\u0315", "\u0316\x07g\x02\x02\u0316\x88\x03\x02\x02\x02\u0317", "\u0318\x07p\x02\x02\u0318\u0319\x07w\x02\x02\u0319\u031A", "\x07n\x02\x02\u031A\u031B\x07n\x02\x02\u031B\x8A\x03", "\x02\x02\x02\u031C\u0320\t\x02\x02\x02\u031D\u031F\t\x03", "\x02\x02\u031E\u031D\x03\x02\x02\x02\u031F\u0322\x03\x02", "\x02\x02\u0320\u031E\x03\x02\x02\x02\u0320\u0321\x03\x02", "\x02\x02\u0321\x8C\x03\x02\x02\x02\u0322\u0320\x03\x02", "\x02\x02\u0323\u0327\x07$\x02\x02\u0324\u0326\x05\x91", "H\x02\u0325\u0324\x03\x02\x02\x02\u0326\u0329\x03\x02", "\x02\x02\u0327\u0325\x03\x02\x02\x02\u0327\u0328\x03\x02", "\x02\x02\u0328\u032A\x03\x02\x02\x02\u0329\u0327\x03\x02", "\x02\x02\u032A\u032B\x07$\x02\x02\u032B\x8E\x03\x02", "\x02\x02\u032C\u032D\x07$\x02\x02\u032D\u032E\x07$\x02", "\x02\u032E\u032F\x07$\x02\x02\u032F\u0333\x03\x02\x02", "\x02\u0330\u0332\x0B\x02\x02\x02\u0331\u0330\x03\x02\x02", "\x02\u0332\u0335\x03\x02\x02\x02\u0333\u0334\x03\x02\x02", "\x02\u0333\u0331\x03\x02\x02\x02\u0334\u0336\x03\x02\x02", "\x02\u0335\u0333\x03\x02\x02\x02\u0336\u0337\x07$\x02", "\x02\u0337\u0338\x07$\x02\x02\u0338\u0339\x07$\x02\x02", "\u0339\x90\x03\x02\x02\x02\u033A\u033D\x05\x93I\x02", "\u033B\u033D\n\x04\x02\x02\u033C\u033A\x03\x02\x02\x02", "\u033C\u033B\x03\x02\x02\x02\u033D\x92\x03\x02\x02\x02", "\u033E\u0341\x07^\x02\x02\u033F\u0342\t\x05\x02\x02\u0340", "\u0342\x05\x95J\x02\u0341\u033F\x03\x02\x02\x02\u0341", "\u0340\x03\x02\x02\x02\u0342\x94\x03\x02\x02\x02\u0343", "\u0344\x07w\x02\x02\u0344\u0345\x05\x97K\x02\u0345\u0346", "\x05\x97K\x02\u0346\u0347\x05\x97K\x02\u0347\u0348\x05", "\x97K\x02\u0348\x96\x03\x02\x02\x02\u0349\u034A\t\x06", "\x02\x02\u034A\x98\x03\x02\x02\x02\u034B\u034C\x05\x9B", "M\x02\u034C\u034D\x05\xA1P\x02\u034D\u0356\x03\x02\x02", "\x02\u034E\u034F\x05\x9BM\x02\u034F\u0350\x05\xA3Q\x02", "\u0350\u0356\x03\x02\x02\x02\u0351\u0352\x05\x9BM\x02", "\u0352\u0353\x05\xA1P\x02\u0353\u0354\x05\xA3Q\x02\u0354", "\u0356\x03\x02\x02\x02\u0355\u034B\x03\x02\x02\x02\u0355", "\u034E\x03\x02\x02\x02\u0355\u0351\x03\x02\x02\x02\u0356", "\x9A\x03\x02\x02\x02\u0357\u0359\x05\xA9T\x02\u0358", "\u0357\x03\x02\x02\x02\u0358\u0359\x03\x02\x02\x02\u0359", "\u035A\x03\x02\x02\x02\u035A\u0366\x072\x02\x02\u035B", "\u035D\x05\xA9T\x02\u035C\u035B\x03\x02\x02\x02\u035C", "\u035D\x03\x02\x02\x02\u035D\u035E\x03\x02\x02\x02\u035E", "\u0362\x05\x9DN\x02\u035F\u0361\x05\x9FO\x02\u0360\u035F", "\x03\x02\x02\x02\u0361\u0364\x03\x02\x02\x02\u0362\u0360", "\x03\x02\x02\x02\u0362\u0363\x03\x02\x02\x02\u0363\u0366", "\x03\x02\x02\x02\u0364\u0362\x03\x02\x02\x02\u0365\u0358", "\x03\x02\x02\x02\u0365\u035C\x03\x02\x02\x02\u0366\x9C", "\x03\x02\x02\x02\u0367\u0368\t\x07\x02\x02\u0368\x9E", "\x03\x02\x02\x02\u0369\u036A\t\b\x02\x02\u036A\xA0\x03", "\x02\x02\x02\u036B\u036D\x070\x02\x02\u036C\u036E\x05", "\x9FO\x02\u036D\u036C\x03\x02\x02\x02\u036E\u036F\x03", "\x02\x02\x02\u036F\u036D\x03\x02\x02\x02\u036F\u0370\x03", "\x02\x02\x02\u0370\xA2\x03\x02\x02\x02\u0371\u0373\x05", "\xA5R\x02\u0372\u0374\x05\xA7S\x02\u0373\u0372\x03\x02", "\x02\x02\u0373\u0374\x03\x02\x02\x02\u0374\u0376\x03\x02", "\x02\x02\u0375\u0377\x05\x9FO\x02\u0376\u0375\x03\x02", "\x02\x02\u0377\u0378\x03\x02\x02\x02\u0378\u0376\x03\x02", "\x02\x02\u0378\u0379\x03\x02\x02\x02\u0379\xA4\x03\x02", "\x02\x02\u037A\u037B\t\t\x02\x02\u037B\xA6\x03\x02\x02", "\x02\u037C\u037D\t\n\x02\x02\u037D\xA8\x03\x02\x02\x02", "\u037E\u037F\x07/\x02\x02\u037F\xAA\x03\x02\x02\x02", "\u0380\u0382\t\x0B\x02\x02\u0381\u0380\x03\x02\x02\x02", "\u0382\u0383\x03\x02\x02\x02\u0383\u0381\x03\x02\x02\x02", "\u0383\u0384\x03\x02\x02\x02\u0384\u0385\x03\x02\x02\x02", "\u0385\u0386\bU\x04\x02\u0386\xAC\x03\x02\x02\x02\u0387", "\u0388\x07.\x02\x02\u0388\u0389\x03\x02\x02\x02\u0389", "\u038A\bV\x04\x02\u038A\xAE\x03\x02\x02\x02\u038B\u038F", "\x07%\x02\x02\u038C\u038E\n\f\x02\x02\u038D\u038C\x03\x02", "\x02\x02\u038E\u0391\x03\x02\x02\x02\u038F\u038D\x03\x02", "\x02\x02\u038F\u0390\x03\x02\x02\x02\u0390\u0392\x03\x02", "\x02\x02\u0391\u038F\x03\x02\x02\x02\u0392\u0393\bW\x04", "\x02\u0393\xB0\x03\x02\x02\x02\u0394\u0398\x05\xB3Y", "\x02\u0395\u0398\x05\xB5Z\x02\u0396\u0398\x05\xB7[\x02", "\u0397\u0394\x03\x02\x02\x02\u0397\u0395\x03\x02\x02\x02", "\u0397\u0396\x03\x02\x02\x02\u0398\u0399\x03\x02\x02\x02", "\u0399\u039A\bX\x04\x02\u039A\xB2\x03\x02\x02\x02\u039B", "\u039C\x07\uEFBD\x02\x02\u039C\u039D\x07D\x02\x02\u039D", "\u039E\x07H\x02\x02\u039E\xB4\x03\x02\x02\x02\u039F", "\u03A0\x07\uFF01\x02\x02\u03A0\xB6\x03\x02\x02\x02\u03A1", "\u03A2\x07\x02\x02\x02\u03A2\u03A3\x07H\x02\x02\u03A3", "\u03A4\x07G\x02\x02\u03A4\u03A5\x07H\x02\x02\u03A5\u03A6", "\x07H\x02\x02\u03A6\xB8\x03\x02\x02\x02\u03A7\u03A8", "\x07h\x02\x02\u03A8\u03A9\x07k\x02\x02\u03A9\u03AA\x07", "g\x02\x02\u03AA\u03AB\x07n\x02\x02\u03AB\u03AC\x07f\x02", "\x02\u03AC\u03AD\x07u\x02\x02\u03AD\xBA\x03\x02\x02", "\x02\u03AE\u03AF\x07h\x02\x02\u03AF\u03B0\x07t\x02\x02", "\u03B0\u03B1\x07q\x02\x02\u03B1\u03B2\x07o\x02\x02\u03B2", "\xBC\x03\x02\x02\x02\u03B3\u03B4\x07t\x02\x02\u03B4", "\u03B5\x07g\x02\x02\u03B5\u03B6\x07u\x02\x02\u03B6\u03B7", "\x07q\x02\x02\u03B7\u03B8\x07n\x02\x02\u03B8\u03B9\x07", "x\x02\x02\u03B9\u03BA\x07c\x02\x02\u03BA\u03BB\x07d\x02", "\x02\u03BB\u03BC\x07n\x02\x02\u03BC\u03BD\x07g\x02\x02", "\u03BD\xBE\x03\x02\x02\x02\u03BE\u03BF\x07v\x02\x02", "\u03BF\u03C0\x07t\x02\x02\u03C0\u03C1\x07w\x02\x02\u03C1", "\u03C2\x07g\x02\x02\u03C2\xC0\x03\x02\x02\x02\u03C3", "\u03C4\x07h\x02\x02\u03C4\u03C5\x07c\x02\x02\u03C5\u03C6", "\x07n\x02\x02\u03C6\u03C7\x07u\x02\x02\u03C7\u03C8\x07", "g\x02\x02\u03C8\xC2\x03\x02\x02\x02\u03C9\u03CB\t\r\x02", "\x02\u03CA\u03C9\x03\x02\x02\x02\u03CB\u03CC\x03\x02\x02", "\x02\u03CC\u03CA\x03\x02\x02\x02\u03CC\u03CD\x03\x02\x02", "\x02\u03CD\u03CE\x03\x02\x02\x02\u03CE\u03CF\ba\x04\x02", "\u03CF\xC4\x03\x02\x02\x02\u03D0\u03D4\t\x02\x02\x02", "\u03D1\u03D3\t\x03\x02\x02\u03D2\u03D1\x03\x02\x02\x02", "\u03D3\u03D6\x03\x02\x02\x02\u03D4\u03D2\x03\x02\x02\x02", "\u03D4\u03D5\x03\x02\x02\x02\u03D5\xC6\x03\x02\x02\x02", "\u03D6\u03D4\x03\x02\x02\x02\u03D7\u03D8\x07$\x02\x02", "\u03D8\xC8\x03\x02\x02\x02\u03D9\u03DA\x07<\x02\x02", "\u03DA\xCA\x03\x02\x02\x02\u03DB\u03DC\x07}\x02\x02", "\u03DC\xCC\x03\x02\x02\x02\u03DD\u03DE\x07\x7F\x02\x02", "\u03DE\xCE\x03\x02\x02\x02\u03DF\u03E0\x07*\x02\x02", "\u03E0\xD0\x03\x02\x02\x02\u03E1\u03E2\x07+\x02\x02", "\u03E2\u03E3\x03\x02\x02\x02\u03E3\u03E4\bh\x05\x02\u03E4", "\xD2\x03\x02\x02\x02\u03E5\u03E6\x07k\x02\x02\u03E6", "\u03E7\x07p\x02\x02\u03E7\u03E8\x07r\x02\x02\u03E8\u03E9", "\x07w\x02\x02\u03E9\u03EA\x07v\x02\x02\u03EA\xD4\x03", "\x02\x02\x02\u03EB\u03EC\x07v\x02\x02\u03EC\u03ED\x07", "{\x02\x02\u03ED\u03EE\x07r\x02\x02\u03EE\u03EF\x07g\x02", "\x02\u03EF\xD6\x03\x02\x02\x02\u03F0\u03F1\x07g\x02", "\x02\u03F1\u03F2\x07p\x02\x02\u03F2\u03F3\x07w\x02\x02", "\u03F3\u03F4\x07o\x02\x02\u03F4\xD8\x03\x02\x02\x02", "\u03F5\u03F6\x07u\x02\x02\u03F6\u03F7\x07e\x02\x02\u03F7", "\u03F8\x07c\x02\x02\u03F8\u03F9\x07n\x02\x02\u03F9\u03FA", "\x07c\x02\x02\u03FA\u03FB\x07t\x02\x02\u03FB\xDA\x03", "\x02\x02\x02\u03FC\u03FD\x07k\x02\x02\u03FD\u03FE\x07", "p\x02\x02\u03FE\u03FF\x07v\x02\x02\u03FF\u0400\x07g\x02", "\x02\u0400\u0401\x07t\x02\x02\u0401\u0402\x07h\x02\x02", "\u0402\u0403\x07c\x02\x02\u0403\u0404\x07e\x02\x02\u0404", "\u0405\x07g\x02\x02\u0405\xDC\x03\x02\x02\x02\u0406", "\u0407\x07f\x02\x02\u0407\u0408\x07k\x02\x02\u0408\u0409", "\x07t\x02\x02\u0409\u040A\x07g\x02\x02\u040A\u040B\x07", "e\x02\x02\u040B\u040C\x07v\x02\x02\u040C\u040D\x07k\x02", "\x02\u040D\u040E\x07x\x02\x02\u040E\u040F\x07g\x02\x02", "\u040F\xDE\x03\x02\x02\x02\u0410\u0411\x07g\x02\x02", "\u0411\u0412\x07z\x02\x02\u0412\u0413\x07v\x02\x02\u0413", "\u0414\x07g\x02\x02\u0414\u0415\x07p\x02\x02\u0415\u0416", "\x07f\x02\x02\u0416\xE0\x03\x02\x02\x02\u0417\u0418", "\x07w\x02\x02\u0418\u0419\x07p\x02\x02\u0419\u041A\x07", "k\x02\x02\u041A\u041B\x07q\x02\x02\u041B\u041C\x07p\x02", "\x02\u041C\xE2\x03\x02\x02\x02\u041D\u041E\x07k\x02", "\x02\u041E\u041F\x07o\x02\x02\u041F\u0420\x07r\x02\x02", "\u0420\u0421\x07n\x02\x02\u0421\u0422\x07g\x02\x02\u0422", "\u0423\x07o\x02\x02\u0423\u0424\x07g\x02\x02\u0424\u0425", "\x07p\x02\x02\u0425\u0426\x07v\x02\x02\u0426\u0427\x07", "u\x02\x02\u0427\xE4\x03\x02\x02\x02\u0428\u0429\x07", "s\x02\x02\u0429\u042A\x07w\x02\x02\u042A\u042B\x07g\x02", "\x02\u042B\u042C\x07t\x02\x02\u042C\u042D\x07{\x02\x02", "\u042D\xE6\x03\x02\x02\x02\u042E\u042F\x07o\x02\x02", "\u042F\u0430\x07w\x02\x02\u0430\u0431\x07v\x02\x02\u0431", "\u0432\x07c\x02\x02\u0432\u0433\x07v\x02\x02\u0433\u0434", "\x07k\x02\x02\u0434\u0435\x07q\x02\x02\u0435\u0436\x07", "p\x02\x02\u0436\xE8\x03\x02\x02\x02\u0437\u0438\x07", "u\x02\x02\u0438\u0439\x07w\x02\x02\u0439\u043A\x07d\x02", "\x02\u043A\u043B\x07u\x02\x02\u043B\u043C\x07e\x02\x02", "\u043C\u043D\x07t\x02\x02\u043D\u043E\x07k\x02\x02\u043E", "\u043F\x07r\x02\x02\u043F\u0440\x07v\x02\x02\u0440\u0441", "\x07k\x02\x02\u0441\u0442\x07q\x02\x02\u0442\u0443\x07", "p\x02\x02\u0443\xEA\x03\x02\x02\x02\u0444\u0445\x07", "u\x02\x02\u0445\u0446\x07e\x02\x02\u0446\u0447\x07j\x02", "\x02\u0447\u0448\x07g\x02\x02\u0448\u0449\x07o\x02\x02", "\u0449\u044A\x07c\x02\x02\u044A\xEC\x03\x02\x02\x02", "\u044B\u044C\x07h\x02\x02\u044C\u044D\x07t\x02\x02\u044D", "\u044E\x07c\x02\x02\u044E\u044F\x07i\x02\x02\u044F\u0450", "\x07o\x02\x02\u0450\u0451\x07g\x02\x02\u0451\u0452\x07", "p\x02\x02\u0452\u0453\x07v\x02\x02\u0453\xEE\x03\x02", "\x02\x02\u0454\u0455\x07q\x02\x02\u0455\u0456\x07p\x02", "\x02\u0456\xF0\x03\x02\x02\x02\u0457\u0458\x07t\x02", "\x02\u0458\u0459\x07g\x02\x02\u0459\u045A\x07r\x02\x02", "\u045A\u045B\x07g\x02\x02\u045B\u045C\x07c\x02\x02\u045C", "\u045D\x07v\x02\x02\u045D\u045E\x07c\x02\x02\u045E\u045F", "\x07d\x02\x02\u045F\u0460\x07n\x02\x02\u0460\u0461\x07", "g\x02\x02\u0461\xF2\x03\x02\x02\x02\u0462\u0463\x07", ".\x02\x02\u0463\u0464\x03\x02\x02\x02\u0464\u0465\by\x04", "\x02\u0465\xF4\x03\x02\x02\x02\u0466\u046A\x07*\x02", "\x02\u0467\u0469\x05\xF7{\x02\u0468\u0467\x03\x02\x02", "\x02\u0469\u046C\x03\x02\x02\x02\u046A\u0468\x03\x02\x02", "\x02\u046A\u046B\x03\x02\x02\x02\u046B\u046D\x03\x02\x02", "\x02\u046C\u046A\x03\x02\x02\x02\u046D\u046E\x07+\x02", "\x02\u046E\u046F\x03\x02\x02\x02\u046F\u0470\bz\x05\x02", "\u0470\xF6\x03\x02\x02\x02\u0471\u0474\x05\xF9|\x02", "\u0472\u0474\n\x0E\x02\x02\u0473\u0471\x03\x02\x02\x02", "\u0473\u0472\x03\x02\x02\x02\u0474\xF8\x03\x02\x02\x02", "\u0475\u0478\x07^\x02\x02\u0476\u0479\t\x05\x02\x02\u0477", "\u0479\x05\xFB}\x02\u0478\u0476\x03\x02\x02\x02\u0478", "\u0477\x03\x02\x02\x02\u0479\xFA\x03\x02\x02\x02\u047A", "\u047B\x07w\x02\x02\u047B\u047C\x05\xFD~\x02\u047C\u047D", "\x05\xFD~\x02\u047D\u047E\x05\xFD~\x02\u047E\u047F\x05", "\xFD~\x02\u047F\xFC\x03\x02\x02\x02\u0480\u0481\t\x06", "\x02\x02\u0481\xFE\x03\x02\x02\x02\u0482\u0484\t\x0B", "\x02\x02\u0483\u0482\x03\x02\x02\x02\u0484\u0485\x03\x02", "\x02\x02\u0485\u0483\x03\x02\x02\x02\u0485\u0486\x03\x02", "\x02\x02\u0486\u0487\x03\x02\x02\x02\u0487\u0488\b\x7F", "\x04\x02\u0488\u0100\x03\x02\x02\x02\x1B\x02\x03\x04", "\u0320\u0327\u0333\u033C\u0341\u0355\u0358\u035C\u0362\u0365\u036F\u0373", "\u0378\u0383\u038F\u0397\u03CC\u03D4\u046A\u0473\u0478\u0485\x06\x07", "\x03\x02\x07\x04\x02\b\x02\x02\x06\x02\x02"].join("");
	var atn = new _antlr["default"].atn.ATNDeserializer().deserialize(serializedATN);
	var decisionsToDFA = atn.decisionToState.map(function (ds, index) {
	  return new _antlr["default"].dfa.DFA(ds, index);
	});

	var GraphQLFederationLexer = /*#__PURE__*/function (_antlr4$Lexer) {
	  _inherits(GraphQLFederationLexer, _antlr4$Lexer);

	  var _super = _createSuper(GraphQLFederationLexer);

	  function GraphQLFederationLexer(input) {
	    var _this;

	    _classCallCheck(this, GraphQLFederationLexer);

	    _this = _super.call(this, input);
	    _this._interp = new _antlr["default"].atn.LexerATNSimulator(_assertThisInitialized(_this), atn, decisionsToDFA, new _antlr["default"].PredictionContextCache());
	    return _this;
	  }

	  _createClass(GraphQLFederationLexer, [{
	    key: "atn",
	    get: function get() {
	      return atn;
	    }
	  }]);

	  return GraphQLFederationLexer;
	}(_antlr["default"].Lexer);

	exports["default"] = GraphQLFederationLexer;

	_defineProperty(GraphQLFederationLexer, "grammarFileName", "GraphQLFederationLexer.g4");

	_defineProperty(GraphQLFederationLexer, "channelNames", ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"]);

	_defineProperty(GraphQLFederationLexer, "modeNames", ["DEFAULT_MODE", "FederationMode", "LinkMode"]);

	_defineProperty(GraphQLFederationLexer, "literalNames", [null, "'@external'", "'@inaccessible'", "'@requires'", "'@provides'", "'@key'", "'@shareable'", "'@override'", "'@link'", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "'INPUT'", "'TYPE'", "'ENUM'", "'SCALAR'", "'INTERFACE'", "'DIRECTIVE'", "'EXTEND'", "'UNION'", "'IMPLEMENTS'", "'QUERY'", "'MUTATION'", "'SUBSCRIPTION'", "'SCHEMA'", "'FRAGMENT'", "'FIELD'", "'FRAGMENT_DEFINITION'", "'FRAGMENT_SPREAD'", "'INLINE_FRAGMENT'", "'VARIABLE_DEFINITION'", "'OBJECT'", "'FIELD_DEFINITION'", "'ARGUMENT_DEFINITION'", "'ENUM_VALUE'", "'INPUT_OBJECT'", "'INPUT_FIELD_DEFINITION'", null, null, "'['", "']'", null, null, "'@'", "'&'", "'='", null, "'...'", "'!'", "'|'", "'$'", null, null, null, "'null'", null, null, null, null, null, null, null, null, null, "'\uEFBBBF'", "'\uFEFF'", "'\0FEFF'", "'fields'", "'from'", "'resolvable'"]);

	_defineProperty(GraphQLFederationLexer, "symbolicNames", [null, "EXTERNAL", "INACCESSIBLE", "REQUIRES", "PROVIDES", "KEY", "SHAREABLE", "OVERRIDE", "LINK", "INPUT_KEYWORD", "TYPE_KEYWORD", "ENUM_KEYWORD", "SCALAR_KEYWORD", "INTERFACE_KEYWORD", "DIRECTIVE_KEYWORD", "EXTEND_KEYWORD", "UNION_KEYWORD", "IMPLEMENTS_KEYWORD", "QUERY_KEYWORD", "MUTATION_KEYWORD", "SUBSCRIPTION_KEYWORD", "SCHEMA_KEYWORD", "FRAGMENT_KEYWORD", "ON_KEYWORD", "REPEATABLE_KEYWORD", "INPUT_LOCATION", "TYPE_LOCATION", "ENUM_LOCATION", "SCALAR_LOCATION", "INTERFACE_LOCATION", "DIRECTIVE_LOCATION", "EXTEND_LOCATION", "UNION_LOCATION", "IMPLEMENTS_LOCATION", "QUERY_LOCATION", "MUTATION_LOCATION", "SUBSCRIPTION_LOCATION", "SCHEMA_LOCATION", "FRAGMENT_LOCATION", "FIELD_LOCATION", "FRAGMENT_DEFINITION_LOCATION", "FRAGMENT_SPREAD_LOCATION", "INLINE_FRAGMENT_LOCATION", "VARIABLE_DEFINITION_LOCATION", "OBJECT_LOCATION", "FIELD_DEFINITION_LOCATION", "ARGUMENT_DEFINITION_LOCATION", "ENUM_VALUE_LOCATION", "INPUT_OBJECT_LOCATION", "INPUT_FIELD_DEFINITION_LOCATION", "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "LPAREN", "RPAREN", "AT", "AMP", "EQ", "COLON", "ELLIPSIS", "EXCL", "VSLASH", "DOLLAR", "DQUOTE", "TRUE", "FALSE", "NULL", "NAME", "STRING", "BLOCK_STRING", "FLOAT", "INT", "WS", "COMMA", "LineComment", "UNICODE_BOM", "UTF8_BOM", "UTF16_BOM", "UTF32_BOM", "FIELDS_KEYWORD", "FROM_KEYWORD", "RESOLVABLE_KEYWORD", "TRUE_F", "FALSE_F", "WS_F", "NAME_F", "DQUOTE_F", "COLON_F", "LBRACE_F", "RBRACE_F", "LPAREN_F", "RPAREN_F", "INPUT_KEYWORD_F", "TYPE_KEYWORD_F", "ENUM_KEYWORD_F", "SCALAR_KEYWORD_F", "INTERFACE_KEYWORD_F", "DIRECTIVE_KEYWORD_F", "EXTEND_KEYWORD_F", "UNION_KEYWORD_F", "IMPLEMENTS_KEYWORD_F", "QUERY_KEYWORD_F", "MUTATION_KEYWORD_F", "SUBSCRIPTION_KEYWORD_F", "SCHEMA_KEYWORD_F", "FRAGMENT_KEYWORD_F", "ON_KEYWORD_F", "REPEATABLE_KEYWORD_F", "COMMA_F", "STRING_LINK", "WS_LINK"]);

	_defineProperty(GraphQLFederationLexer, "ruleNames", ["EXTERNAL", "INACCESSIBLE", "REQUIRES", "PROVIDES", "KEY", "SHAREABLE", "OVERRIDE", "LINK", "INPUT_KEYWORD", "TYPE_KEYWORD", "ENUM_KEYWORD", "SCALAR_KEYWORD", "INTERFACE_KEYWORD", "DIRECTIVE_KEYWORD", "EXTEND_KEYWORD", "UNION_KEYWORD", "IMPLEMENTS_KEYWORD", "QUERY_KEYWORD", "MUTATION_KEYWORD", "SUBSCRIPTION_KEYWORD", "SCHEMA_KEYWORD", "FRAGMENT_KEYWORD", "ON_KEYWORD", "REPEATABLE_KEYWORD", "INPUT_LOCATION", "TYPE_LOCATION", "ENUM_LOCATION", "SCALAR_LOCATION", "INTERFACE_LOCATION", "DIRECTIVE_LOCATION", "EXTEND_LOCATION", "UNION_LOCATION", "IMPLEMENTS_LOCATION", "QUERY_LOCATION", "MUTATION_LOCATION", "SUBSCRIPTION_LOCATION", "SCHEMA_LOCATION", "FRAGMENT_LOCATION", "FIELD_LOCATION", "FRAGMENT_DEFINITION_LOCATION", "FRAGMENT_SPREAD_LOCATION", "INLINE_FRAGMENT_LOCATION", "VARIABLE_DEFINITION_LOCATION", "OBJECT_LOCATION", "FIELD_DEFINITION_LOCATION", "ARGUMENT_DEFINITION_LOCATION", "ENUM_VALUE_LOCATION", "INPUT_OBJECT_LOCATION", "INPUT_FIELD_DEFINITION_LOCATION", "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "LPAREN", "RPAREN", "AT", "AMP", "EQ", "COLON", "ELLIPSIS", "EXCL", "VSLASH", "DOLLAR", "DQUOTE", "TRUE", "FALSE", "NULL", "NAME", "STRING", "BLOCK_STRING", "CHARACTER", "ESC", "UNICODE", "HEX", "FLOAT", "INT", "NONZERO_DIGIT", "DIGIT", "FRACTIONAL_PART", "EXPONENTIAL_PART", "EXPONENT_INDICATOR", "SIGN", "NEGATIVE_SIGN", "WS", "COMMA", "LineComment", "UNICODE_BOM", "UTF8_BOM", "UTF16_BOM", "UTF32_BOM", "FIELDS_KEYWORD", "FROM_KEYWORD", "RESOLVABLE_KEYWORD", "TRUE_F", "FALSE_F", "WS_F", "NAME_F", "DQUOTE_F", "COLON_F", "LBRACE_F", "RBRACE_F", "LPAREN_F", "RPAREN_F", "INPUT_KEYWORD_F", "TYPE_KEYWORD_F", "ENUM_KEYWORD_F", "SCALAR_KEYWORD_F", "INTERFACE_KEYWORD_F", "DIRECTIVE_KEYWORD_F", "EXTEND_KEYWORD_F", "UNION_KEYWORD_F", "IMPLEMENTS_KEYWORD_F", "QUERY_KEYWORD_F", "MUTATION_KEYWORD_F", "SUBSCRIPTION_KEYWORD_F", "SCHEMA_KEYWORD_F", "FRAGMENT_KEYWORD_F", "ON_KEYWORD_F", "REPEATABLE_KEYWORD_F", "COMMA_F", "STRING_LINK", "CHARACTER_LINK", "ESC_LINK", "UNICODE_LINK", "HEX_LINK", "WS_LINK"]);

	GraphQLFederationLexer.EOF = _antlr["default"].Token.EOF;
	GraphQLFederationLexer.EXTERNAL = 1;
	GraphQLFederationLexer.INACCESSIBLE = 2;
	GraphQLFederationLexer.REQUIRES = 3;
	GraphQLFederationLexer.PROVIDES = 4;
	GraphQLFederationLexer.KEY = 5;
	GraphQLFederationLexer.SHAREABLE = 6;
	GraphQLFederationLexer.OVERRIDE = 7;
	GraphQLFederationLexer.LINK = 8;
	GraphQLFederationLexer.INPUT_KEYWORD = 9;
	GraphQLFederationLexer.TYPE_KEYWORD = 10;
	GraphQLFederationLexer.ENUM_KEYWORD = 11;
	GraphQLFederationLexer.SCALAR_KEYWORD = 12;
	GraphQLFederationLexer.INTERFACE_KEYWORD = 13;
	GraphQLFederationLexer.DIRECTIVE_KEYWORD = 14;
	GraphQLFederationLexer.EXTEND_KEYWORD = 15;
	GraphQLFederationLexer.UNION_KEYWORD = 16;
	GraphQLFederationLexer.IMPLEMENTS_KEYWORD = 17;
	GraphQLFederationLexer.QUERY_KEYWORD = 18;
	GraphQLFederationLexer.MUTATION_KEYWORD = 19;
	GraphQLFederationLexer.SUBSCRIPTION_KEYWORD = 20;
	GraphQLFederationLexer.SCHEMA_KEYWORD = 21;
	GraphQLFederationLexer.FRAGMENT_KEYWORD = 22;
	GraphQLFederationLexer.ON_KEYWORD = 23;
	GraphQLFederationLexer.REPEATABLE_KEYWORD = 24;
	GraphQLFederationLexer.INPUT_LOCATION = 25;
	GraphQLFederationLexer.TYPE_LOCATION = 26;
	GraphQLFederationLexer.ENUM_LOCATION = 27;
	GraphQLFederationLexer.SCALAR_LOCATION = 28;
	GraphQLFederationLexer.INTERFACE_LOCATION = 29;
	GraphQLFederationLexer.DIRECTIVE_LOCATION = 30;
	GraphQLFederationLexer.EXTEND_LOCATION = 31;
	GraphQLFederationLexer.UNION_LOCATION = 32;
	GraphQLFederationLexer.IMPLEMENTS_LOCATION = 33;
	GraphQLFederationLexer.QUERY_LOCATION = 34;
	GraphQLFederationLexer.MUTATION_LOCATION = 35;
	GraphQLFederationLexer.SUBSCRIPTION_LOCATION = 36;
	GraphQLFederationLexer.SCHEMA_LOCATION = 37;
	GraphQLFederationLexer.FRAGMENT_LOCATION = 38;
	GraphQLFederationLexer.FIELD_LOCATION = 39;
	GraphQLFederationLexer.FRAGMENT_DEFINITION_LOCATION = 40;
	GraphQLFederationLexer.FRAGMENT_SPREAD_LOCATION = 41;
	GraphQLFederationLexer.INLINE_FRAGMENT_LOCATION = 42;
	GraphQLFederationLexer.VARIABLE_DEFINITION_LOCATION = 43;
	GraphQLFederationLexer.OBJECT_LOCATION = 44;
	GraphQLFederationLexer.FIELD_DEFINITION_LOCATION = 45;
	GraphQLFederationLexer.ARGUMENT_DEFINITION_LOCATION = 46;
	GraphQLFederationLexer.ENUM_VALUE_LOCATION = 47;
	GraphQLFederationLexer.INPUT_OBJECT_LOCATION = 48;
	GraphQLFederationLexer.INPUT_FIELD_DEFINITION_LOCATION = 49;
	GraphQLFederationLexer.LBRACE = 50;
	GraphQLFederationLexer.RBRACE = 51;
	GraphQLFederationLexer.LBRACKET = 52;
	GraphQLFederationLexer.RBRACKET = 53;
	GraphQLFederationLexer.LPAREN = 54;
	GraphQLFederationLexer.RPAREN = 55;
	GraphQLFederationLexer.AT = 56;
	GraphQLFederationLexer.AMP = 57;
	GraphQLFederationLexer.EQ = 58;
	GraphQLFederationLexer.COLON = 59;
	GraphQLFederationLexer.ELLIPSIS = 60;
	GraphQLFederationLexer.EXCL = 61;
	GraphQLFederationLexer.VSLASH = 62;
	GraphQLFederationLexer.DOLLAR = 63;
	GraphQLFederationLexer.DQUOTE = 64;
	GraphQLFederationLexer.TRUE = 65;
	GraphQLFederationLexer.FALSE = 66;
	GraphQLFederationLexer.NULL = 67;
	GraphQLFederationLexer.NAME = 68;
	GraphQLFederationLexer.STRING = 69;
	GraphQLFederationLexer.BLOCK_STRING = 70;
	GraphQLFederationLexer.FLOAT = 71;
	GraphQLFederationLexer.INT = 72;
	GraphQLFederationLexer.WS = 73;
	GraphQLFederationLexer.COMMA = 74;
	GraphQLFederationLexer.LineComment = 75;
	GraphQLFederationLexer.UNICODE_BOM = 76;
	GraphQLFederationLexer.UTF8_BOM = 77;
	GraphQLFederationLexer.UTF16_BOM = 78;
	GraphQLFederationLexer.UTF32_BOM = 79;
	GraphQLFederationLexer.FIELDS_KEYWORD = 80;
	GraphQLFederationLexer.FROM_KEYWORD = 81;
	GraphQLFederationLexer.RESOLVABLE_KEYWORD = 82;
	GraphQLFederationLexer.TRUE_F = 83;
	GraphQLFederationLexer.FALSE_F = 84;
	GraphQLFederationLexer.WS_F = 85;
	GraphQLFederationLexer.NAME_F = 86;
	GraphQLFederationLexer.DQUOTE_F = 87;
	GraphQLFederationLexer.COLON_F = 88;
	GraphQLFederationLexer.LBRACE_F = 89;
	GraphQLFederationLexer.RBRACE_F = 90;
	GraphQLFederationLexer.LPAREN_F = 91;
	GraphQLFederationLexer.RPAREN_F = 92;
	GraphQLFederationLexer.INPUT_KEYWORD_F = 93;
	GraphQLFederationLexer.TYPE_KEYWORD_F = 94;
	GraphQLFederationLexer.ENUM_KEYWORD_F = 95;
	GraphQLFederationLexer.SCALAR_KEYWORD_F = 96;
	GraphQLFederationLexer.INTERFACE_KEYWORD_F = 97;
	GraphQLFederationLexer.DIRECTIVE_KEYWORD_F = 98;
	GraphQLFederationLexer.EXTEND_KEYWORD_F = 99;
	GraphQLFederationLexer.UNION_KEYWORD_F = 100;
	GraphQLFederationLexer.IMPLEMENTS_KEYWORD_F = 101;
	GraphQLFederationLexer.QUERY_KEYWORD_F = 102;
	GraphQLFederationLexer.MUTATION_KEYWORD_F = 103;
	GraphQLFederationLexer.SUBSCRIPTION_KEYWORD_F = 104;
	GraphQLFederationLexer.SCHEMA_KEYWORD_F = 105;
	GraphQLFederationLexer.FRAGMENT_KEYWORD_F = 106;
	GraphQLFederationLexer.ON_KEYWORD_F = 107;
	GraphQLFederationLexer.REPEATABLE_KEYWORD_F = 108;
	GraphQLFederationLexer.COMMA_F = 109;
	GraphQLFederationLexer.STRING_LINK = 110;
	GraphQLFederationLexer.WS_LINK = 111;
	GraphQLFederationLexer.FederationMode = 1;
	GraphQLFederationLexer.LinkMode = 2;
} (GraphQLFederationLexer));

var GraphqlFederationLexer = /*@__PURE__*/getDefaultExportFromCjs(GraphQLFederationLexer);

var GraphQLFederationParser = {};

var GraphQLFederationParserListener = {};

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// This class defines a complete listener for a parse tree produced by GraphQLFederationParser.
	var GraphQLFederationParserListener = /*#__PURE__*/function (_antlr4$tree$ParseTre) {
	  _inherits(GraphQLFederationParserListener, _antlr4$tree$ParseTre);

	  var _super = _createSuper(GraphQLFederationParserListener);

	  function GraphQLFederationParserListener() {
	    _classCallCheck(this, GraphQLFederationParserListener);

	    return _super.apply(this, arguments);
	  }

	  _createClass(GraphQLFederationParserListener, [{
	    key: "enterDocument",
	    value: // Enter a parse tree produced by GraphQLFederationParser#document.
	    function enterDocument(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#document.

	  }, {
	    key: "exitDocument",
	    value: function exitDocument(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#definition.

	  }, {
	    key: "enterDefinition",
	    value: function enterDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#definition.

	  }, {
	    key: "exitDefinition",
	    value: function exitDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#executableDefinition.

	  }, {
	    key: "enterExecutableDefinition",
	    value: function enterExecutableDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#executableDefinition.

	  }, {
	    key: "exitExecutableDefinition",
	    value: function exitExecutableDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#operationDefinition.

	  }, {
	    key: "enterOperationDefinition",
	    value: function enterOperationDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#operationDefinition.

	  }, {
	    key: "exitOperationDefinition",
	    value: function exitOperationDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#operationType.

	  }, {
	    key: "enterOperationType",
	    value: function enterOperationType(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#operationType.

	  }, {
	    key: "exitOperationType",
	    value: function exitOperationType(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#selectionSet.

	  }, {
	    key: "enterSelectionSet",
	    value: function enterSelectionSet(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#selectionSet.

	  }, {
	    key: "exitSelectionSet",
	    value: function exitSelectionSet(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#selection.

	  }, {
	    key: "enterSelection",
	    value: function enterSelection(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#selection.

	  }, {
	    key: "exitSelection",
	    value: function exitSelection(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#field.

	  }, {
	    key: "enterField",
	    value: function enterField(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#field.

	  }, {
	    key: "exitField",
	    value: function exitField(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#arguments.

	  }, {
	    key: "enterArguments",
	    value: function enterArguments(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#arguments.

	  }, {
	    key: "exitArguments",
	    value: function exitArguments(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#argument.

	  }, {
	    key: "enterArgument",
	    value: function enterArgument(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#argument.

	  }, {
	    key: "exitArgument",
	    value: function exitArgument(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#alias.

	  }, {
	    key: "enterAlias",
	    value: function enterAlias(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#alias.

	  }, {
	    key: "exitAlias",
	    value: function exitAlias(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fragmentSpread.

	  }, {
	    key: "enterFragmentSpread",
	    value: function enterFragmentSpread(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fragmentSpread.

	  }, {
	    key: "exitFragmentSpread",
	    value: function exitFragmentSpread(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fragmentDefinition.

	  }, {
	    key: "enterFragmentDefinition",
	    value: function enterFragmentDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fragmentDefinition.

	  }, {
	    key: "exitFragmentDefinition",
	    value: function exitFragmentDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fragmentName.

	  }, {
	    key: "enterFragmentName",
	    value: function enterFragmentName(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fragmentName.

	  }, {
	    key: "exitFragmentName",
	    value: function exitFragmentName(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeCondition.

	  }, {
	    key: "enterTypeCondition",
	    value: function enterTypeCondition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeCondition.

	  }, {
	    key: "exitTypeCondition",
	    value: function exitTypeCondition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inlineFragment.

	  }, {
	    key: "enterInlineFragment",
	    value: function enterInlineFragment(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inlineFragment.

	  }, {
	    key: "exitInlineFragment",
	    value: function exitInlineFragment(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#value.

	  }, {
	    key: "enterValue",
	    value: function enterValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#value.

	  }, {
	    key: "exitValue",
	    value: function exitValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#intValue.

	  }, {
	    key: "enterIntValue",
	    value: function enterIntValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#intValue.

	  }, {
	    key: "exitIntValue",
	    value: function exitIntValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#floatValue.

	  }, {
	    key: "enterFloatValue",
	    value: function enterFloatValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#floatValue.

	  }, {
	    key: "exitFloatValue",
	    value: function exitFloatValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#booleanValue.

	  }, {
	    key: "enterBooleanValue",
	    value: function enterBooleanValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#booleanValue.

	  }, {
	    key: "exitBooleanValue",
	    value: function exitBooleanValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#stringValue.

	  }, {
	    key: "enterStringValue",
	    value: function enterStringValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#stringValue.

	  }, {
	    key: "exitStringValue",
	    value: function exitStringValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#nullValue.

	  }, {
	    key: "enterNullValue",
	    value: function enterNullValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#nullValue.

	  }, {
	    key: "exitNullValue",
	    value: function exitNullValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumValue.

	  }, {
	    key: "enterEnumValue",
	    value: function enterEnumValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumValue.

	  }, {
	    key: "exitEnumValue",
	    value: function exitEnumValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#listValue.

	  }, {
	    key: "enterListValue",
	    value: function enterListValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#listValue.

	  }, {
	    key: "exitListValue",
	    value: function exitListValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectValue.

	  }, {
	    key: "enterObjectValue",
	    value: function enterObjectValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectValue.

	  }, {
	    key: "exitObjectValue",
	    value: function exitObjectValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectField.

	  }, {
	    key: "enterObjectField",
	    value: function enterObjectField(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectField.

	  }, {
	    key: "exitObjectField",
	    value: function exitObjectField(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#variable.

	  }, {
	    key: "enterVariable",
	    value: function enterVariable(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#variable.

	  }, {
	    key: "exitVariable",
	    value: function exitVariable(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#variableDefinitions.

	  }, {
	    key: "enterVariableDefinitions",
	    value: function enterVariableDefinitions(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#variableDefinitions.

	  }, {
	    key: "exitVariableDefinitions",
	    value: function exitVariableDefinitions(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#variableDefinition.

	  }, {
	    key: "enterVariableDefinition",
	    value: function enterVariableDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#variableDefinition.

	  }, {
	    key: "exitVariableDefinition",
	    value: function exitVariableDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#defaultValue.

	  }, {
	    key: "enterDefaultValue",
	    value: function enterDefaultValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#defaultValue.

	  }, {
	    key: "exitDefaultValue",
	    value: function exitDefaultValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#type_.

	  }, {
	    key: "enterType_",
	    value: function enterType_(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#type_.

	  }, {
	    key: "exitType_",
	    value: function exitType_(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#namedType.

	  }, {
	    key: "enterNamedType",
	    value: function enterNamedType(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#namedType.

	  }, {
	    key: "exitNamedType",
	    value: function exitNamedType(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#listType.

	  }, {
	    key: "enterListType",
	    value: function enterListType(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#listType.

	  }, {
	    key: "exitListType",
	    value: function exitListType(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directives.

	  }, {
	    key: "enterDirectives",
	    value: function enterDirectives(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directives.

	  }, {
	    key: "exitDirectives",
	    value: function exitDirectives(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directive.

	  }, {
	    key: "enterDirective",
	    value: function enterDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directive.

	  }, {
	    key: "exitDirective",
	    value: function exitDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeSystemDefinition.

	  }, {
	    key: "enterTypeSystemDefinition",
	    value: function enterTypeSystemDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeSystemDefinition.

	  }, {
	    key: "exitTypeSystemDefinition",
	    value: function exitTypeSystemDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeSystemExtension.

	  }, {
	    key: "enterTypeSystemExtension",
	    value: function enterTypeSystemExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeSystemExtension.

	  }, {
	    key: "exitTypeSystemExtension",
	    value: function exitTypeSystemExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#schemaDefinition.

	  }, {
	    key: "enterSchemaDefinition",
	    value: function enterSchemaDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#schemaDefinition.

	  }, {
	    key: "exitSchemaDefinition",
	    value: function exitSchemaDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#rootOperationTypeDefinition.

	  }, {
	    key: "enterRootOperationTypeDefinition",
	    value: function enterRootOperationTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#rootOperationTypeDefinition.

	  }, {
	    key: "exitRootOperationTypeDefinition",
	    value: function exitRootOperationTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#schemaExtension.

	  }, {
	    key: "enterSchemaExtension",
	    value: function enterSchemaExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#schemaExtension.

	  }, {
	    key: "exitSchemaExtension",
	    value: function exitSchemaExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#operationTypeDefinition.

	  }, {
	    key: "enterOperationTypeDefinition",
	    value: function enterOperationTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#operationTypeDefinition.

	  }, {
	    key: "exitOperationTypeDefinition",
	    value: function exitOperationTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#description.

	  }, {
	    key: "enterDescription",
	    value: function enterDescription(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#description.

	  }, {
	    key: "exitDescription",
	    value: function exitDescription(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeDefinition.

	  }, {
	    key: "enterTypeDefinition",
	    value: function enterTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeDefinition.

	  }, {
	    key: "exitTypeDefinition",
	    value: function exitTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeExtension.

	  }, {
	    key: "enterTypeExtension",
	    value: function enterTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeExtension.

	  }, {
	    key: "exitTypeExtension",
	    value: function exitTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#scalarTypeDefinition.

	  }, {
	    key: "enterScalarTypeDefinition",
	    value: function enterScalarTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#scalarTypeDefinition.

	  }, {
	    key: "exitScalarTypeDefinition",
	    value: function exitScalarTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#scalarTypeExtension.

	  }, {
	    key: "enterScalarTypeExtension",
	    value: function enterScalarTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#scalarTypeExtension.

	  }, {
	    key: "exitScalarTypeExtension",
	    value: function exitScalarTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectTypeDefinition.

	  }, {
	    key: "enterObjectTypeDefinition",
	    value: function enterObjectTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectTypeDefinition.

	  }, {
	    key: "exitObjectTypeDefinition",
	    value: function exitObjectTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#implementsInterfaces.

	  }, {
	    key: "enterImplementsInterfaces",
	    value: function enterImplementsInterfaces(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#implementsInterfaces.

	  }, {
	    key: "exitImplementsInterfaces",
	    value: function exitImplementsInterfaces(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldsDefinition.

	  }, {
	    key: "enterFieldsDefinition",
	    value: function enterFieldsDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldsDefinition.

	  }, {
	    key: "exitFieldsDefinition",
	    value: function exitFieldsDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldDefinition.

	  }, {
	    key: "enterFieldDefinition",
	    value: function enterFieldDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldDefinition.

	  }, {
	    key: "exitFieldDefinition",
	    value: function exitFieldDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#argumentsDefinition.

	  }, {
	    key: "enterArgumentsDefinition",
	    value: function enterArgumentsDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#argumentsDefinition.

	  }, {
	    key: "exitArgumentsDefinition",
	    value: function exitArgumentsDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputValueDefinition.

	  }, {
	    key: "enterInputValueDefinition",
	    value: function enterInputValueDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputValueDefinition.

	  }, {
	    key: "exitInputValueDefinition",
	    value: function exitInputValueDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectTypeExtension.

	  }, {
	    key: "enterObjectTypeExtension",
	    value: function enterObjectTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectTypeExtension.

	  }, {
	    key: "exitObjectTypeExtension",
	    value: function exitObjectTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#interfaceTypeDefinition.

	  }, {
	    key: "enterInterfaceTypeDefinition",
	    value: function enterInterfaceTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#interfaceTypeDefinition.

	  }, {
	    key: "exitInterfaceTypeDefinition",
	    value: function exitInterfaceTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#interfaceTypeExtension.

	  }, {
	    key: "enterInterfaceTypeExtension",
	    value: function enterInterfaceTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#interfaceTypeExtension.

	  }, {
	    key: "exitInterfaceTypeExtension",
	    value: function exitInterfaceTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#unionTypeDefinition.

	  }, {
	    key: "enterUnionTypeDefinition",
	    value: function enterUnionTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#unionTypeDefinition.

	  }, {
	    key: "exitUnionTypeDefinition",
	    value: function exitUnionTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#unionMemberTypes.

	  }, {
	    key: "enterUnionMemberTypes",
	    value: function enterUnionMemberTypes(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#unionMemberTypes.

	  }, {
	    key: "exitUnionMemberTypes",
	    value: function exitUnionMemberTypes(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#unionTypeExtension.

	  }, {
	    key: "enterUnionTypeExtension",
	    value: function enterUnionTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#unionTypeExtension.

	  }, {
	    key: "exitUnionTypeExtension",
	    value: function exitUnionTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumTypeDefinition.

	  }, {
	    key: "enterEnumTypeDefinition",
	    value: function enterEnumTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumTypeDefinition.

	  }, {
	    key: "exitEnumTypeDefinition",
	    value: function exitEnumTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumValuesDefinition.

	  }, {
	    key: "enterEnumValuesDefinition",
	    value: function enterEnumValuesDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumValuesDefinition.

	  }, {
	    key: "exitEnumValuesDefinition",
	    value: function exitEnumValuesDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumValueDefinition.

	  }, {
	    key: "enterEnumValueDefinition",
	    value: function enterEnumValueDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumValueDefinition.

	  }, {
	    key: "exitEnumValueDefinition",
	    value: function exitEnumValueDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumTypeExtension.

	  }, {
	    key: "enterEnumTypeExtension",
	    value: function enterEnumTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumTypeExtension.

	  }, {
	    key: "exitEnumTypeExtension",
	    value: function exitEnumTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputObjectTypeDefinition.

	  }, {
	    key: "enterInputObjectTypeDefinition",
	    value: function enterInputObjectTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputObjectTypeDefinition.

	  }, {
	    key: "exitInputObjectTypeDefinition",
	    value: function exitInputObjectTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputFieldsDefinition.

	  }, {
	    key: "enterInputFieldsDefinition",
	    value: function enterInputFieldsDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputFieldsDefinition.

	  }, {
	    key: "exitInputFieldsDefinition",
	    value: function exitInputFieldsDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputObjectTypeExtension.

	  }, {
	    key: "enterInputObjectTypeExtension",
	    value: function enterInputObjectTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputObjectTypeExtension.

	  }, {
	    key: "exitInputObjectTypeExtension",
	    value: function exitInputObjectTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directiveDefinition.

	  }, {
	    key: "enterDirectiveDefinition",
	    value: function enterDirectiveDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directiveDefinition.

	  }, {
	    key: "exitDirectiveDefinition",
	    value: function exitDirectiveDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directiveLocations.

	  }, {
	    key: "enterDirectiveLocations",
	    value: function enterDirectiveLocations(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directiveLocations.

	  }, {
	    key: "exitDirectiveLocations",
	    value: function exitDirectiveLocations(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directiveLocation.

	  }, {
	    key: "enterDirectiveLocation",
	    value: function enterDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directiveLocation.

	  }, {
	    key: "exitDirectiveLocation",
	    value: function exitDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#executableDirectiveLocation.

	  }, {
	    key: "enterExecutableDirectiveLocation",
	    value: function enterExecutableDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#executableDirectiveLocation.

	  }, {
	    key: "exitExecutableDirectiveLocation",
	    value: function exitExecutableDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeSystemDirectiveLocation.

	  }, {
	    key: "enterTypeSystemDirectiveLocation",
	    value: function enterTypeSystemDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeSystemDirectiveLocation.

	  }, {
	    key: "exitTypeSystemDirectiveLocation",
	    value: function exitTypeSystemDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#externalDirective.

	  }, {
	    key: "enterExternalDirective",
	    value: function enterExternalDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#externalDirective.

	  }, {
	    key: "exitExternalDirective",
	    value: function exitExternalDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inaccessibleDirective.

	  }, {
	    key: "enterInaccessibleDirective",
	    value: function enterInaccessibleDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inaccessibleDirective.

	  }, {
	    key: "exitInaccessibleDirective",
	    value: function exitInaccessibleDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#requiresDirective.

	  }, {
	    key: "enterRequiresDirective",
	    value: function enterRequiresDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#requiresDirective.

	  }, {
	    key: "exitRequiresDirective",
	    value: function exitRequiresDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#providesDirective.

	  }, {
	    key: "enterProvidesDirective",
	    value: function enterProvidesDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#providesDirective.

	  }, {
	    key: "exitProvidesDirective",
	    value: function exitProvidesDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#keyDirective.

	  }, {
	    key: "enterKeyDirective",
	    value: function enterKeyDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#keyDirective.

	  }, {
	    key: "exitKeyDirective",
	    value: function exitKeyDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#shareableDirective.

	  }, {
	    key: "enterShareableDirective",
	    value: function enterShareableDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#shareableDirective.

	  }, {
	    key: "exitShareableDirective",
	    value: function exitShareableDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#overrideDirective.

	  }, {
	    key: "enterOverrideDirective",
	    value: function enterOverrideDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#overrideDirective.

	  }, {
	    key: "exitOverrideDirective",
	    value: function exitOverrideDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#linkDirective.

	  }, {
	    key: "enterLinkDirective",
	    value: function enterLinkDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#linkDirective.

	  }, {
	    key: "exitLinkDirective",
	    value: function exitLinkDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldSet.

	  }, {
	    key: "enterFieldSet",
	    value: function enterFieldSet(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldSet.

	  }, {
	    key: "exitFieldSet",
	    value: function exitFieldSet(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldSetComponent.

	  }, {
	    key: "enterFieldSetComponent",
	    value: function enterFieldSetComponent(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldSetComponent.

	  }, {
	    key: "exitFieldSetComponent",
	    value: function exitFieldSetComponent(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#nestedFieldSet.

	  }, {
	    key: "enterNestedFieldSet",
	    value: function enterNestedFieldSet(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#nestedFieldSet.

	  }, {
	    key: "exitNestedFieldSet",
	    value: function exitNestedFieldSet(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#schemaDirective.

	  }, {
	    key: "enterSchemaDirective",
	    value: function enterSchemaDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#schemaDirective.

	  }, {
	    key: "exitSchemaDirective",
	    value: function exitSchemaDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#schemaFederationDirective.

	  }, {
	    key: "enterSchemaFederationDirective",
	    value: function enterSchemaFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#schemaFederationDirective.

	  }, {
	    key: "exitSchemaFederationDirective",
	    value: function exitSchemaFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#scalarDirective.

	  }, {
	    key: "enterScalarDirective",
	    value: function enterScalarDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#scalarDirective.

	  }, {
	    key: "exitScalarDirective",
	    value: function exitScalarDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#scalarFederationDirective.

	  }, {
	    key: "enterScalarFederationDirective",
	    value: function enterScalarFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#scalarFederationDirective.

	  }, {
	    key: "exitScalarFederationDirective",
	    value: function exitScalarFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectDirective.

	  }, {
	    key: "enterObjectDirective",
	    value: function enterObjectDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectDirective.

	  }, {
	    key: "exitObjectDirective",
	    value: function exitObjectDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectFederationDirective.

	  }, {
	    key: "enterObjectFederationDirective",
	    value: function enterObjectFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectFederationDirective.

	  }, {
	    key: "exitObjectFederationDirective",
	    value: function exitObjectFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#interfaceDirective.

	  }, {
	    key: "enterInterfaceDirective",
	    value: function enterInterfaceDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#interfaceDirective.

	  }, {
	    key: "exitInterfaceDirective",
	    value: function exitInterfaceDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#interfaceFederationDirective.

	  }, {
	    key: "enterInterfaceFederationDirective",
	    value: function enterInterfaceFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#interfaceFederationDirective.

	  }, {
	    key: "exitInterfaceFederationDirective",
	    value: function exitInterfaceFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#unionDirective.

	  }, {
	    key: "enterUnionDirective",
	    value: function enterUnionDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#unionDirective.

	  }, {
	    key: "exitUnionDirective",
	    value: function exitUnionDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#unionFederationDirective.

	  }, {
	    key: "enterUnionFederationDirective",
	    value: function enterUnionFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#unionFederationDirective.

	  }, {
	    key: "exitUnionFederationDirective",
	    value: function exitUnionFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumDirective.

	  }, {
	    key: "enterEnumDirective",
	    value: function enterEnumDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumDirective.

	  }, {
	    key: "exitEnumDirective",
	    value: function exitEnumDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumFederationDirective.

	  }, {
	    key: "enterEnumFederationDirective",
	    value: function enterEnumFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumFederationDirective.

	  }, {
	    key: "exitEnumFederationDirective",
	    value: function exitEnumFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputObjectDirective.

	  }, {
	    key: "enterInputObjectDirective",
	    value: function enterInputObjectDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputObjectDirective.

	  }, {
	    key: "exitInputObjectDirective",
	    value: function exitInputObjectDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputObjectFederationDirective.

	  }, {
	    key: "enterInputObjectFederationDirective",
	    value: function enterInputObjectFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputObjectFederationDirective.

	  }, {
	    key: "exitInputObjectFederationDirective",
	    value: function exitInputObjectFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputValueDirective.

	  }, {
	    key: "enterInputValueDirective",
	    value: function enterInputValueDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputValueDirective.

	  }, {
	    key: "exitInputValueDirective",
	    value: function exitInputValueDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputFieldFederationDirective.

	  }, {
	    key: "enterInputFieldFederationDirective",
	    value: function enterInputFieldFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputFieldFederationDirective.

	  }, {
	    key: "exitInputFieldFederationDirective",
	    value: function exitInputFieldFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldDirective.

	  }, {
	    key: "enterFieldDirective",
	    value: function enterFieldDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldDirective.

	  }, {
	    key: "exitFieldDirective",
	    value: function exitFieldDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldFederationDirective.

	  }, {
	    key: "enterFieldFederationDirective",
	    value: function enterFieldFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldFederationDirective.

	  }, {
	    key: "exitFieldFederationDirective",
	    value: function exitFieldFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumValueDirective.

	  }, {
	    key: "enterEnumValueDirective",
	    value: function enterEnumValueDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumValueDirective.

	  }, {
	    key: "exitEnumValueDirective",
	    value: function exitEnumValueDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumValueFederationDirective.

	  }, {
	    key: "enterEnumValueFederationDirective",
	    value: function enterEnumValueFederationDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumValueFederationDirective.

	  }, {
	    key: "exitEnumValueFederationDirective",
	    value: function exitEnumValueFederationDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#name.

	  }, {
	    key: "enterName",
	    value: function enterName(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#name.

	  }, {
	    key: "exitName",
	    value: function exitName(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#name_f.

	  }, {
	    key: "enterName_f",
	    value: function enterName_f(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#name_f.

	  }, {
	    key: "exitName_f",
	    value: function exitName_f(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#booleanValue_f.

	  }, {
	    key: "enterBooleanValue_f",
	    value: function enterBooleanValue_f(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#booleanValue_f.

	  }, {
	    key: "exitBooleanValue_f",
	    value: function exitBooleanValue_f(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#keyword.

	  }, {
	    key: "enterKeyword",
	    value: function enterKeyword(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#keyword.

	  }, {
	    key: "exitKeyword",
	    value: function exitKeyword(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#keyword_f.

	  }, {
	    key: "enterKeyword_f",
	    value: function enterKeyword_f(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#keyword_f.

	  }, {
	    key: "exitKeyword_f",
	    value: function exitKeyword_f(ctx) {}
	  }]);

	  return GraphQLFederationParserListener;
	}(_antlr["default"].tree.ParseTreeListener);

	exports["default"] = GraphQLFederationParserListener;
} (GraphQLFederationParserListener));

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	var _GraphQLFederationParserListener = _interopRequireDefault(GraphQLFederationParserListener);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var serializedATN = ["\x03\u608B\uA72A\u8133\uB9ED\u417C\u3BE7\u7786", "\u5964\x03q\u03F0\x04\x02\t\x02\x04\x03\t\x03\x04\x04", "\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07\t\x07", "\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\x0B\t\x0B\x04\f\t\f", "\x04\r\t\r\x04\x0E\t\x0E\x04\x0F\t\x0F\x04\x10\t\x10", "\x04\x11\t\x11\x04\x12\t\x12\x04\x13\t\x13\x04\x14", "\t\x14\x04\x15\t\x15\x04\x16\t\x16\x04\x17\t\x17", "\x04\x18\t\x18\x04\x19\t\x19\x04\x1A\t\x1A\x04\x1B", "\t\x1B\x04\x1C\t\x1C\x04\x1D\t\x1D\x04\x1E\t\x1E", "\x04\x1F\t\x1F\x04 \t \x04!\t!\x04\"\t\"\x04#\t#\x04", "$\t$\x04%\t%\x04&\t&\x04'\t'\x04(\t(\x04)\t)\x04*\t*\x04", "+\t+\x04,\t,\x04-\t-\x04.\t.\x04/\t/\x040\t0\x041\t1\x04", "2\t2\x043\t3\x044\t4\x045\t5\x046\t6\x047\t7\x048\t8\x04", "9\t9\x04:\t:\x04;\t;\x04<\t<\x04=\t=\x04>\t>\x04?\t?\x04", "@\t@\x04A\tA\x04B\tB\x04C\tC\x04D\tD\x04E\tE\x04F\tF\x04", "G\tG\x04H\tH\x04I\tI\x04J\tJ\x04K\tK\x04L\tL\x04M\tM\x04", "N\tN\x04O\tO\x04P\tP\x04Q\tQ\x04R\tR\x04S\tS\x04T\tT\x04", "U\tU\x04V\tV\x04W\tW\x04X\tX\x04Y\tY\x04Z\tZ\x04[\t[\x04", "\\\t\\\x04]\t]\x04^\t^\x04_\t_\x04`\t`\x04a\ta\x04b\tb\x04", "c\tc\x04d\td\x04e\te\x04f\tf\x04g\tg\x04h\th\x04i\ti\x04", "j\tj\x04k\tk\x03\x02\x06\x02\xD8\n\x02\r\x02\x0E\x02", "\xD9\x03\x02\x03\x02\x03\x03\x03\x03\x03\x03\x05", "\x03\xE1\n\x03\x03\x04\x03\x04\x05\x04\xE5\n\x04", "\x03\x05\x03\x05\x05\x05\xE9\n\x05\x03\x05\x05", "\x05\xEC\n\x05\x03\x05\x05\x05\xEF\n\x05\x03\x05", "\x03\x05\x03\x05\x05\x05\xF4\n\x05\x03\x06\x03", "\x06\x03\x07\x03\x07\x06\x07\xFA\n\x07\r\x07\x0E", "\x07\xFB\x03\x07\x03\x07\x03\b\x03\b\x03\b\x05\b", "\u0103\n\b\x03\t\x05\t\u0106\n\t\x03\t\x03\t\x05\t\u010A\n", "\t\x03\t\x05\t\u010D\n\t\x03\t\x05\t\u0110\n\t\x03\n\x03", "\n\x06\n\u0114\n\n\r\n\x0E\n\u0115\x03\n\x03\n\x03\x0B\x03", "\x0B\x03\x0B\x03\x0B\x03\f\x03\f\x03\f\x03\r\x03", "\r\x03\r\x05\r\u0124\n\r\x03\x0E\x03\x0E\x03\x0E\x03", "\x0E\x05\x0E\u012A\n\x0E\x03\x0E\x03\x0E\x03\x0F", "\x03\x0F\x03\x10\x03\x10\x03\x10\x03\x11\x03\x11", "\x05\x11\u0135\n\x11\x03\x11\x05\x11\u0138\n\x11\x03", "\x11\x03\x11\x03\x12\x03\x12\x03\x12\x03\x12\x03", "\x12\x03\x12\x03\x12\x03\x12\x03\x12\x05\x12\u0145", "\n\x12\x03\x13\x03\x13\x03\x14\x03\x14\x03\x15", "\x03\x15\x03\x16\x03\x16\x03\x17\x03\x17\x03\x18", "\x03\x18\x03\x19\x03\x19\x03\x19\x03\x19\x06\x19", "\u0157\n\x19\r\x19\x0E\x19\u0158\x03\x19\x03\x19\x05", "\x19\u015D\n\x19\x03\x1A\x03\x1A\x07\x1A\u0161\n\x1A", "\f\x1A\x0E\x1A\u0164\x0B\x1A\x03\x1A\x03\x1A\x03", "\x1B\x03\x1B\x03\x1B\x03\x1B\x03\x1C\x03\x1C\x03", "\x1C\x03\x1D\x03\x1D\x06\x1D\u0171\n\x1D\r\x1D\x0E", "\x1D\u0172\x03\x1D\x03\x1D\x03\x1E\x03\x1E\x03\x1E", "\x03\x1E\x05\x1E\u017B\n\x1E\x03\x1F\x03\x1F\x03", "\x1F\x03 \x03 \x05 \u0182\n \x03 \x03 \x05 \u0186\n \x05", " \u0188\n \x03!\x03!\x03\"\x03\"\x03\"\x03\"\x03#\x06", "#\u0191\n#\r#\x0E#\u0192\x03$\x03$\x03$\x05$\u0198\n$\x03", "%\x03%\x03%\x05%\u019D\n%\x03&\x03&\x05&\u01A1\n&\x03", "'\x05'\u01A4\n'\x03'\x03'\x07'\u01A8\n'\f'\x0E'\u01AB", "\x0B'\x03'\x03'\x06'\u01AF\n'\r'\x0E'\u01B0\x03'", "\x03'\x03(\x03(\x03(\x03(\x03)\x03)\x03)\x07)\u01BC", "\n)\f)\x0E)\u01BF\x0B)\x03)\x03)\x06)\u01C3\n)\r)\x0E)\u01C4", "\x03)\x03)\x03)\x03)\x03)\x06)\u01CC\n)\r)\x0E)\u01CD", "\x05)\u01D0\n)\x03*\x03*\x03*\x03*\x03+\x03+\x03,\x03", ",\x03,\x03,\x03,\x03,\x05,\u01DE\n,\x03-\x03-\x03-\x03", "-\x03-\x03-\x05-\u01E6\n-\x03.\x05.\u01E9\n.\x03.\x03", ".\x03.\x07.\u01EE\n.\f.\x0E.\u01F1\x0B.\x03/\x03/\x03", "/\x03/\x06/\u01F7\n/\r/\x0E/\u01F8\x030\x050\u01FC\n0\x03", "0\x030\x030\x050\u0201\n0\x030\x070\u0204\n0\f0\x0E0\u0207", "\x0B0\x030\x050\u020A\n0\x031\x031\x051\u020E\n1\x031", "\x031\x051\u0212\n1\x031\x071\u0215\n1\f1\x0E1\u0218\x0B", "1\x032\x032\x062\u021C\n2\r2\x0E2\u021D\x032\x032\x03", "3\x053\u0223\n3\x033\x033\x053\u0227\n3\x033\x033\x03", "3\x073\u022C\n3\f3\x0E3\u022F\x0B3\x033\x053\u0232\n3\x03", "3\x033\x053\u0236\n3\x033\x033\x033\x053\u023B\n3\x03", "4\x034\x064\u023F\n4\r4\x0E4\u0240\x034\x034\x035\x05", "5\u0246\n5\x035\x035\x035\x035\x055\u024C\n5\x035\x07", "5\u024F\n5\f5\x0E5\u0252\x0B5\x036\x036\x036\x036\x05", "6\u0258\n6\x036\x076\u025B\n6\f6\x0E6\u025E\x0B6\x036\x03", "6\x036\x036\x036\x036\x056\u0266\n6\x036\x066\u0269\n", "6\r6\x0E6\u026A\x036\x036\x036\x036\x036\x056\u0272\n", "6\x037\x057\u0275\n7\x037\x037\x037\x057\u027A\n7\x03", "7\x077\u027D\n7\f7\x0E7\u0280\x0B7\x037\x057\u0283\n7\x03", "8\x038\x038\x038\x058\u0289\n8\x038\x078\u028C\n8\f8\x0E", "8\u028F\x0B8\x038\x038\x038\x038\x038\x038\x058\u0297", "\n8\x038\x068\u029A\n8\r8\x0E8\u029B\x038\x038\x038\x03", "8\x038\x058\u02A3\n8\x039\x059\u02A6\n9\x039\x039\x03", "9\x079\u02AB\n9\f9\x0E9\u02AE\x0B9\x039\x059\u02B1\n9\x03", ":\x03:\x05:\u02B5\n:\x03:\x03:\x03:\x07:\u02BA\n:\f:\x0E", ":\u02BD\x0B:\x03;\x03;\x03;\x03;\x07;\u02C3\n;\f;\x0E", ";\u02C6\x0B;\x03;\x03;\x03;\x03;\x03;\x03;\x06;\u02CE", "\n;\r;\x0E;\u02CF\x05;\u02D2\n;\x03<\x05<\u02D5\n<\x03<\x03", "<\x03<\x07<\u02DA\n<\f<\x0E<\u02DD\x0B<\x03<\x05<\u02E0", "\n<\x03=\x03=\x06=\u02E4\n=\r=\x0E=\u02E5\x03=\x03=\x03", ">\x05>\u02EB\n>\x03>\x03>\x07>\u02EF\n>\f>\x0E>\u02F2\x0B", ">\x03?\x03?\x03?\x03?\x07?\u02F8\n?\f?\x0E?\u02FB\x0B", "?\x03?\x03?\x03?\x03?\x03?\x03?\x06?\u0303\n?\r?\x0E", "?\u0304\x05?\u0307\n?\x03@\x05@\u030A\n@\x03@\x03@\x03@", "\x07@\u030F\n@\f@\x0E@\u0312\x0B@\x03@\x05@\u0315\n@\x03", "A\x03A\x06A\u0319\nA\rA\x0EA\u031A\x03A\x03A\x03B\x03", "B\x03B\x03B\x07B\u0323\nB\fB\x0EB\u0326\x0BB\x03B\x03", "B\x03B\x03B\x03B\x03B\x06B\u032E\nB\rB\x0EB\u032F\x05", "B\u0332\nB\x03C\x05C\u0335\nC\x03C\x03C\x03C\x03C\x05", "C\u033B\nC\x03C\x05C\u033E\nC\x03C\x03C\x03C\x03D\x03", "D\x03D\x07D\u0346\nD\fD\x0ED\u0349\x0BD\x03E\x03E\x05", "E\u034D\nE\x03F\x03F\x03G\x03G\x03H\x03H\x03I\x03I\x03", "J\x03J\x03J\x03J\x03J\x03J\x03J\x03J\x03J\x03K\x03", "K\x03K\x03K\x03K\x03K\x03K\x03K\x03K\x03L\x03L\x03", "L\x03L\x03L\x03L\x03L\x03L\x03L\x03L\x03L\x03L\x03", "L\x03L\x03L\x03L\x03L\x03L\x03L\x03L\x03L\x05L\u037E", "\nL\x03M\x03M\x03N\x03N\x03N\x03N\x03N\x03N\x03N\x03", "N\x03N\x03O\x03O\x03O\x03P\x06P\u038F\nP\rP\x0EP\u0390", "\x03Q\x03Q\x05Q\u0395\nQ\x03R\x03R\x03R\x03R\x03S\x03", "S\x05S\u039D\nS\x03T\x03T\x03U\x03U\x05U\u03A3\nU\x03", "V\x03V\x03W\x03W\x05W\u03A9\nW\x03X\x03X\x03X\x05X\u03AE", "\nX\x03Y\x03Y\x05Y\u03B2\nY\x03Z\x03Z\x05Z\u03B6\nZ\x03", "[\x03[\x05[\u03BA\n[\x03\\\x03\\\x03]\x03]\x05]\u03C0", "\n]\x03^\x03^\x03_\x03_\x05_\u03C6\n_\x03`\x03`\x03", "a\x03a\x05a\u03CC\na\x03b\x03b\x03c\x03c\x05c\u03D2\n", "c\x03d\x03d\x03d\x03d\x03d\x03d\x05d\u03DA\nd\x03e\x03", "e\x05e\u03DE\ne\x03f\x03f\x03g\x03g\x05g\u03E4\ng\x03", "h\x03h\x05h\u03E8\nh\x03i\x03i\x03j\x03j\x03k\x03k\x03", "k\x02\x02l\x02\x04\x06\b\n\f\x0E\x10\x12\x14\x16", "\x18\x1A\x1C\x1E \"$&(*,.02468:<>@BDFHJLNPRTVXZ\\^`bdfhjlnp", "rtvxz|~\x80\x82\x84\x86\x88\x8A\x8C\x8E\x90\x92", "\x94\x96\x98\x9A\x9C\x9E\xA0\xA2\xA4\xA6\xA8\xAA", "\xAC\xAE\xB0\xB2\xB4\xB6\xB8\xBA\xBC\xBE\xC0\xC2", "\xC4\xC6\xC8\xCA\xCC\xCE\xD0\xD2\xD4\x02\n\x03", "\x02\x14\x16\x03\x02CD\x03\x02GH\x04\x02$&)-\x06", "\x02\x1D\x1F\"\"''.3\x03\x02UV\x04\x02\x0B3RT\x03", "\x02_n\x02\u0418\x02\xD7\x03\x02\x02\x02\x04\xE0", "\x03\x02\x02\x02\x06\xE4\x03\x02\x02\x02\b\xF3", "\x03\x02\x02\x02\n\xF5\x03\x02\x02\x02\f\xF7\x03", "\x02\x02\x02\x0E\u0102\x03\x02\x02\x02\x10\u0105\x03", "\x02\x02\x02\x12\u0111\x03\x02\x02\x02\x14\u0119\x03", "\x02\x02\x02\x16\u011D\x03\x02\x02\x02\x18\u0120\x03", "\x02\x02\x02\x1A\u0125\x03\x02\x02\x02\x1C\u012D\x03", "\x02\x02\x02\x1E\u012F\x03\x02\x02\x02 \u0132\x03", "\x02\x02\x02\"\u0144\x03\x02\x02\x02$\u0146\x03\x02", "\x02\x02&\u0148\x03\x02\x02\x02(\u014A\x03\x02\x02", "\x02*\u014C\x03\x02\x02\x02,\u014E\x03\x02\x02\x02", ".\u0150\x03\x02\x02\x020\u015C\x03\x02\x02\x022\u015E", "\x03\x02\x02\x024\u0167\x03\x02\x02\x026\u016B\x03", "\x02\x02\x028\u016E\x03\x02\x02\x02:\u0176\x03\x02", "\x02\x02<\u017C\x03\x02\x02\x02>\u0187\x03\x02\x02", "\x02@\u0189\x03\x02\x02\x02B\u018B\x03\x02\x02\x02", "D\u0190\x03\x02\x02\x02F\u0194\x03\x02\x02\x02H\u019C", "\x03\x02\x02\x02J\u01A0\x03\x02\x02\x02L\u01A3\x03", "\x02\x02\x02N\u01B4\x03\x02\x02\x02P\u01CF\x03\x02", "\x02\x02R\u01D1\x03\x02\x02\x02T\u01D5\x03\x02\x02", "\x02V\u01DD\x03\x02\x02\x02X\u01E5\x03\x02\x02\x02", "Z\u01E8\x03\x02\x02\x02\\\u01F2\x03\x02\x02\x02^\u01FB", "\x03\x02\x02\x02`\u020B\x03\x02\x02\x02b\u0219\x03", "\x02\x02\x02d\u023A\x03\x02\x02\x02f\u023C\x03\x02", "\x02\x02h\u0245\x03\x02\x02\x02j\u0271\x03\x02\x02", "\x02l\u0274\x03\x02\x02\x02n\u02A2\x03\x02\x02\x02", "p\u02A5\x03\x02\x02\x02r\u02B2\x03\x02\x02\x02t\u02D1", "\x03\x02\x02\x02v\u02D4\x03\x02\x02\x02x\u02E1\x03", "\x02\x02\x02z\u02EA\x03\x02\x02\x02|\u0306\x03\x02", "\x02\x02~\u0309\x03\x02\x02\x02\x80\u0316\x03\x02", "\x02\x02\x82\u0331\x03\x02\x02\x02\x84\u0334\x03\x02", "\x02\x02\x86\u0342\x03\x02\x02\x02\x88\u034C\x03\x02", "\x02\x02\x8A\u034E\x03\x02\x02\x02\x8C\u0350\x03\x02", "\x02\x02\x8E\u0352\x03\x02\x02\x02\x90\u0354\x03\x02", "\x02\x02\x92\u0356\x03\x02\x02\x02\x94\u035F\x03\x02", "\x02\x02\x96\u037D\x03\x02\x02\x02\x98\u037F\x03\x02", "\x02\x02\x9A\u0381\x03\x02\x02\x02\x9C\u038A\x03\x02", "\x02\x02\x9E\u038E\x03\x02\x02\x02\xA0\u0392\x03\x02", "\x02\x02\xA2\u0396\x03\x02\x02\x02\xA4\u039C\x03\x02", "\x02\x02\xA6\u039E\x03\x02\x02\x02\xA8\u03A2\x03\x02", "\x02\x02\xAA\u03A4\x03\x02\x02\x02\xAC\u03A8\x03\x02", "\x02\x02\xAE\u03AD\x03\x02\x02\x02\xB0\u03B1\x03\x02", "\x02\x02\xB2\u03B5\x03\x02\x02\x02\xB4\u03B9\x03\x02", "\x02\x02\xB6\u03BB\x03\x02\x02\x02\xB8\u03BF\x03\x02", "\x02\x02\xBA\u03C1\x03\x02\x02\x02\xBC\u03C5\x03\x02", "\x02\x02\xBE\u03C7\x03\x02\x02\x02\xC0\u03CB\x03\x02", "\x02\x02\xC2\u03CD\x03\x02\x02\x02\xC4\u03D1\x03\x02", "\x02\x02\xC6\u03D9\x03\x02\x02\x02\xC8\u03DD\x03\x02", "\x02\x02\xCA\u03DF\x03\x02\x02\x02\xCC\u03E3\x03\x02", "\x02\x02\xCE\u03E7\x03\x02\x02\x02\xD0\u03E9\x03\x02", "\x02\x02\xD2\u03EB\x03\x02\x02\x02\xD4\u03ED\x03\x02", "\x02\x02\xD6\xD8\x05\x04\x03\x02\xD7\xD6\x03\x02", "\x02\x02\xD8\xD9\x03\x02\x02\x02\xD9\xD7\x03\x02", "\x02\x02\xD9\xDA\x03\x02\x02\x02\xDA\xDB\x03\x02", "\x02\x02\xDB\xDC\x07\x02\x02\x03\xDC\x03\x03\x02", "\x02\x02\xDD\xE1\x05\x06\x04\x02\xDE\xE1\x05H", "%\x02\xDF\xE1\x05J&\x02\xE0\xDD\x03\x02\x02\x02", "\xE0\xDE\x03\x02\x02\x02\xE0\xDF\x03\x02\x02\x02", "\xE1\x05\x03\x02\x02\x02\xE2\xE5\x05\b\x05\x02", "\xE3\xE5\x05\x1A\x0E\x02\xE4\xE2\x03\x02\x02\x02", "\xE4\xE3\x03\x02\x02\x02\xE5\x07\x03\x02\x02\x02", "\xE6\xE8\x05\n\x06\x02\xE7\xE9\x05\xCCg\x02\xE8", "\xE7\x03\x02\x02\x02\xE8\xE9\x03\x02\x02\x02\xE9", "\xEB\x03\x02\x02\x02\xEA\xEC\x058\x1D\x02\xEB", "\xEA\x03\x02\x02\x02\xEB\xEC\x03\x02\x02\x02\xEC", "\xEE\x03\x02\x02\x02\xED\xEF\x05D#\x02\xEE\xED", "\x03\x02\x02\x02\xEE\xEF\x03\x02\x02\x02\xEF\xF0", "\x03\x02\x02\x02\xF0\xF1\x05\f\x07\x02\xF1\xF4", "\x03\x02\x02\x02\xF2\xF4\x05\f\x07\x02\xF3\xE6", "\x03\x02\x02\x02\xF3\xF2\x03\x02\x02\x02\xF4\t", "\x03\x02\x02\x02\xF5\xF6\t\x02\x02\x02\xF6\x0B", "\x03\x02\x02\x02\xF7\xF9\x074\x02\x02\xF8\xFA", "\x05\x0E\b\x02\xF9\xF8\x03\x02\x02\x02\xFA\xFB", "\x03\x02\x02\x02\xFB\xF9\x03\x02\x02\x02\xFB\xFC", "\x03\x02\x02\x02\xFC\xFD\x03\x02\x02\x02\xFD\xFE", "\x075\x02\x02\xFE\r\x03\x02\x02\x02\xFF\u0103\x05", "\x10\t\x02\u0100\u0103\x05\x18\r\x02\u0101\u0103\x05 \x11", "\x02\u0102\xFF\x03\x02\x02\x02\u0102\u0100\x03\x02\x02", "\x02\u0102\u0101\x03\x02\x02\x02\u0103\x0F\x03\x02\x02", "\x02\u0104\u0106\x05\x16\f\x02\u0105\u0104\x03\x02\x02", "\x02\u0105\u0106\x03\x02\x02\x02\u0106\u0107\x03\x02\x02", "\x02\u0107\u0109\x05\xCCg\x02\u0108\u010A\x05\x12\n\x02", "\u0109\u0108\x03\x02\x02\x02\u0109\u010A\x03\x02\x02\x02", "\u010A\u010C\x03\x02\x02\x02\u010B\u010D\x05D#\x02\u010C", "\u010B\x03\x02\x02\x02\u010C\u010D\x03\x02\x02\x02\u010D", "\u010F\x03\x02\x02\x02\u010E\u0110\x05\f\x07\x02\u010F", "\u010E\x03\x02\x02\x02\u010F\u0110\x03\x02\x02\x02\u0110", "\x11\x03\x02\x02\x02\u0111\u0113\x078\x02\x02\u0112", "\u0114\x05\x14\x0B\x02\u0113\u0112\x03\x02\x02\x02\u0114", "\u0115\x03\x02\x02\x02\u0115\u0113\x03\x02\x02\x02\u0115", "\u0116\x03\x02\x02\x02\u0116\u0117\x03\x02\x02\x02\u0117", "\u0118\x079\x02\x02\u0118\x13\x03\x02\x02\x02\u0119", "\u011A\x05\xCCg\x02\u011A\u011B\x07=\x02\x02\u011B\u011C", "\x05\"\x12\x02\u011C\x15\x03\x02\x02\x02\u011D\u011E", "\x05\xCCg\x02\u011E\u011F\x07=\x02\x02\u011F\x17\x03", "\x02\x02\x02\u0120\u0121\x07>\x02\x02\u0121\u0123\x05", "\x1C\x0F\x02\u0122\u0124\x05D#\x02\u0123\u0122\x03\x02", "\x02\x02\u0123\u0124\x03\x02\x02\x02\u0124\x19\x03\x02", "\x02\x02\u0125\u0126\x07\x18\x02\x02\u0126\u0127\x05\x1C", "\x0F\x02\u0127\u0129\x05\x1E\x10\x02\u0128\u012A\x05D", "#\x02\u0129\u0128\x03\x02\x02\x02\u0129\u012A\x03\x02", "\x02\x02\u012A\u012B\x03\x02\x02\x02\u012B\u012C\x05\f", "\x07\x02\u012C\x1B\x03\x02\x02\x02\u012D\u012E\x05\xCC", "g\x02\u012E\x1D\x03\x02\x02\x02\u012F\u0130\x07\x19", "\x02\x02\u0130\u0131\x05@!\x02\u0131\x1F\x03\x02\x02", "\x02\u0132\u0134\x07>\x02\x02\u0133\u0135\x05\x1E\x10", "\x02\u0134\u0133\x03\x02\x02\x02\u0134\u0135\x03\x02\x02", "\x02\u0135\u0137\x03\x02\x02\x02\u0136\u0138\x05D#\x02", "\u0137\u0136\x03\x02\x02\x02\u0137\u0138\x03\x02\x02\x02", "\u0138\u0139\x03\x02\x02\x02\u0139\u013A\x05\f\x07\x02", "\u013A!\x03\x02\x02\x02\u013B\u0145\x056\x1C\x02\u013C", "\u0145\x05$\x13\x02\u013D\u0145\x05&\x14\x02\u013E\u0145", "\x05*\x16\x02\u013F\u0145\x05(\x15\x02\u0140\u0145\x05", ",\x17\x02\u0141\u0145\x05.\x18\x02\u0142\u0145\x050\x19", "\x02\u0143\u0145\x052\x1A\x02\u0144\u013B\x03\x02\x02", "\x02\u0144\u013C\x03\x02\x02\x02\u0144\u013D\x03\x02\x02", "\x02\u0144\u013E\x03\x02\x02\x02\u0144\u013F\x03\x02\x02", "\x02\u0144\u0140\x03\x02\x02\x02\u0144\u0141\x03\x02\x02", "\x02\u0144\u0142\x03\x02\x02\x02\u0144\u0143\x03\x02\x02", "\x02\u0145#\x03\x02\x02\x02\u0146\u0147\x07J\x02\x02", "\u0147%\x03\x02\x02\x02\u0148\u0149\x07I\x02\x02\u0149", "'\x03\x02\x02\x02\u014A\u014B\t\x03\x02\x02\u014B)\x03", "\x02\x02\x02\u014C\u014D\t\x04\x02\x02\u014D+\x03\x02", "\x02\x02\u014E\u014F\x07E\x02\x02\u014F-\x03\x02\x02", "\x02\u0150\u0151\x05\xCCg\x02\u0151/\x03\x02\x02\x02", "\u0152\u0153\x076\x02\x02\u0153\u015D\x077\x02\x02\u0154", "\u0156\x076\x02\x02\u0155\u0157\x05\"\x12\x02\u0156\u0155", "\x03\x02\x02\x02\u0157\u0158\x03\x02\x02\x02\u0158\u0156", "\x03\x02\x02\x02\u0158\u0159\x03\x02\x02\x02\u0159\u015A", "\x03\x02\x02\x02\u015A\u015B\x077\x02\x02\u015B\u015D", "\x03\x02\x02\x02\u015C\u0152\x03\x02\x02\x02\u015C\u0154", "\x03\x02\x02\x02\u015D1\x03\x02\x02\x02\u015E\u0162", "\x074\x02\x02\u015F\u0161\x054\x1B\x02\u0160\u015F\x03", "\x02\x02\x02\u0161\u0164\x03\x02\x02\x02\u0162\u0160\x03", "\x02\x02\x02\u0162\u0163\x03\x02\x02\x02\u0163\u0165\x03", "\x02\x02\x02\u0164\u0162\x03\x02\x02\x02\u0165\u0166\x07", "5\x02\x02\u01663\x03\x02\x02\x02\u0167\u0168\x05\xCC", "g\x02\u0168\u0169\x07=\x02\x02\u0169\u016A\x05\"\x12\x02", "\u016A5\x03\x02\x02\x02\u016B\u016C\x07A\x02\x02\u016C", "\u016D\x05\xCCg\x02\u016D7\x03\x02\x02\x02\u016E\u0170", "\x078\x02\x02\u016F\u0171\x05:\x1E\x02\u0170\u016F\x03", "\x02\x02\x02\u0171\u0172\x03\x02\x02\x02\u0172\u0170\x03", "\x02\x02\x02\u0172\u0173\x03\x02\x02\x02\u0173\u0174\x03", "\x02\x02\x02\u0174\u0175\x079\x02\x02\u01759\x03\x02", "\x02\x02\u0176\u0177\x056\x1C\x02\u0177\u0178\x07=\x02", "\x02\u0178\u017A\x05> \x02\u0179\u017B\x05<\x1F\x02\u017A", "\u0179\x03\x02\x02\x02\u017A\u017B\x03\x02\x02\x02\u017B", ";\x03\x02\x02\x02\u017C\u017D\x07<\x02\x02\u017D\u017E", "\x05\"\x12\x02\u017E=\x03\x02\x02\x02\u017F\u0181\x05", "@!\x02\u0180\u0182\x07?\x02\x02\u0181\u0180\x03\x02\x02", "\x02\u0181\u0182\x03\x02\x02\x02\u0182\u0188\x03\x02\x02", "\x02\u0183\u0185\x05B\"\x02\u0184\u0186\x07?\x02\x02\u0185", "\u0184\x03\x02\x02\x02\u0185\u0186\x03\x02\x02\x02\u0186", "\u0188\x03\x02\x02\x02\u0187\u017F\x03\x02\x02\x02\u0187", "\u0183\x03\x02\x02\x02\u0188?\x03\x02\x02\x02\u0189", "\u018A\x05\xCCg\x02\u018AA\x03\x02\x02\x02\u018B\u018C", "\x076\x02\x02\u018C\u018D\x05> \x02\u018D\u018E\x077\x02", "\x02\u018EC\x03\x02\x02\x02\u018F\u0191\x05F$\x02\u0190", "\u018F\x03\x02\x02\x02\u0191\u0192\x03\x02\x02\x02\u0192", "\u0190\x03\x02\x02\x02\u0192\u0193\x03\x02\x02\x02\u0193", "E\x03\x02\x02\x02\u0194\u0195\x07:\x02\x02\u0195\u0197", "\x05\xCCg\x02\u0196\u0198\x05\x12\n\x02\u0197\u0196\x03", "\x02\x02\x02\u0197\u0198\x03\x02\x02\x02\u0198G\x03", "\x02\x02\x02\u0199\u019D\x05L'\x02\u019A\u019D\x05V,\x02", "\u019B\u019D\x05\x84C\x02\u019C\u0199\x03\x02\x02\x02", "\u019C\u019A\x03\x02\x02\x02\u019C\u019B\x03\x02\x02\x02", "\u019DI\x03\x02\x02\x02\u019E\u01A1\x05P)\x02\u019F\u01A1", "\x05X-\x02\u01A0\u019E\x03\x02\x02\x02\u01A0\u019F\x03", "\x02\x02\x02\u01A1K\x03\x02\x02\x02\u01A2\u01A4\x05", "T+\x02\u01A3\u01A2\x03\x02\x02\x02\u01A3\u01A4\x03\x02", "\x02\x02\u01A4\u01A5\x03\x02\x02\x02\u01A5\u01A9\x07\x17", "\x02\x02\u01A6\u01A8\x05\xA4S\x02\u01A7\u01A6\x03\x02", "\x02\x02\u01A8\u01AB\x03\x02\x02\x02\u01A9\u01A7\x03\x02", "\x02\x02\u01A9\u01AA\x03\x02\x02\x02\u01AA\u01AC\x03\x02", "\x02\x02\u01AB\u01A9\x03\x02\x02\x02\u01AC\u01AE\x074", "\x02\x02\u01AD\u01AF\x05N(\x02\u01AE\u01AD\x03\x02\x02", "\x02\u01AF\u01B0\x03\x02\x02\x02\u01B0\u01AE\x03\x02\x02", "\x02\u01B0\u01B1\x03\x02\x02\x02\u01B1\u01B2\x03\x02\x02", "\x02\u01B2\u01B3\x075\x02\x02\u01B3M\x03\x02\x02\x02", "\u01B4\u01B5\x05\n\x06\x02\u01B5\u01B6\x07=\x02\x02\u01B6", "\u01B7\x05@!\x02\u01B7O\x03\x02\x02\x02\u01B8\u01B9\x07", "\x11\x02\x02\u01B9\u01BD\x07\x17\x02\x02\u01BA\u01BC\x05", "\xA4S\x02\u01BB\u01BA\x03\x02\x02\x02\u01BC\u01BF\x03", "\x02\x02\x02\u01BD\u01BB\x03\x02\x02\x02\u01BD\u01BE\x03", "\x02\x02\x02\u01BE\u01C0\x03\x02\x02\x02\u01BF\u01BD\x03", "\x02\x02\x02\u01C0\u01C2\x074\x02\x02\u01C1\u01C3\x05", "R*\x02\u01C2\u01C1\x03\x02\x02\x02\u01C3\u01C4\x03\x02", "\x02\x02\u01C4\u01C2\x03\x02\x02\x02\u01C4\u01C5\x03\x02", "\x02\x02\u01C5\u01C6\x03\x02\x02\x02\u01C6\u01C7\x075", "\x02\x02\u01C7\u01D0\x03\x02\x02\x02\u01C8\u01C9\x07\x11", "\x02\x02\u01C9\u01CB\x07\x17\x02\x02\u01CA\u01CC\x05\xA4", "S\x02\u01CB\u01CA\x03\x02\x02\x02\u01CC\u01CD\x03\x02", "\x02\x02\u01CD\u01CB\x03\x02\x02\x02\u01CD\u01CE\x03\x02", "\x02\x02\u01CE\u01D0\x03\x02\x02\x02\u01CF\u01B8\x03\x02", "\x02\x02\u01CF\u01C8\x03\x02\x02\x02\u01D0Q\x03\x02", "\x02\x02\u01D1\u01D2\x05\n\x06\x02\u01D2\u01D3\x07=\x02", "\x02\u01D3\u01D4\x05@!\x02\u01D4S\x03\x02\x02\x02\u01D5", "\u01D6\x05*\x16\x02\u01D6U\x03\x02\x02\x02\u01D7\u01DE", "\x05Z.\x02\u01D8\u01DE\x05^0\x02\u01D9\u01DE\x05l7\x02\u01DA", "\u01DE\x05p9\x02\u01DB\u01DE\x05v<\x02\u01DC\u01DE\x05~@\x02", "\u01DD\u01D7\x03\x02\x02\x02\u01DD\u01D8\x03\x02\x02\x02", "\u01DD\u01D9\x03\x02\x02\x02\u01DD\u01DA\x03\x02\x02\x02", "\u01DD\u01DB\x03\x02\x02\x02\u01DD\u01DC\x03\x02\x02\x02", "\u01DEW\x03\x02\x02\x02\u01DF\u01E6\x05\\/\x02\u01E0\u01E6", "\x05j6\x02\u01E1\u01E6\x05n8\x02\u01E2\u01E6\x05t;\x02\u01E3", "\u01E6\x05|?\x02\u01E4\u01E6\x05\x82B\x02\u01E5\u01DF\x03", "\x02\x02\x02\u01E5\u01E0\x03\x02\x02\x02\u01E5\u01E1\x03", "\x02\x02\x02\u01E5\u01E2\x03\x02\x02\x02\u01E5\u01E3\x03", "\x02\x02\x02\u01E5\u01E4\x03\x02\x02\x02\u01E6Y\x03", "\x02\x02\x02\u01E7\u01E9\x05T+\x02\u01E8\u01E7\x03\x02", "\x02\x02\u01E8\u01E9\x03\x02\x02\x02\u01E9\u01EA\x03\x02", "\x02\x02\u01EA\u01EB\x07\x0E\x02\x02\u01EB\u01EF\x05\xCC", "g\x02\u01EC\u01EE\x05\xA8U\x02\u01ED\u01EC\x03\x02\x02", "\x02\u01EE\u01F1\x03\x02\x02\x02\u01EF\u01ED\x03\x02\x02", "\x02\u01EF\u01F0\x03\x02\x02\x02\u01F0[\x03\x02\x02", "\x02\u01F1\u01EF\x03\x02\x02\x02\u01F2\u01F3\x07\x11\x02", "\x02\u01F3\u01F4\x07\x0E\x02\x02\u01F4\u01F6\x05\xCCg", "\x02\u01F5\u01F7\x05\xA8U\x02\u01F6\u01F5\x03\x02\x02", "\x02\u01F7\u01F8\x03\x02\x02\x02\u01F8\u01F6\x03\x02\x02", "\x02\u01F8\u01F9\x03\x02\x02\x02\u01F9]\x03\x02\x02", "\x02\u01FA\u01FC\x05T+\x02\u01FB\u01FA\x03\x02\x02\x02", "\u01FB\u01FC\x03\x02\x02\x02\u01FC\u01FD\x03\x02\x02\x02", "\u01FD\u01FE\x07\f\x02\x02\u01FE\u0200\x05\xCCg\x02\u01FF", "\u0201\x05`1\x02\u0200\u01FF\x03\x02\x02\x02\u0200\u0201", "\x03\x02\x02\x02\u0201\u0205\x03\x02\x02\x02\u0202\u0204", "\x05\xACW\x02\u0203\u0202\x03\x02\x02\x02\u0204\u0207", "\x03\x02\x02\x02\u0205\u0203\x03\x02\x02\x02\u0205\u0206", "\x03\x02\x02\x02\u0206\u0209\x03\x02\x02\x02\u0207\u0205", "\x03\x02\x02\x02\u0208\u020A\x05b2\x02\u0209\u0208\x03", "\x02\x02\x02\u0209\u020A\x03\x02\x02\x02\u020A_\x03", "\x02\x02\x02\u020B\u020D\x07\x13\x02\x02\u020C\u020E\x07", ";\x02\x02\u020D\u020C\x03\x02\x02\x02\u020D\u020E\x03", "\x02\x02\x02\u020E\u020F\x03\x02\x02\x02\u020F\u0216\x05", "@!\x02\u0210\u0212\x07;\x02\x02\u0211\u0210\x03\x02\x02", "\x02\u0211\u0212\x03\x02\x02\x02\u0212\u0213\x03\x02\x02", "\x02\u0213\u0215\x05@!\x02\u0214\u0211\x03\x02\x02\x02", "\u0215\u0218\x03\x02\x02\x02\u0216\u0214\x03\x02\x02\x02", "\u0216\u0217\x03\x02\x02\x02\u0217a\x03\x02\x02\x02", "\u0218\u0216\x03\x02\x02\x02\u0219\u021B\x074\x02\x02", "\u021A\u021C\x05d3\x02\u021B\u021A\x03\x02\x02\x02\u021C", "\u021D\x03\x02\x02\x02\u021D\u021B\x03\x02\x02\x02\u021D", "\u021E\x03\x02\x02\x02\u021E\u021F\x03\x02\x02\x02\u021F", "\u0220\x075\x02\x02\u0220c\x03\x02\x02\x02\u0221\u0223", "\x05T+\x02\u0222\u0221\x03\x02\x02\x02\u0222\u0223\x03", "\x02\x02\x02\u0223\u0224\x03\x02\x02\x02\u0224\u0226\x05", "\xCCg\x02\u0225\u0227\x05f4\x02\u0226\u0225\x03\x02\x02", "\x02\u0226\u0227\x03\x02\x02\x02\u0227\u0228\x03\x02\x02", "\x02\u0228\u0229\x07=\x02\x02\u0229\u022D\x05> \x02\u022A", "\u022C\x05\xC4c\x02\u022B\u022A\x03\x02\x02\x02\u022C", "\u022F\x03\x02\x02\x02\u022D\u022B\x03\x02\x02\x02\u022D", "\u022E\x03\x02\x02\x02\u022E\u023B\x03\x02\x02\x02\u022F", "\u022D\x03\x02\x02\x02\u0230\u0232\x05T+\x02\u0231\u0230", "\x03\x02\x02\x02\u0231\u0232\x03\x02\x02\x02\u0232\u0233", "\x03\x02\x02\x02\u0233\u0235\x05\xCCg\x02\u0234\u0236", "\x05f4\x02\u0235\u0234\x03\x02\x02\x02\u0235\u0236\x03", "\x02\x02\x02\u0236\u0237\x03\x02\x02\x02\u0237\u0238\x07", "=\x02\x02\u0238\u0239\b3\x01\x02\u0239\u023B\x03\x02\x02", "\x02\u023A\u0222\x03\x02\x02\x02\u023A\u0231\x03\x02\x02", "\x02\u023Be\x03\x02\x02\x02\u023C\u023E\x078\x02\x02", "\u023D\u023F\x05h5\x02\u023E\u023D\x03\x02\x02\x02\u023F", "\u0240\x03\x02\x02\x02\u0240\u023E\x03\x02\x02\x02\u0240", "\u0241\x03\x02\x02\x02\u0241\u0242\x03\x02\x02\x02\u0242", "\u0243\x079\x02\x02\u0243g\x03\x02\x02\x02\u0244\u0246", "\x05T+\x02\u0245\u0244\x03\x02\x02\x02\u0245\u0246\x03", "\x02\x02\x02\u0246\u0247\x03\x02\x02\x02\u0247\u0248\x05", "\xCCg\x02\u0248\u0249\x07=\x02\x02\u0249\u024B\x05> \x02", "\u024A\u024C\x05<\x1F\x02\u024B\u024A\x03\x02\x02\x02", "\u024B\u024C\x03\x02\x02\x02\u024C\u0250\x03\x02\x02\x02", "\u024D\u024F\x05\xC0a\x02\u024E\u024D\x03\x02\x02\x02", "\u024F\u0252\x03\x02\x02\x02\u0250\u024E\x03\x02\x02\x02", "\u0250\u0251\x03\x02\x02\x02\u0251i\x03\x02\x02\x02", "\u0252\u0250\x03\x02\x02\x02\u0253\u0254\x07\x11\x02\x02", "\u0254\u0255\x07\f\x02\x02\u0255\u0257\x05\xCCg\x02\u0256", "\u0258\x05`1\x02\u0257\u0256\x03\x02\x02\x02\u0257\u0258", "\x03\x02\x02\x02\u0258\u025C\x03\x02\x02\x02\u0259\u025B", "\x05\xACW\x02\u025A\u0259\x03\x02\x02\x02\u025B\u025E", "\x03\x02\x02\x02\u025C\u025A\x03\x02\x02\x02\u025C\u025D", "\x03\x02\x02\x02\u025D\u025F\x03\x02\x02\x02\u025E\u025C", "\x03\x02\x02\x02\u025F\u0260\x05b2\x02\u0260\u0272\x03", "\x02\x02\x02\u0261\u0262\x07\x11\x02\x02\u0262\u0263\x07", "\f\x02\x02\u0263\u0265\x05\xCCg\x02\u0264\u0266\x05`1\x02", "\u0265\u0264\x03\x02\x02\x02\u0265\u0266\x03\x02\x02\x02", "\u0266\u0268\x03\x02\x02\x02\u0267\u0269\x05\xACW\x02", "\u0268\u0267\x03\x02\x02\x02\u0269\u026A\x03\x02\x02\x02", "\u026A\u0268\x03\x02\x02\x02\u026A\u026B\x03\x02\x02\x02", "\u026B\u0272\x03\x02\x02\x02\u026C\u026D\x07\x11\x02\x02", "\u026D\u026E\x07\f\x02\x02\u026E\u026F\x05\xCCg\x02\u026F", "\u0270\x05`1\x02\u0270\u0272\x03\x02\x02\x02\u0271\u0253", "\x03\x02\x02\x02\u0271\u0261\x03\x02\x02\x02\u0271\u026C", "\x03\x02\x02\x02\u0272k\x03\x02\x02\x02\u0273\u0275", "\x05T+\x02\u0274\u0273\x03\x02\x02\x02\u0274\u0275\x03", "\x02\x02\x02\u0275\u0276\x03\x02\x02\x02\u0276\u0277\x07", "\x0F\x02\x02\u0277\u0279\x05\xCCg\x02\u0278\u027A\x05", "`1\x02\u0279\u0278\x03\x02\x02\x02\u0279\u027A\x03\x02", "\x02\x02\u027A\u027E\x03\x02\x02\x02\u027B\u027D\x05\xB0", "Y\x02\u027C\u027B\x03\x02\x02\x02\u027D\u0280\x03\x02", "\x02\x02\u027E\u027C\x03\x02\x02\x02\u027E\u027F\x03\x02", "\x02\x02\u027F\u0282\x03\x02\x02\x02\u0280\u027E\x03\x02", "\x02\x02\u0281\u0283\x05b2\x02\u0282\u0281\x03\x02\x02", "\x02\u0282\u0283\x03\x02\x02\x02\u0283m\x03\x02\x02", "\x02\u0284\u0285\x07\x11\x02\x02\u0285\u0286\x07\x0F\x02", "\x02\u0286\u0288\x05\xCCg\x02\u0287\u0289\x05`1\x02\u0288", "\u0287\x03\x02\x02\x02\u0288\u0289\x03\x02\x02\x02\u0289", "\u028D\x03\x02\x02\x02\u028A\u028C\x05\xB0Y\x02\u028B", "\u028A\x03\x02\x02\x02\u028C\u028F\x03\x02\x02\x02\u028D", "\u028B\x03\x02\x02\x02\u028D\u028E\x03\x02\x02\x02\u028E", "\u0290\x03\x02\x02\x02\u028F\u028D\x03\x02\x02\x02\u0290", "\u0291\x05b2\x02\u0291\u02A3\x03\x02\x02\x02\u0292\u0293", "\x07\x11\x02\x02\u0293\u0294\x07\x0F\x02\x02\u0294\u0296", "\x05\xCCg\x02\u0295\u0297\x05`1\x02\u0296\u0295\x03\x02", "\x02\x02\u0296\u0297\x03\x02\x02\x02\u0297\u0299\x03\x02", "\x02\x02\u0298\u029A\x05\xB0Y\x02\u0299\u0298\x03\x02", "\x02\x02\u029A\u029B\x03\x02\x02\x02\u029B\u0299\x03\x02", "\x02\x02\u029B\u029C\x03\x02\x02\x02\u029C\u02A3\x03\x02", "\x02\x02\u029D\u029E\x07\x11\x02\x02\u029E\u029F\x07\x0F", "\x02\x02\u029F\u02A0\x05\xCCg\x02\u02A0\u02A1\x05`1\x02", "\u02A1\u02A3\x03\x02\x02\x02\u02A2\u0284\x03\x02\x02\x02", "\u02A2\u0292\x03\x02\x02\x02\u02A2\u029D\x03\x02\x02\x02", "\u02A3o\x03\x02\x02\x02\u02A4\u02A6\x05T+\x02\u02A5\u02A4", "\x03\x02\x02\x02\u02A5\u02A6\x03\x02\x02\x02\u02A6\u02A7", "\x03\x02\x02\x02\u02A7\u02A8\x07\x12\x02\x02\u02A8\u02AC", "\x05\xCCg\x02\u02A9\u02AB\x05\xB4[\x02\u02AA\u02A9\x03", "\x02\x02\x02\u02AB\u02AE\x03\x02\x02\x02\u02AC\u02AA\x03", "\x02\x02\x02\u02AC\u02AD\x03\x02\x02\x02\u02AD\u02B0\x03", "\x02\x02\x02\u02AE\u02AC\x03\x02\x02\x02\u02AF\u02B1\x05", "r:\x02\u02B0\u02AF\x03\x02\x02\x02\u02B0\u02B1\x03\x02", "\x02\x02\u02B1q\x03\x02\x02\x02\u02B2\u02B4\x07<\x02", "\x02\u02B3\u02B5\x07@\x02\x02\u02B4\u02B3\x03\x02\x02", "\x02\u02B4\u02B5\x03\x02\x02\x02\u02B5\u02B6\x03\x02\x02", "\x02\u02B6\u02BB\x05@!\x02\u02B7\u02B8\x07@\x02\x02\u02B8", "\u02BA\x05@!\x02\u02B9\u02B7\x03\x02\x02\x02\u02BA\u02BD", "\x03\x02\x02\x02\u02BB\u02B9\x03\x02\x02\x02\u02BB\u02BC", "\x03\x02\x02\x02\u02BCs\x03\x02\x02\x02\u02BD\u02BB", "\x03\x02\x02\x02\u02BE\u02BF\x07\x11\x02\x02\u02BF\u02C0", "\x07\x12\x02\x02\u02C0\u02C4\x05\xCCg\x02\u02C1\u02C3", "\x05\xB4[\x02\u02C2\u02C1\x03\x02\x02\x02\u02C3\u02C6", "\x03\x02\x02\x02\u02C4\u02C2\x03\x02\x02\x02\u02C4\u02C5", "\x03\x02\x02\x02\u02C5\u02C7\x03\x02\x02\x02\u02C6\u02C4", "\x03\x02\x02\x02\u02C7\u02C8\x05r:\x02\u02C8\u02D2\x03", "\x02\x02\x02\u02C9\u02CA\x07\x11\x02\x02\u02CA\u02CB\x07", "\x12\x02\x02\u02CB\u02CD\x05\xCCg\x02\u02CC\u02CE\x05", "\xB4[\x02\u02CD\u02CC\x03\x02\x02\x02\u02CE\u02CF\x03", "\x02\x02\x02\u02CF\u02CD\x03\x02\x02\x02\u02CF\u02D0\x03", "\x02\x02\x02\u02D0\u02D2\x03\x02\x02\x02\u02D1\u02BE\x03", "\x02\x02\x02\u02D1\u02C9\x03\x02\x02\x02\u02D2u\x03", "\x02\x02\x02\u02D3\u02D5\x05T+\x02\u02D4\u02D3\x03\x02", "\x02\x02\u02D4\u02D5\x03\x02\x02\x02\u02D5\u02D6\x03\x02", "\x02\x02\u02D6\u02D7\x07\r\x02\x02\u02D7\u02DB\x05\xCC", "g\x02\u02D8\u02DA\x05\xB8]\x02\u02D9\u02D8\x03\x02\x02", "\x02\u02DA\u02DD\x03\x02\x02\x02\u02DB\u02D9\x03\x02\x02", "\x02\u02DB\u02DC\x03\x02\x02\x02\u02DC\u02DF\x03\x02\x02", "\x02\u02DD\u02DB\x03\x02\x02\x02\u02DE\u02E0\x05x=\x02", "\u02DF\u02DE\x03\x02\x02\x02\u02DF\u02E0\x03\x02\x02\x02", "\u02E0w\x03\x02\x02\x02\u02E1\u02E3\x074\x02\x02\u02E2", "\u02E4\x05z>\x02\u02E3\u02E2\x03\x02\x02\x02\u02E4\u02E5", "\x03\x02\x02\x02\u02E5\u02E3\x03\x02\x02\x02\u02E5\u02E6", "\x03\x02\x02\x02\u02E6\u02E7\x03\x02\x02\x02\u02E7\u02E8", "\x075\x02\x02\u02E8y\x03\x02\x02\x02\u02E9\u02EB\x05", "T+\x02\u02EA\u02E9\x03\x02\x02\x02\u02EA\u02EB\x03\x02", "\x02\x02\u02EB\u02EC\x03\x02\x02\x02\u02EC\u02F0\x05.", "\x18\x02\u02ED\u02EF\x05\xC8e\x02\u02EE\u02ED\x03\x02", "\x02\x02\u02EF\u02F2\x03\x02\x02\x02\u02F0\u02EE\x03\x02", "\x02\x02\u02F0\u02F1\x03\x02\x02\x02\u02F1{\x03\x02", "\x02\x02\u02F2\u02F0\x03\x02\x02\x02\u02F3\u02F4\x07\x11", "\x02\x02\u02F4\u02F5\x07\r\x02\x02\u02F5\u02F9\x05\xCC", "g\x02\u02F6\u02F8\x05\xB8]\x02\u02F7\u02F6\x03\x02\x02", "\x02\u02F8\u02FB\x03\x02\x02\x02\u02F9\u02F7\x03\x02\x02", "\x02\u02F9\u02FA\x03\x02\x02\x02\u02FA\u02FC\x03\x02\x02", "\x02\u02FB\u02F9\x03\x02\x02\x02\u02FC\u02FD\x05x=\x02", "\u02FD\u0307\x03\x02\x02\x02\u02FE\u02FF\x07\x11\x02\x02", "\u02FF\u0300\x07\r\x02\x02\u0300\u0302\x05\xCCg\x02\u0301", "\u0303\x05\xB8]\x02\u0302\u0301\x03\x02\x02\x02\u0303", "\u0304\x03\x02\x02\x02\u0304\u0302\x03\x02\x02\x02\u0304", "\u0305\x03\x02\x02\x02\u0305\u0307\x03\x02\x02\x02\u0306", "\u02F3\x03\x02\x02\x02\u0306\u02FE\x03\x02\x02\x02\u0307", "}\x03\x02\x02\x02\u0308\u030A\x05T+\x02\u0309\u0308\x03", "\x02\x02\x02\u0309\u030A\x03\x02\x02\x02\u030A\u030B\x03", "\x02\x02\x02\u030B\u030C\x07\x0B\x02\x02\u030C\u0310\x05", "\xCCg\x02\u030D\u030F\x05\xBC_\x02\u030E\u030D\x03\x02", "\x02\x02\u030F\u0312\x03\x02\x02\x02\u0310\u030E\x03\x02", "\x02\x02\u0310\u0311\x03\x02\x02\x02\u0311\u0314\x03\x02", "\x02\x02\u0312\u0310\x03\x02\x02\x02\u0313\u0315\x05\x80", "A\x02\u0314\u0313\x03\x02\x02\x02\u0314\u0315\x03\x02", "\x02\x02\u0315\x7F\x03\x02\x02\x02\u0316\u0318\x074", "\x02\x02\u0317\u0319\x05h5\x02\u0318\u0317\x03\x02\x02", "\x02\u0319\u031A\x03\x02\x02\x02\u031A\u0318\x03\x02\x02", "\x02\u031A\u031B\x03\x02\x02\x02\u031B\u031C\x03\x02\x02", "\x02\u031C\u031D\x075\x02\x02\u031D\x81\x03\x02\x02", "\x02\u031E\u031F\x07\x11\x02\x02\u031F\u0320\x07\x0B\x02", "\x02\u0320\u0324\x05\xCCg\x02\u0321\u0323\x05\xBC_\x02", "\u0322\u0321\x03\x02\x02\x02\u0323\u0326\x03\x02\x02\x02", "\u0324\u0322\x03\x02\x02\x02\u0324\u0325\x03\x02\x02\x02", "\u0325\u0327\x03\x02\x02\x02\u0326\u0324\x03\x02\x02\x02", "\u0327\u0328\x05\x80A\x02\u0328\u0332\x03\x02\x02\x02", "\u0329\u032A\x07\x11\x02\x02\u032A\u032B\x07\x0B\x02\x02", "\u032B\u032D\x05\xCCg\x02\u032C\u032E\x05\xBC_\x02\u032D", "\u032C\x03\x02\x02\x02\u032E\u032F\x03\x02\x02\x02\u032F", "\u032D\x03\x02\x02\x02\u032F\u0330\x03\x02\x02\x02\u0330", "\u0332\x03\x02\x02\x02\u0331\u031E\x03\x02\x02\x02\u0331", "\u0329\x03\x02\x02\x02\u0332\x83\x03\x02\x02\x02\u0333", "\u0335\x05T+\x02\u0334\u0333\x03\x02\x02\x02\u0334\u0335", "\x03\x02\x02\x02\u0335\u0336\x03\x02\x02\x02\u0336\u0337", "\x07\x10\x02\x02\u0337\u0338\x07:\x02\x02\u0338\u033A", "\x05\xCCg\x02\u0339\u033B\x05f4\x02\u033A\u0339\x03\x02", "\x02\x02\u033A\u033B\x03\x02\x02\x02\u033B\u033D\x03\x02", "\x02\x02\u033C\u033E\x07\x1A\x02\x02\u033D\u033C\x03\x02", "\x02\x02\u033D\u033E\x03\x02\x02\x02\u033E\u033F\x03\x02", "\x02\x02\u033F\u0340\x07\x19\x02\x02\u0340\u0341\x05\x86", "D\x02\u0341\x85\x03\x02\x02\x02\u0342\u0347\x05\x88", "E\x02\u0343\u0344\x07@\x02\x02\u0344\u0346\x05\x88E\x02", "\u0345\u0343\x03\x02\x02\x02\u0346\u0349\x03\x02\x02\x02", "\u0347\u0345\x03\x02\x02\x02\u0347\u0348\x03\x02\x02\x02", "\u0348\x87\x03\x02\x02\x02\u0349\u0347\x03\x02\x02\x02", "\u034A\u034D\x05\x8AF\x02\u034B\u034D\x05\x8CG\x02\u034C", "\u034A\x03\x02\x02\x02\u034C\u034B\x03\x02\x02\x02\u034D", "\x89\x03\x02\x02\x02\u034E\u034F\t\x05\x02\x02\u034F", "\x8B\x03\x02\x02\x02\u0350\u0351\t\x06\x02\x02\u0351", "\x8D\x03\x02\x02\x02\u0352\u0353\x07\x03\x02\x02\u0353", "\x8F\x03\x02\x02\x02\u0354\u0355\x07\x04\x02\x02\u0355", "\x91\x03\x02\x02\x02\u0356\u0357\x07\x05\x02\x02\u0357", "\u0358\x07]\x02\x02\u0358\u0359\x07R\x02\x02\u0359\u035A", "\x07Z\x02\x02\u035A\u035B\x07Y\x02\x02\u035B\u035C\x05", "\x9EP\x02\u035C\u035D\x07Y\x02\x02\u035D\u035E\x07^\x02", "\x02\u035E\x93\x03\x02\x02\x02\u035F\u0360\x07\x06\x02", "\x02\u0360\u0361\x07]\x02\x02\u0361\u0362\x07R\x02\x02", "\u0362\u0363\x07Z\x02\x02\u0363\u0364\x07Y\x02\x02\u0364", "\u0365\x05\x9EP\x02\u0365\u0366\x07Y\x02\x02\u0366\u0367", "\x07^\x02\x02\u0367\x95\x03\x02\x02\x02\u0368\u0369", "\x07\x07\x02\x02\u0369\u036A\x07]\x02\x02\u036A\u036B", "\x07R\x02\x02\u036B\u036C\x07Z\x02\x02\u036C\u036D\x07", "Y\x02\x02\u036D\u036E\x05\x9EP\x02\u036E\u036F\x07Y\x02", "\x02\u036F\u0370\x07^\x02\x02\u0370\u037E\x03\x02\x02", "\x02\u0371\u0372\x07\x07\x02\x02\u0372\u0373\x07]\x02", "\x02\u0373\u0374\x07R\x02\x02\u0374\u0375\x07Z\x02\x02", "\u0375\u0376\x07Y\x02\x02\u0376\u0377\x05\x9EP\x02\u0377", "\u0378\x07Y\x02\x02\u0378\u0379\x07T\x02\x02\u0379\u037A", "\x07Z\x02\x02\u037A\u037B\x05\xD0i\x02\u037B\u037C\x07", "^\x02\x02\u037C\u037E\x03\x02\x02\x02\u037D\u0368\x03", "\x02\x02\x02\u037D\u0371\x03\x02\x02\x02\u037E\x97\x03", "\x02\x02\x02\u037F\u0380\x07\b\x02\x02\u0380\x99\x03", "\x02\x02\x02\u0381\u0382\x07\t\x02\x02\u0382\u0383\x07", "]\x02\x02\u0383\u0384\x07S\x02\x02\u0384\u0385\x07Z\x02", "\x02\u0385\u0386\x07Y\x02\x02\u0386\u0387\x05\xCEh\x02", "\u0387\u0388\x07Y\x02\x02\u0388\u0389\x07^\x02\x02\u0389", "\x9B\x03\x02\x02\x02\u038A\u038B\x07\n\x02\x02\u038B", "\u038C\x07p\x02\x02\u038C\x9D\x03\x02\x02\x02\u038D", "\u038F\x05\xA0Q\x02\u038E\u038D\x03\x02\x02\x02\u038F", "\u0390\x03\x02\x02\x02\u0390\u038E\x03\x02\x02\x02\u0390", "\u0391\x03\x02\x02\x02\u0391\x9F\x03\x02\x02\x02\u0392", "\u0394\x05\xCEh\x02\u0393\u0395\x05\xA2R\x02\u0394\u0393", "\x03\x02\x02\x02\u0394\u0395\x03\x02\x02\x02\u0395\xA1", "\x03\x02\x02\x02\u0396\u0397\x07[\x02\x02\u0397\u0398", "\x05\x9EP\x02\u0398\u0399\x07\\\x02\x02\u0399\xA3\x03", "\x02\x02\x02\u039A\u039D\x05F$\x02\u039B\u039D\x05\xA6", "T\x02\u039C\u039A\x03\x02\x02\x02\u039C\u039B\x03\x02", "\x02\x02\u039D\xA5\x03\x02\x02\x02\u039E\u039F\x05\x9C", "O\x02\u039F\xA7\x03\x02\x02\x02\u03A0\u03A3\x05F$\x02", "\u03A1\u03A3\x05\xAAV\x02\u03A2\u03A0\x03\x02\x02\x02", "\u03A2\u03A1\x03\x02\x02\x02\u03A3\xA9\x03\x02\x02\x02", "\u03A4\u03A5\x05\x90I\x02\u03A5\xAB\x03\x02\x02\x02", "\u03A6\u03A9\x05F$\x02\u03A7\u03A9\x05\xAEX\x02\u03A8\u03A6", "\x03\x02\x02\x02\u03A8\u03A7\x03\x02\x02\x02\u03A9\xAD", "\x03\x02\x02\x02\u03AA\u03AE\x05\x96L\x02\u03AB\u03AE", "\x05\x98M\x02\u03AC\u03AE\x05\x90I\x02\u03AD\u03AA\x03", "\x02\x02\x02\u03AD\u03AB\x03\x02\x02\x02\u03AD\u03AC\x03", "\x02\x02\x02\u03AE\xAF\x03\x02\x02\x02\u03AF\u03B2\x05", "F$\x02\u03B0\u03B2\x05\xB2Z\x02\u03B1\u03AF\x03\x02\x02", "\x02\u03B1\u03B0\x03\x02\x02\x02\u03B2\xB1\x03\x02\x02", "\x02\u03B3\u03B6\x05\x90I\x02\u03B4\u03B6\x05\x96L\x02", "\u03B5\u03B3\x03\x02\x02\x02\u03B5\u03B4\x03\x02\x02\x02", "\u03B6\xB3\x03\x02\x02\x02\u03B7\u03BA\x05F$\x02\u03B8", "\u03BA\x05\xB6\\\x02\u03B9\u03B7\x03\x02\x02\x02\u03B9", "\u03B8\x03\x02\x02\x02\u03BA\xB5\x03\x02\x02\x02\u03BB", "\u03BC\x05\x90I\x02\u03BC\xB7\x03\x02\x02\x02\u03BD", "\u03C0\x05F$\x02\u03BE\u03C0\x05\xBA^\x02\u03BF\u03BD\x03", "\x02\x02\x02\u03BF\u03BE\x03\x02\x02\x02\u03C0\xB9\x03", "\x02\x02\x02\u03C1\u03C2\x05\x90I\x02\u03C2\xBB\x03", "\x02\x02\x02\u03C3\u03C6\x05F$\x02\u03C4\u03C6\x05\xBE", "`\x02\u03C5\u03C3\x03\x02\x02\x02\u03C5\u03C4\x03\x02", "\x02\x02\u03C6\xBD\x03\x02\x02\x02\u03C7\u03C8\x05\x90", "I\x02\u03C8\xBF\x03\x02\x02\x02\u03C9\u03CC\x05F$\x02", "\u03CA\u03CC\x05\xC2b\x02\u03CB\u03C9\x03\x02\x02\x02", "\u03CB\u03CA\x03\x02\x02\x02\u03CC\xC1\x03\x02\x02\x02", "\u03CD\u03CE\x05\x90I\x02\u03CE\xC3\x03\x02\x02\x02", "\u03CF\u03D2\x05F$\x02\u03D0\u03D2\x05\xC6d\x02\u03D1\u03CF", "\x03\x02\x02\x02\u03D1\u03D0\x03\x02\x02\x02\u03D2\xC5", "\x03\x02\x02\x02\u03D3\u03DA\x05\x8EH\x02\u03D4\u03DA", "\x05\x92J\x02\u03D5\u03DA\x05\x94K\x02\u03D6\u03DA\x05", "\x98M\x02\u03D7\u03DA\x05\x90I\x02\u03D8\u03DA\x05\x9A", "N\x02\u03D9\u03D3\x03\x02\x02\x02\u03D9\u03D4\x03\x02", "\x02\x02\u03D9\u03D5\x03\x02\x02\x02\u03D9\u03D6\x03\x02", "\x02\x02\u03D9\u03D7\x03\x02\x02\x02\u03D9\u03D8\x03\x02", "\x02\x02\u03DA\xC7\x03\x02\x02\x02\u03DB\u03DE\x05F", "$\x02\u03DC\u03DE\x05\xCAf\x02\u03DD\u03DB\x03\x02\x02", "\x02\u03DD\u03DC\x03\x02\x02\x02\u03DE\xC9\x03\x02\x02", "\x02\u03DF\u03E0\x05\x90I\x02\u03E0\xCB\x03\x02\x02", "\x02\u03E1\u03E4\x05\xD2j\x02\u03E2\u03E4\x07F\x02\x02", "\u03E3\u03E1\x03\x02\x02\x02\u03E3\u03E2\x03\x02\x02\x02", "\u03E4\xCD\x03\x02\x02\x02\u03E5\u03E8\x05\xD4k\x02", "\u03E6\u03E8\x07X\x02\x02\u03E7\u03E5\x03\x02\x02\x02", "\u03E7\u03E6\x03\x02\x02\x02\u03E8\xCF\x03\x02\x02\x02", "\u03E9\u03EA\t\x07\x02\x02\u03EA\xD1\x03\x02\x02\x02", "\u03EB\u03EC\t\b\x02\x02\u03EC\xD3\x03\x02\x02\x02\u03ED", "\u03EE\t\t\x02\x02\u03EE\xD5\x03\x02\x02\x02|\xD9\xE0", "\xE4\xE8\xEB\xEE\xF3\xFB\u0102\u0105\u0109\u010C\u010F\u0115", "\u0123\u0129\u0134\u0137\u0144\u0158\u015C\u0162\u0172\u017A\u0181\u0185", "\u0187\u0192\u0197\u019C\u01A0\u01A3\u01A9\u01B0\u01BD\u01C4\u01CD\u01CF", "\u01DD\u01E5\u01E8\u01EF\u01F8\u01FB\u0200\u0205\u0209\u020D\u0211\u0216", "\u021D\u0222\u0226\u022D\u0231\u0235\u023A\u0240\u0245\u024B\u0250\u0257", "\u025C\u0265\u026A\u0271\u0274\u0279\u027E\u0282\u0288\u028D\u0296\u029B", "\u02A2\u02A5\u02AC\u02B0\u02B4\u02BB\u02C4\u02CF\u02D1\u02D4\u02DB\u02DF", "\u02E5\u02EA\u02F0\u02F9\u0304\u0306\u0309\u0310\u0314\u031A\u0324\u032F", "\u0331\u0334\u033A\u033D\u0347\u034C\u037D\u0390\u0394\u039C\u03A2\u03A8", "\u03AD\u03B1\u03B5\u03B9\u03BF\u03C5\u03CB\u03D1\u03D9\u03DD\u03E3\u03E7"].join("");
	var atn = new _antlr["default"].atn.ATNDeserializer().deserialize(serializedATN);
	var decisionsToDFA = atn.decisionToState.map(function (ds, index) {
	  return new _antlr["default"].dfa.DFA(ds, index);
	});
	var sharedContextCache = new _antlr["default"].PredictionContextCache();

	var GraphQLFederationParser = /*#__PURE__*/function (_antlr4$Parser) {
	  _inherits(GraphQLFederationParser, _antlr4$Parser);

	  var _super = _createSuper(GraphQLFederationParser);

	  function GraphQLFederationParser(input) {
	    var _this;

	    _classCallCheck(this, GraphQLFederationParser);

	    _this = _super.call(this, input);
	    _this._interp = new _antlr["default"].atn.ParserATNSimulator(_assertThisInitialized(_this), atn, decisionsToDFA, sharedContextCache);
	    _this.ruleNames = GraphQLFederationParser.ruleNames;
	    _this.literalNames = GraphQLFederationParser.literalNames;
	    _this.symbolicNames = GraphQLFederationParser.symbolicNames;
	    return _this;
	  }

	  _createClass(GraphQLFederationParser, [{
	    key: "atn",
	    get: function get() {
	      return atn;
	    }
	  }, {
	    key: "document",
	    value: function document() {
	      var localctx = new DocumentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 0, GraphQLFederationParser.RULE_document);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 213;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 212;
	          this.definition();
	          this.state = 215;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD)) !== 0 || (_la - 50 & ~0x1f) == 0 && (1 << _la - 50 & (1 << GraphQLFederationParser.LBRACE - 50 | 1 << GraphQLFederationParser.STRING - 50 | 1 << GraphQLFederationParser.BLOCK_STRING - 50)) !== 0);

	        this.state = 217;
	        this.match(GraphQLFederationParser.EOF);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "definition",
	    value: function definition() {
	      var localctx = new DefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 2, GraphQLFederationParser.RULE_definition);

	      try {
	        this.state = 222;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.QUERY_KEYWORD:
	          case GraphQLFederationParser.MUTATION_KEYWORD:
	          case GraphQLFederationParser.SUBSCRIPTION_KEYWORD:
	          case GraphQLFederationParser.FRAGMENT_KEYWORD:
	          case GraphQLFederationParser.LBRACE:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 219;
	            this.executableDefinition();
	            break;

	          case GraphQLFederationParser.INPUT_KEYWORD:
	          case GraphQLFederationParser.TYPE_KEYWORD:
	          case GraphQLFederationParser.ENUM_KEYWORD:
	          case GraphQLFederationParser.SCALAR_KEYWORD:
	          case GraphQLFederationParser.INTERFACE_KEYWORD:
	          case GraphQLFederationParser.DIRECTIVE_KEYWORD:
	          case GraphQLFederationParser.UNION_KEYWORD:
	          case GraphQLFederationParser.SCHEMA_KEYWORD:
	          case GraphQLFederationParser.STRING:
	          case GraphQLFederationParser.BLOCK_STRING:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 220;
	            this.typeSystemDefinition();
	            break;

	          case GraphQLFederationParser.EXTEND_KEYWORD:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 221;
	            this.typeSystemExtension();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "executableDefinition",
	    value: function executableDefinition() {
	      var localctx = new ExecutableDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 4, GraphQLFederationParser.RULE_executableDefinition);

	      try {
	        this.state = 226;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.QUERY_KEYWORD:
	          case GraphQLFederationParser.MUTATION_KEYWORD:
	          case GraphQLFederationParser.SUBSCRIPTION_KEYWORD:
	          case GraphQLFederationParser.LBRACE:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 224;
	            this.operationDefinition();
	            break;

	          case GraphQLFederationParser.FRAGMENT_KEYWORD:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 225;
	            this.fragmentDefinition();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "operationDefinition",
	    value: function operationDefinition() {
	      var localctx = new OperationDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 6, GraphQLFederationParser.RULE_operationDefinition);
	      var _la = 0; // Token type

	      try {
	        this.state = 241;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.QUERY_KEYWORD:
	          case GraphQLFederationParser.MUTATION_KEYWORD:
	          case GraphQLFederationParser.SUBSCRIPTION_KEYWORD:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 228;
	            this.operationType();
	            this.state = 230;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32)) !== 0 || (_la - 68 & ~0x1f) == 0 && (1 << _la - 68 & (1 << GraphQLFederationParser.NAME - 68 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 68 | 1 << GraphQLFederationParser.FROM_KEYWORD - 68 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 68)) !== 0) {
	              this.state = 229;
	              this.name();
	            }

	            this.state = 233;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.LPAREN) {
	              this.state = 232;
	              this.variableDefinitions();
	            }

	            this.state = 236;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.AT) {
	              this.state = 235;
	              this.directives();
	            }

	            this.state = 238;
	            this.selectionSet();
	            break;

	          case GraphQLFederationParser.LBRACE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 240;
	            this.selectionSet();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "operationType",
	    value: function operationType() {
	      var localctx = new OperationTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 8, GraphQLFederationParser.RULE_operationType);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 243;
	        _la = this._input.LA(1);

	        if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      var localctx = new SelectionSetContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 10, GraphQLFederationParser.RULE_selectionSet);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 245;
	        this.match(GraphQLFederationParser.LBRACE);
	        this.state = 247;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 246;
	          this.selection();
	          this.state = 249;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ELLIPSIS - 32)) !== 0 || (_la - 68 & ~0x1f) == 0 && (1 << _la - 68 & (1 << GraphQLFederationParser.NAME - 68 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 68 | 1 << GraphQLFederationParser.FROM_KEYWORD - 68 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 68)) !== 0);

	        this.state = 251;
	        this.match(GraphQLFederationParser.RBRACE);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "selection",
	    value: function selection() {
	      var localctx = new SelectionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 12, GraphQLFederationParser.RULE_selection);

	      try {
	        this.state = 256;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 8, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 253;
	            this.field();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 254;
	            this.fragmentSpread();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 255;
	            this.inlineFragment();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "field",
	    value: function field() {
	      var localctx = new FieldContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 14, GraphQLFederationParser.RULE_field);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 259;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 9, this._ctx);

	        if (la_ === 1) {
	          this.state = 258;
	          this.alias();
	        }

	        this.state = 261;
	        this.name();
	        this.state = 263;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.LPAREN) {
	          this.state = 262;
	          this.arguments();
	        }

	        this.state = 266;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.AT) {
	          this.state = 265;
	          this.directives();
	        }

	        this.state = 269;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.LBRACE) {
	          this.state = 268;
	          this.selectionSet();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "arguments",
	    value: function _arguments() {
	      var localctx = new ArgumentsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 16, GraphQLFederationParser.RULE_arguments);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 271;
	        this.match(GraphQLFederationParser.LPAREN);
	        this.state = 273;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 272;
	          this.argument();
	          this.state = 275;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32)) !== 0 || (_la - 68 & ~0x1f) == 0 && (1 << _la - 68 & (1 << GraphQLFederationParser.NAME - 68 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 68 | 1 << GraphQLFederationParser.FROM_KEYWORD - 68 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 68)) !== 0);

	        this.state = 277;
	        this.match(GraphQLFederationParser.RPAREN);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "argument",
	    value: function argument() {
	      var localctx = new ArgumentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 18, GraphQLFederationParser.RULE_argument);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 279;
	        this.name();
	        this.state = 280;
	        this.match(GraphQLFederationParser.COLON);
	        this.state = 281;
	        this.value();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "alias",
	    value: function alias() {
	      var localctx = new AliasContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 20, GraphQLFederationParser.RULE_alias);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 283;
	        this.name();
	        this.state = 284;
	        this.match(GraphQLFederationParser.COLON);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fragmentSpread",
	    value: function fragmentSpread() {
	      var localctx = new FragmentSpreadContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 22, GraphQLFederationParser.RULE_fragmentSpread);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 286;
	        this.match(GraphQLFederationParser.ELLIPSIS);
	        this.state = 287;
	        this.fragmentName();
	        this.state = 289;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.AT) {
	          this.state = 288;
	          this.directives();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fragmentDefinition",
	    value: function fragmentDefinition() {
	      var localctx = new FragmentDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 24, GraphQLFederationParser.RULE_fragmentDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 291;
	        this.match(GraphQLFederationParser.FRAGMENT_KEYWORD);
	        this.state = 292;
	        this.fragmentName();
	        this.state = 293;
	        this.typeCondition();
	        this.state = 295;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.AT) {
	          this.state = 294;
	          this.directives();
	        }

	        this.state = 297;
	        this.selectionSet();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fragmentName",
	    value: function fragmentName() {
	      var localctx = new FragmentNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 26, GraphQLFederationParser.RULE_fragmentName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 299;
	        this.name();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeCondition",
	    value: function typeCondition() {
	      var localctx = new TypeConditionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 28, GraphQLFederationParser.RULE_typeCondition);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 301;
	        this.match(GraphQLFederationParser.ON_KEYWORD);
	        this.state = 302;
	        this.namedType();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inlineFragment",
	    value: function inlineFragment() {
	      var localctx = new InlineFragmentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 30, GraphQLFederationParser.RULE_inlineFragment);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 304;
	        this.match(GraphQLFederationParser.ELLIPSIS);
	        this.state = 306;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.ON_KEYWORD) {
	          this.state = 305;
	          this.typeCondition();
	        }

	        this.state = 309;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.AT) {
	          this.state = 308;
	          this.directives();
	        }

	        this.state = 311;
	        this.selectionSet();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "value",
	    value: function value() {
	      var localctx = new ValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 32, GraphQLFederationParser.RULE_value);

	      try {
	        this.state = 322;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.DOLLAR:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 313;
	            this.variable();
	            break;

	          case GraphQLFederationParser.INT:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 314;
	            this.intValue();
	            break;

	          case GraphQLFederationParser.FLOAT:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 315;
	            this.floatValue();
	            break;

	          case GraphQLFederationParser.STRING:
	          case GraphQLFederationParser.BLOCK_STRING:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 316;
	            this.stringValue();
	            break;

	          case GraphQLFederationParser.TRUE:
	          case GraphQLFederationParser.FALSE:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 317;
	            this.booleanValue();
	            break;

	          case GraphQLFederationParser.NULL:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 318;
	            this.nullValue();
	            break;

	          case GraphQLFederationParser.INPUT_KEYWORD:
	          case GraphQLFederationParser.TYPE_KEYWORD:
	          case GraphQLFederationParser.ENUM_KEYWORD:
	          case GraphQLFederationParser.SCALAR_KEYWORD:
	          case GraphQLFederationParser.INTERFACE_KEYWORD:
	          case GraphQLFederationParser.DIRECTIVE_KEYWORD:
	          case GraphQLFederationParser.EXTEND_KEYWORD:
	          case GraphQLFederationParser.UNION_KEYWORD:
	          case GraphQLFederationParser.IMPLEMENTS_KEYWORD:
	          case GraphQLFederationParser.QUERY_KEYWORD:
	          case GraphQLFederationParser.MUTATION_KEYWORD:
	          case GraphQLFederationParser.SUBSCRIPTION_KEYWORD:
	          case GraphQLFederationParser.SCHEMA_KEYWORD:
	          case GraphQLFederationParser.FRAGMENT_KEYWORD:
	          case GraphQLFederationParser.ON_KEYWORD:
	          case GraphQLFederationParser.REPEATABLE_KEYWORD:
	          case GraphQLFederationParser.INPUT_LOCATION:
	          case GraphQLFederationParser.TYPE_LOCATION:
	          case GraphQLFederationParser.ENUM_LOCATION:
	          case GraphQLFederationParser.SCALAR_LOCATION:
	          case GraphQLFederationParser.INTERFACE_LOCATION:
	          case GraphQLFederationParser.DIRECTIVE_LOCATION:
	          case GraphQLFederationParser.EXTEND_LOCATION:
	          case GraphQLFederationParser.UNION_LOCATION:
	          case GraphQLFederationParser.IMPLEMENTS_LOCATION:
	          case GraphQLFederationParser.QUERY_LOCATION:
	          case GraphQLFederationParser.MUTATION_LOCATION:
	          case GraphQLFederationParser.SUBSCRIPTION_LOCATION:
	          case GraphQLFederationParser.SCHEMA_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_LOCATION:
	          case GraphQLFederationParser.FIELD_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION:
	          case GraphQLFederationParser.INLINE_FRAGMENT_LOCATION:
	          case GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION:
	          case GraphQLFederationParser.OBJECT_LOCATION:
	          case GraphQLFederationParser.FIELD_DEFINITION_LOCATION:
	          case GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION:
	          case GraphQLFederationParser.ENUM_VALUE_LOCATION:
	          case GraphQLFederationParser.INPUT_OBJECT_LOCATION:
	          case GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION:
	          case GraphQLFederationParser.NAME:
	          case GraphQLFederationParser.FIELDS_KEYWORD:
	          case GraphQLFederationParser.FROM_KEYWORD:
	          case GraphQLFederationParser.RESOLVABLE_KEYWORD:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 319;
	            this.enumValue();
	            break;

	          case GraphQLFederationParser.LBRACKET:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 320;
	            this.listValue();
	            break;

	          case GraphQLFederationParser.LBRACE:
	            this.enterOuterAlt(localctx, 9);
	            this.state = 321;
	            this.objectValue();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "intValue",
	    value: function intValue() {
	      var localctx = new IntValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 34, GraphQLFederationParser.RULE_intValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 324;
	        this.match(GraphQLFederationParser.INT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "floatValue",
	    value: function floatValue() {
	      var localctx = new FloatValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 36, GraphQLFederationParser.RULE_floatValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 326;
	        this.match(GraphQLFederationParser.FLOAT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "booleanValue",
	    value: function booleanValue() {
	      var localctx = new BooleanValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 38, GraphQLFederationParser.RULE_booleanValue);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 328;
	        _la = this._input.LA(1);

	        if (!(_la === GraphQLFederationParser.TRUE || _la === GraphQLFederationParser.FALSE)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "stringValue",
	    value: function stringValue() {
	      var localctx = new StringValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 40, GraphQLFederationParser.RULE_stringValue);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 330;
	        _la = this._input.LA(1);

	        if (!(_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "nullValue",
	    value: function nullValue() {
	      var localctx = new NullValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 42, GraphQLFederationParser.RULE_nullValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 332;
	        this.match(GraphQLFederationParser.NULL);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValue",
	    value: function enumValue() {
	      var localctx = new EnumValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 44, GraphQLFederationParser.RULE_enumValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 334;
	        this.name();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "listValue",
	    value: function listValue() {
	      var localctx = new ListValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 46, GraphQLFederationParser.RULE_listValue);
	      var _la = 0; // Token type

	      try {
	        this.state = 346;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 20, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 336;
	            this.match(GraphQLFederationParser.LBRACKET);
	            this.state = 337;
	            this.match(GraphQLFederationParser.RBRACKET);
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 338;
	            this.match(GraphQLFederationParser.LBRACKET);
	            this.state = 340;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 339;
	              this.value();
	              this.state = 342;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.LBRACE - 32 | 1 << GraphQLFederationParser.LBRACKET - 32 | 1 << GraphQLFederationParser.DOLLAR - 32)) !== 0 || (_la - 65 & ~0x1f) == 0 && (1 << _la - 65 & (1 << GraphQLFederationParser.TRUE - 65 | 1 << GraphQLFederationParser.FALSE - 65 | 1 << GraphQLFederationParser.NULL - 65 | 1 << GraphQLFederationParser.NAME - 65 | 1 << GraphQLFederationParser.STRING - 65 | 1 << GraphQLFederationParser.BLOCK_STRING - 65 | 1 << GraphQLFederationParser.FLOAT - 65 | 1 << GraphQLFederationParser.INT - 65 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 65 | 1 << GraphQLFederationParser.FROM_KEYWORD - 65 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 65)) !== 0);

	            this.state = 344;
	            this.match(GraphQLFederationParser.RBRACKET);
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectValue",
	    value: function objectValue() {
	      var localctx = new ObjectValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 48, GraphQLFederationParser.RULE_objectValue);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 348;
	        this.match(GraphQLFederationParser.LBRACE);
	        this.state = 352;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32)) !== 0 || (_la - 68 & ~0x1f) == 0 && (1 << _la - 68 & (1 << GraphQLFederationParser.NAME - 68 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 68 | 1 << GraphQLFederationParser.FROM_KEYWORD - 68 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 68)) !== 0) {
	          this.state = 349;
	          this.objectField();
	          this.state = 354;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 355;
	        this.match(GraphQLFederationParser.RBRACE);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectField",
	    value: function objectField() {
	      var localctx = new ObjectFieldContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 50, GraphQLFederationParser.RULE_objectField);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 357;
	        this.name();
	        this.state = 358;
	        this.match(GraphQLFederationParser.COLON);
	        this.state = 359;
	        this.value();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "variable",
	    value: function variable() {
	      var localctx = new VariableContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 52, GraphQLFederationParser.RULE_variable);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 361;
	        this.match(GraphQLFederationParser.DOLLAR);
	        this.state = 362;
	        this.name();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "variableDefinitions",
	    value: function variableDefinitions() {
	      var localctx = new VariableDefinitionsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 54, GraphQLFederationParser.RULE_variableDefinitions);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 364;
	        this.match(GraphQLFederationParser.LPAREN);
	        this.state = 366;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 365;
	          this.variableDefinition();
	          this.state = 368;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while (_la === GraphQLFederationParser.DOLLAR);

	        this.state = 370;
	        this.match(GraphQLFederationParser.RPAREN);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "variableDefinition",
	    value: function variableDefinition() {
	      var localctx = new VariableDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 56, GraphQLFederationParser.RULE_variableDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 372;
	        this.variable();
	        this.state = 373;
	        this.match(GraphQLFederationParser.COLON);
	        this.state = 374;
	        this.type_();
	        this.state = 376;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.EQ) {
	          this.state = 375;
	          this.defaultValue();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "defaultValue",
	    value: function defaultValue() {
	      var localctx = new DefaultValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 58, GraphQLFederationParser.RULE_defaultValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 378;
	        this.match(GraphQLFederationParser.EQ);
	        this.state = 379;
	        this.value();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      var localctx = new Type_Context(this, this._ctx, this.state);
	      this.enterRule(localctx, 60, GraphQLFederationParser.RULE_type_);
	      var _la = 0; // Token type

	      try {
	        this.state = 389;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.INPUT_KEYWORD:
	          case GraphQLFederationParser.TYPE_KEYWORD:
	          case GraphQLFederationParser.ENUM_KEYWORD:
	          case GraphQLFederationParser.SCALAR_KEYWORD:
	          case GraphQLFederationParser.INTERFACE_KEYWORD:
	          case GraphQLFederationParser.DIRECTIVE_KEYWORD:
	          case GraphQLFederationParser.EXTEND_KEYWORD:
	          case GraphQLFederationParser.UNION_KEYWORD:
	          case GraphQLFederationParser.IMPLEMENTS_KEYWORD:
	          case GraphQLFederationParser.QUERY_KEYWORD:
	          case GraphQLFederationParser.MUTATION_KEYWORD:
	          case GraphQLFederationParser.SUBSCRIPTION_KEYWORD:
	          case GraphQLFederationParser.SCHEMA_KEYWORD:
	          case GraphQLFederationParser.FRAGMENT_KEYWORD:
	          case GraphQLFederationParser.ON_KEYWORD:
	          case GraphQLFederationParser.REPEATABLE_KEYWORD:
	          case GraphQLFederationParser.INPUT_LOCATION:
	          case GraphQLFederationParser.TYPE_LOCATION:
	          case GraphQLFederationParser.ENUM_LOCATION:
	          case GraphQLFederationParser.SCALAR_LOCATION:
	          case GraphQLFederationParser.INTERFACE_LOCATION:
	          case GraphQLFederationParser.DIRECTIVE_LOCATION:
	          case GraphQLFederationParser.EXTEND_LOCATION:
	          case GraphQLFederationParser.UNION_LOCATION:
	          case GraphQLFederationParser.IMPLEMENTS_LOCATION:
	          case GraphQLFederationParser.QUERY_LOCATION:
	          case GraphQLFederationParser.MUTATION_LOCATION:
	          case GraphQLFederationParser.SUBSCRIPTION_LOCATION:
	          case GraphQLFederationParser.SCHEMA_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_LOCATION:
	          case GraphQLFederationParser.FIELD_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION:
	          case GraphQLFederationParser.INLINE_FRAGMENT_LOCATION:
	          case GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION:
	          case GraphQLFederationParser.OBJECT_LOCATION:
	          case GraphQLFederationParser.FIELD_DEFINITION_LOCATION:
	          case GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION:
	          case GraphQLFederationParser.ENUM_VALUE_LOCATION:
	          case GraphQLFederationParser.INPUT_OBJECT_LOCATION:
	          case GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION:
	          case GraphQLFederationParser.NAME:
	          case GraphQLFederationParser.FIELDS_KEYWORD:
	          case GraphQLFederationParser.FROM_KEYWORD:
	          case GraphQLFederationParser.RESOLVABLE_KEYWORD:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 381;
	            this.namedType();
	            this.state = 383;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.EXCL) {
	              this.state = 382;
	              this.match(GraphQLFederationParser.EXCL);
	            }

	            break;

	          case GraphQLFederationParser.LBRACKET:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 385;
	            this.listType();
	            this.state = 387;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.EXCL) {
	              this.state = 386;
	              this.match(GraphQLFederationParser.EXCL);
	            }

	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "namedType",
	    value: function namedType() {
	      var localctx = new NamedTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 62, GraphQLFederationParser.RULE_namedType);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 391;
	        this.name();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "listType",
	    value: function listType() {
	      var localctx = new ListTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 64, GraphQLFederationParser.RULE_listType);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 393;
	        this.match(GraphQLFederationParser.LBRACKET);
	        this.state = 394;
	        this.type_();
	        this.state = 395;
	        this.match(GraphQLFederationParser.RBRACKET);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      var localctx = new DirectivesContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 66, GraphQLFederationParser.RULE_directives);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 398;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 397;
	          this.directive();
	          this.state = 400;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while (_la === GraphQLFederationParser.AT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directive",
	    value: function directive() {
	      var localctx = new DirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 68, GraphQLFederationParser.RULE_directive);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 402;
	        this.match(GraphQLFederationParser.AT);
	        this.state = 403;
	        this.name();
	        this.state = 405;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.LPAREN) {
	          this.state = 404;
	          this.arguments();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeSystemDefinition",
	    value: function typeSystemDefinition() {
	      var localctx = new TypeSystemDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 70, GraphQLFederationParser.RULE_typeSystemDefinition);

	      try {
	        this.state = 410;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 29, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 407;
	            this.schemaDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 408;
	            this.typeDefinition();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 409;
	            this.directiveDefinition();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeSystemExtension",
	    value: function typeSystemExtension() {
	      var localctx = new TypeSystemExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 72, GraphQLFederationParser.RULE_typeSystemExtension);

	      try {
	        this.state = 414;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 30, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 412;
	            this.schemaExtension();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 413;
	            this.typeExtension();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "schemaDefinition",
	    value: function schemaDefinition() {
	      var localctx = new SchemaDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 74, GraphQLFederationParser.RULE_schemaDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 417;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 416;
	          this.description();
	        }

	        this.state = 419;
	        this.match(GraphQLFederationParser.SCHEMA_KEYWORD);
	        this.state = 423;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.LINK || _la === GraphQLFederationParser.AT) {
	          this.state = 420;
	          this.schemaDirective();
	          this.state = 425;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 426;
	        this.match(GraphQLFederationParser.LBRACE);
	        this.state = 428;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 427;
	          this.rootOperationTypeDefinition();
	          this.state = 430;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD)) !== 0);

	        this.state = 432;
	        this.match(GraphQLFederationParser.RBRACE);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "rootOperationTypeDefinition",
	    value: function rootOperationTypeDefinition() {
	      var localctx = new RootOperationTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 76, GraphQLFederationParser.RULE_rootOperationTypeDefinition);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 434;
	        this.operationType();
	        this.state = 435;
	        this.match(GraphQLFederationParser.COLON);
	        this.state = 436;
	        this.namedType();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "schemaExtension",
	    value: function schemaExtension() {
	      var localctx = new SchemaExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 78, GraphQLFederationParser.RULE_schemaExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 461;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 37, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 438;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 439;
	            this.match(GraphQLFederationParser.SCHEMA_KEYWORD);
	            this.state = 443;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            while (_la === GraphQLFederationParser.LINK || _la === GraphQLFederationParser.AT) {
	              this.state = 440;
	              this.schemaDirective();
	              this.state = 445;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            }

	            this.state = 446;
	            this.match(GraphQLFederationParser.LBRACE);
	            this.state = 448;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 447;
	              this.operationTypeDefinition();
	              this.state = 450;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD)) !== 0);

	            this.state = 452;
	            this.match(GraphQLFederationParser.RBRACE);
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 454;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 455;
	            this.match(GraphQLFederationParser.SCHEMA_KEYWORD);
	            this.state = 457;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 456;
	              this.schemaDirective();
	              this.state = 459;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while (_la === GraphQLFederationParser.LINK || _la === GraphQLFederationParser.AT);

	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "operationTypeDefinition",
	    value: function operationTypeDefinition() {
	      var localctx = new OperationTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 80, GraphQLFederationParser.RULE_operationTypeDefinition);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 463;
	        this.operationType();
	        this.state = 464;
	        this.match(GraphQLFederationParser.COLON);
	        this.state = 465;
	        this.namedType();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      var localctx = new DescriptionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 82, GraphQLFederationParser.RULE_description);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 467;
	        this.stringValue();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeDefinition",
	    value: function typeDefinition() {
	      var localctx = new TypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 84, GraphQLFederationParser.RULE_typeDefinition);

	      try {
	        this.state = 475;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 38, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 469;
	            this.scalarTypeDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 470;
	            this.objectTypeDefinition();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 471;
	            this.interfaceTypeDefinition();
	            break;

	          case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 472;
	            this.unionTypeDefinition();
	            break;

	          case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 473;
	            this.enumTypeDefinition();
	            break;

	          case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 474;
	            this.inputObjectTypeDefinition();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeExtension",
	    value: function typeExtension() {
	      var localctx = new TypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 86, GraphQLFederationParser.RULE_typeExtension);

	      try {
	        this.state = 483;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 39, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 477;
	            this.scalarTypeExtension();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 478;
	            this.objectTypeExtension();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 479;
	            this.interfaceTypeExtension();
	            break;

	          case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 480;
	            this.unionTypeExtension();
	            break;

	          case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 481;
	            this.enumTypeExtension();
	            break;

	          case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 482;
	            this.inputObjectTypeExtension();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "scalarTypeDefinition",
	    value: function scalarTypeDefinition() {
	      var localctx = new ScalarTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 88, GraphQLFederationParser.RULE_scalarTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 486;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 485;
	          this.description();
	        }

	        this.state = 488;
	        this.match(GraphQLFederationParser.SCALAR_KEYWORD);
	        this.state = 489;
	        this.name();
	        this.state = 493;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	          this.state = 490;
	          this.scalarDirective();
	          this.state = 495;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "scalarTypeExtension",
	    value: function scalarTypeExtension() {
	      var localctx = new ScalarTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 90, GraphQLFederationParser.RULE_scalarTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 496;
	        this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	        this.state = 497;
	        this.match(GraphQLFederationParser.SCALAR_KEYWORD);
	        this.state = 498;
	        this.name();
	        this.state = 500;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 499;
	          this.scalarDirective();
	          this.state = 502;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectTypeDefinition",
	    value: function objectTypeDefinition() {
	      var localctx = new ObjectTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 92, GraphQLFederationParser.RULE_objectTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 505;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 504;
	          this.description();
	        }

	        this.state = 507;
	        this.match(GraphQLFederationParser.TYPE_KEYWORD);
	        this.state = 508;
	        this.name();
	        this.state = 510;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.IMPLEMENTS_KEYWORD) {
	          this.state = 509;
	          this.implementsInterfaces();
	        }

	        this.state = 515;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INACCESSIBLE | 1 << GraphQLFederationParser.KEY | 1 << GraphQLFederationParser.SHAREABLE)) !== 0 || _la === GraphQLFederationParser.AT) {
	          this.state = 512;
	          this.objectDirective();
	          this.state = 517;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 519;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 46, this._ctx);

	        if (la_ === 1) {
	          this.state = 518;
	          this.fieldsDefinition();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      var localctx = new ImplementsInterfacesContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 94, GraphQLFederationParser.RULE_implementsInterfaces);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 521;
	        this.match(GraphQLFederationParser.IMPLEMENTS_KEYWORD);
	        this.state = 523;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.AMP) {
	          this.state = 522;
	          this.match(GraphQLFederationParser.AMP);
	        }

	        this.state = 525;
	        this.namedType();
	        this.state = 532;

	        this._errHandler.sync(this);

	        var _alt = this._interp.adaptivePredict(this._input, 49, this._ctx);

	        while (_alt != 2 && _alt != _antlr["default"].atn.ATN.INVALID_ALT_NUMBER) {
	          if (_alt === 1) {
	            this.state = 527;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.AMP) {
	              this.state = 526;
	              this.match(GraphQLFederationParser.AMP);
	            }

	            this.state = 529;
	            this.namedType();
	          }

	          this.state = 534;

	          this._errHandler.sync(this);

	          _alt = this._interp.adaptivePredict(this._input, 49, this._ctx);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      var localctx = new FieldsDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 96, GraphQLFederationParser.RULE_fieldsDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 535;
	        this.match(GraphQLFederationParser.LBRACE);
	        this.state = 537;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 536;
	          this.fieldDefinition();
	          this.state = 539;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32)) !== 0 || (_la - 68 & ~0x1f) == 0 && (1 << _la - 68 & (1 << GraphQLFederationParser.NAME - 68 | 1 << GraphQLFederationParser.STRING - 68 | 1 << GraphQLFederationParser.BLOCK_STRING - 68 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 68 | 1 << GraphQLFederationParser.FROM_KEYWORD - 68 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 68)) !== 0);

	        this.state = 541;
	        this.match(GraphQLFederationParser.RBRACE);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldDefinition",
	    value: function fieldDefinition() {
	      var localctx = new FieldDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 98, GraphQLFederationParser.RULE_fieldDefinition);
	      var _la = 0; // Token type

	      try {
	        this.state = 568;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 56, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 544;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	              this.state = 543;
	              this.description();
	            }

	            this.state = 546;
	            this.name();
	            this.state = 548;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.LPAREN) {
	              this.state = 547;
	              this.argumentsDefinition();
	            }

	            this.state = 550;
	            this.match(GraphQLFederationParser.COLON);
	            this.state = 551;
	            this.type_();
	            this.state = 555;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.EXTERNAL | 1 << GraphQLFederationParser.INACCESSIBLE | 1 << GraphQLFederationParser.REQUIRES | 1 << GraphQLFederationParser.PROVIDES | 1 << GraphQLFederationParser.SHAREABLE | 1 << GraphQLFederationParser.OVERRIDE)) !== 0 || _la === GraphQLFederationParser.AT) {
	              this.state = 552;
	              this.fieldDirective();
	              this.state = 557;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            }

	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 559;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	              this.state = 558;
	              this.description();
	            }

	            this.state = 561;
	            localctx._name = this.name();
	            this.state = 563;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.LPAREN) {
	              this.state = 562;
	              this.argumentsDefinition();
	            }

	            this.state = 565;
	            this.match(GraphQLFederationParser.COLON);
	            this.notifyErrorListeners("[AMF]Field '" + (localctx._name === null ? null : this._input.getText(new _antlr["default"].Interval(localctx._name.start, localctx._name.stop))) + "' missing field type", localctx._name === null ? null : localctx._name.start, null);
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "argumentsDefinition",
	    value: function argumentsDefinition() {
	      var localctx = new ArgumentsDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 100, GraphQLFederationParser.RULE_argumentsDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 570;
	        this.match(GraphQLFederationParser.LPAREN);
	        this.state = 572;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 571;
	          this.inputValueDefinition();
	          this.state = 574;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32)) !== 0 || (_la - 68 & ~0x1f) == 0 && (1 << _la - 68 & (1 << GraphQLFederationParser.NAME - 68 | 1 << GraphQLFederationParser.STRING - 68 | 1 << GraphQLFederationParser.BLOCK_STRING - 68 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 68 | 1 << GraphQLFederationParser.FROM_KEYWORD - 68 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 68)) !== 0);

	        this.state = 576;
	        this.match(GraphQLFederationParser.RPAREN);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputValueDefinition",
	    value: function inputValueDefinition() {
	      var localctx = new InputValueDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 102, GraphQLFederationParser.RULE_inputValueDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 579;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 578;
	          this.description();
	        }

	        this.state = 581;
	        this.name();
	        this.state = 582;
	        this.match(GraphQLFederationParser.COLON);
	        this.state = 583;
	        this.type_();
	        this.state = 585;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.EQ) {
	          this.state = 584;
	          this.defaultValue();
	        }

	        this.state = 590;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	          this.state = 587;
	          this.inputValueDirective();
	          this.state = 592;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectTypeExtension",
	    value: function objectTypeExtension() {
	      var localctx = new ObjectTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 104, GraphQLFederationParser.RULE_objectTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 623;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 65, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 593;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 594;
	            this.match(GraphQLFederationParser.TYPE_KEYWORD);
	            this.state = 595;
	            this.name();
	            this.state = 597;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.IMPLEMENTS_KEYWORD) {
	              this.state = 596;
	              this.implementsInterfaces();
	            }

	            this.state = 602;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INACCESSIBLE | 1 << GraphQLFederationParser.KEY | 1 << GraphQLFederationParser.SHAREABLE)) !== 0 || _la === GraphQLFederationParser.AT) {
	              this.state = 599;
	              this.objectDirective();
	              this.state = 604;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            }

	            this.state = 605;
	            this.fieldsDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 607;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 608;
	            this.match(GraphQLFederationParser.TYPE_KEYWORD);
	            this.state = 609;
	            this.name();
	            this.state = 611;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.IMPLEMENTS_KEYWORD) {
	              this.state = 610;
	              this.implementsInterfaces();
	            }

	            this.state = 614;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 613;
	              this.objectDirective();
	              this.state = 616;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INACCESSIBLE | 1 << GraphQLFederationParser.KEY | 1 << GraphQLFederationParser.SHAREABLE)) !== 0 || _la === GraphQLFederationParser.AT);

	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 618;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 619;
	            this.match(GraphQLFederationParser.TYPE_KEYWORD);
	            this.state = 620;
	            this.name();
	            this.state = 621;
	            this.implementsInterfaces();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "interfaceTypeDefinition",
	    value: function interfaceTypeDefinition() {
	      var localctx = new InterfaceTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 106, GraphQLFederationParser.RULE_interfaceTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 626;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 625;
	          this.description();
	        }

	        this.state = 628;
	        this.match(GraphQLFederationParser.INTERFACE_KEYWORD);
	        this.state = 629;
	        this.name();
	        this.state = 631;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.IMPLEMENTS_KEYWORD) {
	          this.state = 630;
	          this.implementsInterfaces();
	        }

	        this.state = 636;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.KEY || _la === GraphQLFederationParser.AT) {
	          this.state = 633;
	          this.interfaceDirective();
	          this.state = 638;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 640;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 69, this._ctx);

	        if (la_ === 1) {
	          this.state = 639;
	          this.fieldsDefinition();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "interfaceTypeExtension",
	    value: function interfaceTypeExtension() {
	      var localctx = new InterfaceTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 108, GraphQLFederationParser.RULE_interfaceTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 672;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 74, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 642;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 643;
	            this.match(GraphQLFederationParser.INTERFACE_KEYWORD);
	            this.state = 644;
	            this.name();
	            this.state = 646;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.IMPLEMENTS_KEYWORD) {
	              this.state = 645;
	              this.implementsInterfaces();
	            }

	            this.state = 651;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.KEY || _la === GraphQLFederationParser.AT) {
	              this.state = 648;
	              this.interfaceDirective();
	              this.state = 653;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            }

	            this.state = 654;
	            this.fieldsDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 656;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 657;
	            this.match(GraphQLFederationParser.INTERFACE_KEYWORD);
	            this.state = 658;
	            this.name();
	            this.state = 660;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLFederationParser.IMPLEMENTS_KEYWORD) {
	              this.state = 659;
	              this.implementsInterfaces();
	            }

	            this.state = 663;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 662;
	              this.interfaceDirective();
	              this.state = 665;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.KEY || _la === GraphQLFederationParser.AT);

	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 667;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 668;
	            this.match(GraphQLFederationParser.INTERFACE_KEYWORD);
	            this.state = 669;
	            this.name();
	            this.state = 670;
	            this.implementsInterfaces();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "unionTypeDefinition",
	    value: function unionTypeDefinition() {
	      var localctx = new UnionTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 110, GraphQLFederationParser.RULE_unionTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 675;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 674;
	          this.description();
	        }

	        this.state = 677;
	        this.match(GraphQLFederationParser.UNION_KEYWORD);
	        this.state = 678;
	        this.name();
	        this.state = 682;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	          this.state = 679;
	          this.unionDirective();
	          this.state = 684;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 686;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.EQ) {
	          this.state = 685;
	          this.unionMemberTypes();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "unionMemberTypes",
	    value: function unionMemberTypes() {
	      var localctx = new UnionMemberTypesContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 112, GraphQLFederationParser.RULE_unionMemberTypes);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 688;
	        this.match(GraphQLFederationParser.EQ);
	        this.state = 690;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.VSLASH) {
	          this.state = 689;
	          this.match(GraphQLFederationParser.VSLASH);
	        }

	        this.state = 692;
	        this.namedType();
	        this.state = 697;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.VSLASH) {
	          this.state = 693;
	          this.match(GraphQLFederationParser.VSLASH);
	          this.state = 694;
	          this.namedType();
	          this.state = 699;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "unionTypeExtension",
	    value: function unionTypeExtension() {
	      var localctx = new UnionTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 114, GraphQLFederationParser.RULE_unionTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 719;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 82, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 700;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 701;
	            this.match(GraphQLFederationParser.UNION_KEYWORD);
	            this.state = 702;
	            this.name();
	            this.state = 706;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	              this.state = 703;
	              this.unionDirective();
	              this.state = 708;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            }

	            this.state = 709;
	            this.unionMemberTypes();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 711;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 712;
	            this.match(GraphQLFederationParser.UNION_KEYWORD);
	            this.state = 713;
	            this.name();
	            this.state = 715;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 714;
	              this.unionDirective();
	              this.state = 717;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT);

	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumTypeDefinition",
	    value: function enumTypeDefinition() {
	      var localctx = new EnumTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 116, GraphQLFederationParser.RULE_enumTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 722;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 721;
	          this.description();
	        }

	        this.state = 724;
	        this.match(GraphQLFederationParser.ENUM_KEYWORD);
	        this.state = 725;
	        this.name();
	        this.state = 729;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	          this.state = 726;
	          this.enumDirective();
	          this.state = 731;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 733;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 85, this._ctx);

	        if (la_ === 1) {
	          this.state = 732;
	          this.enumValuesDefinition();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValuesDefinition",
	    value: function enumValuesDefinition() {
	      var localctx = new EnumValuesDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 118, GraphQLFederationParser.RULE_enumValuesDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 735;
	        this.match(GraphQLFederationParser.LBRACE);
	        this.state = 737;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 736;
	          this.enumValueDefinition();
	          this.state = 739;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32)) !== 0 || (_la - 68 & ~0x1f) == 0 && (1 << _la - 68 & (1 << GraphQLFederationParser.NAME - 68 | 1 << GraphQLFederationParser.STRING - 68 | 1 << GraphQLFederationParser.BLOCK_STRING - 68 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 68 | 1 << GraphQLFederationParser.FROM_KEYWORD - 68 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 68)) !== 0);

	        this.state = 741;
	        this.match(GraphQLFederationParser.RBRACE);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValueDefinition",
	    value: function enumValueDefinition() {
	      var localctx = new EnumValueDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 120, GraphQLFederationParser.RULE_enumValueDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 744;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 743;
	          this.description();
	        }

	        this.state = 746;
	        this.enumValue();
	        this.state = 750;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	          this.state = 747;
	          this.enumValueDirective();
	          this.state = 752;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumTypeExtension",
	    value: function enumTypeExtension() {
	      var localctx = new EnumTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 122, GraphQLFederationParser.RULE_enumTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 772;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 91, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 753;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 754;
	            this.match(GraphQLFederationParser.ENUM_KEYWORD);
	            this.state = 755;
	            this.name();
	            this.state = 759;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	              this.state = 756;
	              this.enumDirective();
	              this.state = 761;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            }

	            this.state = 762;
	            this.enumValuesDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 764;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 765;
	            this.match(GraphQLFederationParser.ENUM_KEYWORD);
	            this.state = 766;
	            this.name();
	            this.state = 768;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 767;
	              this.enumDirective();
	              this.state = 770;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT);

	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputObjectTypeDefinition",
	    value: function inputObjectTypeDefinition() {
	      var localctx = new InputObjectTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 124, GraphQLFederationParser.RULE_inputObjectTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 775;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 774;
	          this.description();
	        }

	        this.state = 777;
	        this.match(GraphQLFederationParser.INPUT_KEYWORD);
	        this.state = 778;
	        this.name();
	        this.state = 782;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	          this.state = 779;
	          this.inputObjectDirective();
	          this.state = 784;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 786;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 94, this._ctx);

	        if (la_ === 1) {
	          this.state = 785;
	          this.inputFieldsDefinition();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputFieldsDefinition",
	    value: function inputFieldsDefinition() {
	      var localctx = new InputFieldsDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 126, GraphQLFederationParser.RULE_inputFieldsDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 788;
	        this.match(GraphQLFederationParser.LBRACE);
	        this.state = 790;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 789;
	          this.inputValueDefinition();
	          this.state = 792;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32)) !== 0 || (_la - 68 & ~0x1f) == 0 && (1 << _la - 68 & (1 << GraphQLFederationParser.NAME - 68 | 1 << GraphQLFederationParser.STRING - 68 | 1 << GraphQLFederationParser.BLOCK_STRING - 68 | 1 << GraphQLFederationParser.FIELDS_KEYWORD - 68 | 1 << GraphQLFederationParser.FROM_KEYWORD - 68 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 68)) !== 0);

	        this.state = 794;
	        this.match(GraphQLFederationParser.RBRACE);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputObjectTypeExtension",
	    value: function inputObjectTypeExtension() {
	      var localctx = new InputObjectTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 128, GraphQLFederationParser.RULE_inputObjectTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 815;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 98, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 796;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 797;
	            this.match(GraphQLFederationParser.INPUT_KEYWORD);
	            this.state = 798;
	            this.name();
	            this.state = 802;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT) {
	              this.state = 799;
	              this.inputObjectDirective();
	              this.state = 804;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            }

	            this.state = 805;
	            this.inputFieldsDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 807;
	            this.match(GraphQLFederationParser.EXTEND_KEYWORD);
	            this.state = 808;
	            this.match(GraphQLFederationParser.INPUT_KEYWORD);
	            this.state = 809;
	            this.name();
	            this.state = 811;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 810;
	              this.inputObjectDirective();
	              this.state = 813;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while (_la === GraphQLFederationParser.INACCESSIBLE || _la === GraphQLFederationParser.AT);

	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directiveDefinition",
	    value: function directiveDefinition() {
	      var localctx = new DirectiveDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 130, GraphQLFederationParser.RULE_directiveDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 818;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.STRING || _la === GraphQLFederationParser.BLOCK_STRING) {
	          this.state = 817;
	          this.description();
	        }

	        this.state = 820;
	        this.match(GraphQLFederationParser.DIRECTIVE_KEYWORD);
	        this.state = 821;
	        this.match(GraphQLFederationParser.AT);
	        this.state = 822;
	        this.name();
	        this.state = 824;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.LPAREN) {
	          this.state = 823;
	          this.argumentsDefinition();
	        }

	        this.state = 827;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.REPEATABLE_KEYWORD) {
	          this.state = 826;
	          this.match(GraphQLFederationParser.REPEATABLE_KEYWORD);
	        }

	        this.state = 829;
	        this.match(GraphQLFederationParser.ON_KEYWORD);
	        this.state = 830;
	        this.directiveLocations();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directiveLocations",
	    value: function directiveLocations() {
	      var localctx = new DirectiveLocationsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 132, GraphQLFederationParser.RULE_directiveLocations);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 832;
	        this.directiveLocation();
	        this.state = 837;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLFederationParser.VSLASH) {
	          this.state = 833;
	          this.match(GraphQLFederationParser.VSLASH);
	          this.state = 834;
	          this.directiveLocation();
	          this.state = 839;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directiveLocation",
	    value: function directiveLocation() {
	      var localctx = new DirectiveLocationContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 134, GraphQLFederationParser.RULE_directiveLocation);

	      try {
	        this.state = 842;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.QUERY_LOCATION:
	          case GraphQLFederationParser.MUTATION_LOCATION:
	          case GraphQLFederationParser.SUBSCRIPTION_LOCATION:
	          case GraphQLFederationParser.FIELD_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION:
	          case GraphQLFederationParser.INLINE_FRAGMENT_LOCATION:
	          case GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 840;
	            this.executableDirectiveLocation();
	            break;

	          case GraphQLFederationParser.ENUM_LOCATION:
	          case GraphQLFederationParser.SCALAR_LOCATION:
	          case GraphQLFederationParser.INTERFACE_LOCATION:
	          case GraphQLFederationParser.UNION_LOCATION:
	          case GraphQLFederationParser.SCHEMA_LOCATION:
	          case GraphQLFederationParser.OBJECT_LOCATION:
	          case GraphQLFederationParser.FIELD_DEFINITION_LOCATION:
	          case GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION:
	          case GraphQLFederationParser.ENUM_VALUE_LOCATION:
	          case GraphQLFederationParser.INPUT_OBJECT_LOCATION:
	          case GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 841;
	            this.typeSystemDirectiveLocation();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "executableDirectiveLocation",
	    value: function executableDirectiveLocation() {
	      var localctx = new ExecutableDirectiveLocationContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 136, GraphQLFederationParser.RULE_executableDirectiveLocation);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 844;
	        _la = this._input.LA(1);

	        if (!((_la - 34 & ~0x1f) == 0 && (1 << _la - 34 & (1 << GraphQLFederationParser.QUERY_LOCATION - 34 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 34 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 34 | 1 << GraphQLFederationParser.FIELD_LOCATION - 34 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 34 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 34 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 34 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 34)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeSystemDirectiveLocation",
	    value: function typeSystemDirectiveLocation() {
	      var localctx = new TypeSystemDirectiveLocationContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 138, GraphQLFederationParser.RULE_typeSystemDirectiveLocation);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 846;
	        _la = this._input.LA(1);

	        if (!((_la - 27 & ~0x1f) == 0 && (1 << _la - 27 & (1 << GraphQLFederationParser.ENUM_LOCATION - 27 | 1 << GraphQLFederationParser.SCALAR_LOCATION - 27 | 1 << GraphQLFederationParser.INTERFACE_LOCATION - 27 | 1 << GraphQLFederationParser.UNION_LOCATION - 27 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 27 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 27 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 27 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 27 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 27 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 27 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 27)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "externalDirective",
	    value: function externalDirective() {
	      var localctx = new ExternalDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 140, GraphQLFederationParser.RULE_externalDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 848;
	        this.match(GraphQLFederationParser.EXTERNAL);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      var localctx = new InaccessibleDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 142, GraphQLFederationParser.RULE_inaccessibleDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 850;
	        this.match(GraphQLFederationParser.INACCESSIBLE);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "requiresDirective",
	    value: function requiresDirective() {
	      var localctx = new RequiresDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 144, GraphQLFederationParser.RULE_requiresDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 852;
	        this.match(GraphQLFederationParser.REQUIRES);
	        this.state = 853;
	        this.match(GraphQLFederationParser.LPAREN_F);
	        this.state = 854;
	        this.match(GraphQLFederationParser.FIELDS_KEYWORD);
	        this.state = 855;
	        this.match(GraphQLFederationParser.COLON_F);
	        this.state = 856;
	        this.match(GraphQLFederationParser.DQUOTE_F);
	        this.state = 857;
	        this.fieldSet();
	        this.state = 858;
	        this.match(GraphQLFederationParser.DQUOTE_F);
	        this.state = 859;
	        this.match(GraphQLFederationParser.RPAREN_F);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "providesDirective",
	    value: function providesDirective() {
	      var localctx = new ProvidesDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 146, GraphQLFederationParser.RULE_providesDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 861;
	        this.match(GraphQLFederationParser.PROVIDES);
	        this.state = 862;
	        this.match(GraphQLFederationParser.LPAREN_F);
	        this.state = 863;
	        this.match(GraphQLFederationParser.FIELDS_KEYWORD);
	        this.state = 864;
	        this.match(GraphQLFederationParser.COLON_F);
	        this.state = 865;
	        this.match(GraphQLFederationParser.DQUOTE_F);
	        this.state = 866;
	        this.fieldSet();
	        this.state = 867;
	        this.match(GraphQLFederationParser.DQUOTE_F);
	        this.state = 868;
	        this.match(GraphQLFederationParser.RPAREN_F);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "keyDirective",
	    value: function keyDirective() {
	      var localctx = new KeyDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 148, GraphQLFederationParser.RULE_keyDirective);

	      try {
	        this.state = 891;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 104, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 870;
	            this.match(GraphQLFederationParser.KEY);
	            this.state = 871;
	            this.match(GraphQLFederationParser.LPAREN_F);
	            this.state = 872;
	            this.match(GraphQLFederationParser.FIELDS_KEYWORD);
	            this.state = 873;
	            this.match(GraphQLFederationParser.COLON_F);
	            this.state = 874;
	            this.match(GraphQLFederationParser.DQUOTE_F);
	            this.state = 875;
	            this.fieldSet();
	            this.state = 876;
	            this.match(GraphQLFederationParser.DQUOTE_F);
	            this.state = 877;
	            this.match(GraphQLFederationParser.RPAREN_F);
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 879;
	            this.match(GraphQLFederationParser.KEY);
	            this.state = 880;
	            this.match(GraphQLFederationParser.LPAREN_F);
	            this.state = 881;
	            this.match(GraphQLFederationParser.FIELDS_KEYWORD);
	            this.state = 882;
	            this.match(GraphQLFederationParser.COLON_F);
	            this.state = 883;
	            this.match(GraphQLFederationParser.DQUOTE_F);
	            this.state = 884;
	            this.fieldSet();
	            this.state = 885;
	            this.match(GraphQLFederationParser.DQUOTE_F);
	            this.state = 886;
	            this.match(GraphQLFederationParser.RESOLVABLE_KEYWORD);
	            this.state = 887;
	            this.match(GraphQLFederationParser.COLON_F);
	            this.state = 888;
	            this.booleanValue_f();
	            this.state = 889;
	            this.match(GraphQLFederationParser.RPAREN_F);
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "shareableDirective",
	    value: function shareableDirective() {
	      var localctx = new ShareableDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 150, GraphQLFederationParser.RULE_shareableDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 893;
	        this.match(GraphQLFederationParser.SHAREABLE);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "overrideDirective",
	    value: function overrideDirective() {
	      var localctx = new OverrideDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 152, GraphQLFederationParser.RULE_overrideDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 895;
	        this.match(GraphQLFederationParser.OVERRIDE);
	        this.state = 896;
	        this.match(GraphQLFederationParser.LPAREN_F);
	        this.state = 897;
	        this.match(GraphQLFederationParser.FROM_KEYWORD);
	        this.state = 898;
	        this.match(GraphQLFederationParser.COLON_F);
	        this.state = 899;
	        this.match(GraphQLFederationParser.DQUOTE_F);
	        this.state = 900;
	        this.name_f();
	        this.state = 901;
	        this.match(GraphQLFederationParser.DQUOTE_F);
	        this.state = 902;
	        this.match(GraphQLFederationParser.RPAREN_F);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "linkDirective",
	    value: function linkDirective() {
	      var localctx = new LinkDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 154, GraphQLFederationParser.RULE_linkDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 904;
	        this.match(GraphQLFederationParser.LINK);
	        this.state = 905;
	        this.match(GraphQLFederationParser.STRING_LINK);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldSet",
	    value: function fieldSet() {
	      var localctx = new FieldSetContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 156, GraphQLFederationParser.RULE_fieldSet);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 908;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 907;
	          this.fieldSetComponent();
	          this.state = 910;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la - 86 & ~0x1f) == 0 && (1 << _la - 86 & (1 << GraphQLFederationParser.NAME_F - 86 | 1 << GraphQLFederationParser.INPUT_KEYWORD_F - 86 | 1 << GraphQLFederationParser.TYPE_KEYWORD_F - 86 | 1 << GraphQLFederationParser.ENUM_KEYWORD_F - 86 | 1 << GraphQLFederationParser.SCALAR_KEYWORD_F - 86 | 1 << GraphQLFederationParser.INTERFACE_KEYWORD_F - 86 | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD_F - 86 | 1 << GraphQLFederationParser.EXTEND_KEYWORD_F - 86 | 1 << GraphQLFederationParser.UNION_KEYWORD_F - 86 | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD_F - 86 | 1 << GraphQLFederationParser.QUERY_KEYWORD_F - 86 | 1 << GraphQLFederationParser.MUTATION_KEYWORD_F - 86 | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD_F - 86 | 1 << GraphQLFederationParser.SCHEMA_KEYWORD_F - 86 | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD_F - 86 | 1 << GraphQLFederationParser.ON_KEYWORD_F - 86 | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD_F - 86)) !== 0);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldSetComponent",
	    value: function fieldSetComponent() {
	      var localctx = new FieldSetComponentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 158, GraphQLFederationParser.RULE_fieldSetComponent);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 912;
	        this.name_f();
	        this.state = 914;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLFederationParser.LBRACE_F) {
	          this.state = 913;
	          this.nestedFieldSet();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "nestedFieldSet",
	    value: function nestedFieldSet() {
	      var localctx = new NestedFieldSetContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 160, GraphQLFederationParser.RULE_nestedFieldSet);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 916;
	        this.match(GraphQLFederationParser.LBRACE_F);
	        this.state = 917;
	        this.fieldSet();
	        this.state = 918;
	        this.match(GraphQLFederationParser.RBRACE_F);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "schemaDirective",
	    value: function schemaDirective() {
	      var localctx = new SchemaDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 162, GraphQLFederationParser.RULE_schemaDirective);

	      try {
	        this.state = 922;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 920;
	            this.directive();
	            break;

	          case GraphQLFederationParser.LINK:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 921;
	            this.schemaFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "schemaFederationDirective",
	    value: function schemaFederationDirective() {
	      var localctx = new SchemaFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 164, GraphQLFederationParser.RULE_schemaFederationDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 924;
	        this.linkDirective();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "scalarDirective",
	    value: function scalarDirective() {
	      var localctx = new ScalarDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 166, GraphQLFederationParser.RULE_scalarDirective);

	      try {
	        this.state = 928;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 926;
	            this.directive();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 927;
	            this.scalarFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "scalarFederationDirective",
	    value: function scalarFederationDirective() {
	      var localctx = new ScalarFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 168, GraphQLFederationParser.RULE_scalarFederationDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 930;
	        this.inaccessibleDirective();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectDirective",
	    value: function objectDirective() {
	      var localctx = new ObjectDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 170, GraphQLFederationParser.RULE_objectDirective);

	      try {
	        this.state = 934;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 932;
	            this.directive();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	          case GraphQLFederationParser.KEY:
	          case GraphQLFederationParser.SHAREABLE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 933;
	            this.objectFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectFederationDirective",
	    value: function objectFederationDirective() {
	      var localctx = new ObjectFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 172, GraphQLFederationParser.RULE_objectFederationDirective);

	      try {
	        this.state = 939;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.KEY:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 936;
	            this.keyDirective();
	            break;

	          case GraphQLFederationParser.SHAREABLE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 937;
	            this.shareableDirective();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 938;
	            this.inaccessibleDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "interfaceDirective",
	    value: function interfaceDirective() {
	      var localctx = new InterfaceDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 174, GraphQLFederationParser.RULE_interfaceDirective);

	      try {
	        this.state = 943;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 941;
	            this.directive();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	          case GraphQLFederationParser.KEY:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 942;
	            this.interfaceFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "interfaceFederationDirective",
	    value: function interfaceFederationDirective() {
	      var localctx = new InterfaceFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 176, GraphQLFederationParser.RULE_interfaceFederationDirective);

	      try {
	        this.state = 947;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 945;
	            this.inaccessibleDirective();
	            break;

	          case GraphQLFederationParser.KEY:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 946;
	            this.keyDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "unionDirective",
	    value: function unionDirective() {
	      var localctx = new UnionDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 178, GraphQLFederationParser.RULE_unionDirective);

	      try {
	        this.state = 951;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 949;
	            this.directive();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 950;
	            this.unionFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "unionFederationDirective",
	    value: function unionFederationDirective() {
	      var localctx = new UnionFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 180, GraphQLFederationParser.RULE_unionFederationDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 953;
	        this.inaccessibleDirective();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumDirective",
	    value: function enumDirective() {
	      var localctx = new EnumDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 182, GraphQLFederationParser.RULE_enumDirective);

	      try {
	        this.state = 957;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 955;
	            this.directive();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 956;
	            this.enumFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumFederationDirective",
	    value: function enumFederationDirective() {
	      var localctx = new EnumFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 184, GraphQLFederationParser.RULE_enumFederationDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 959;
	        this.inaccessibleDirective();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputObjectDirective",
	    value: function inputObjectDirective() {
	      var localctx = new InputObjectDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 186, GraphQLFederationParser.RULE_inputObjectDirective);

	      try {
	        this.state = 963;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 961;
	            this.directive();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 962;
	            this.inputObjectFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputObjectFederationDirective",
	    value: function inputObjectFederationDirective() {
	      var localctx = new InputObjectFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 188, GraphQLFederationParser.RULE_inputObjectFederationDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 965;
	        this.inaccessibleDirective();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputValueDirective",
	    value: function inputValueDirective() {
	      var localctx = new InputValueDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 190, GraphQLFederationParser.RULE_inputValueDirective);

	      try {
	        this.state = 969;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 967;
	            this.directive();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 968;
	            this.inputFieldFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputFieldFederationDirective",
	    value: function inputFieldFederationDirective() {
	      var localctx = new InputFieldFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 192, GraphQLFederationParser.RULE_inputFieldFederationDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 971;
	        this.inaccessibleDirective();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldDirective",
	    value: function fieldDirective() {
	      var localctx = new FieldDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 194, GraphQLFederationParser.RULE_fieldDirective);

	      try {
	        this.state = 975;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 973;
	            this.directive();
	            break;

	          case GraphQLFederationParser.EXTERNAL:
	          case GraphQLFederationParser.INACCESSIBLE:
	          case GraphQLFederationParser.REQUIRES:
	          case GraphQLFederationParser.PROVIDES:
	          case GraphQLFederationParser.SHAREABLE:
	          case GraphQLFederationParser.OVERRIDE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 974;
	            this.fieldFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldFederationDirective",
	    value: function fieldFederationDirective() {
	      var localctx = new FieldFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 196, GraphQLFederationParser.RULE_fieldFederationDirective);

	      try {
	        this.state = 983;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.EXTERNAL:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 977;
	            this.externalDirective();
	            break;

	          case GraphQLFederationParser.REQUIRES:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 978;
	            this.requiresDirective();
	            break;

	          case GraphQLFederationParser.PROVIDES:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 979;
	            this.providesDirective();
	            break;

	          case GraphQLFederationParser.SHAREABLE:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 980;
	            this.shareableDirective();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 981;
	            this.inaccessibleDirective();
	            break;

	          case GraphQLFederationParser.OVERRIDE:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 982;
	            this.overrideDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValueDirective",
	    value: function enumValueDirective() {
	      var localctx = new EnumValueDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 198, GraphQLFederationParser.RULE_enumValueDirective);

	      try {
	        this.state = 987;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.AT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 985;
	            this.directive();
	            break;

	          case GraphQLFederationParser.INACCESSIBLE:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 986;
	            this.enumValueFederationDirective();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValueFederationDirective",
	    value: function enumValueFederationDirective() {
	      var localctx = new EnumValueFederationDirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 200, GraphQLFederationParser.RULE_enumValueFederationDirective);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 989;
	        this.inaccessibleDirective();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      var localctx = new NameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 202, GraphQLFederationParser.RULE_name);

	      try {
	        this.state = 993;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.INPUT_KEYWORD:
	          case GraphQLFederationParser.TYPE_KEYWORD:
	          case GraphQLFederationParser.ENUM_KEYWORD:
	          case GraphQLFederationParser.SCALAR_KEYWORD:
	          case GraphQLFederationParser.INTERFACE_KEYWORD:
	          case GraphQLFederationParser.DIRECTIVE_KEYWORD:
	          case GraphQLFederationParser.EXTEND_KEYWORD:
	          case GraphQLFederationParser.UNION_KEYWORD:
	          case GraphQLFederationParser.IMPLEMENTS_KEYWORD:
	          case GraphQLFederationParser.QUERY_KEYWORD:
	          case GraphQLFederationParser.MUTATION_KEYWORD:
	          case GraphQLFederationParser.SUBSCRIPTION_KEYWORD:
	          case GraphQLFederationParser.SCHEMA_KEYWORD:
	          case GraphQLFederationParser.FRAGMENT_KEYWORD:
	          case GraphQLFederationParser.ON_KEYWORD:
	          case GraphQLFederationParser.REPEATABLE_KEYWORD:
	          case GraphQLFederationParser.INPUT_LOCATION:
	          case GraphQLFederationParser.TYPE_LOCATION:
	          case GraphQLFederationParser.ENUM_LOCATION:
	          case GraphQLFederationParser.SCALAR_LOCATION:
	          case GraphQLFederationParser.INTERFACE_LOCATION:
	          case GraphQLFederationParser.DIRECTIVE_LOCATION:
	          case GraphQLFederationParser.EXTEND_LOCATION:
	          case GraphQLFederationParser.UNION_LOCATION:
	          case GraphQLFederationParser.IMPLEMENTS_LOCATION:
	          case GraphQLFederationParser.QUERY_LOCATION:
	          case GraphQLFederationParser.MUTATION_LOCATION:
	          case GraphQLFederationParser.SUBSCRIPTION_LOCATION:
	          case GraphQLFederationParser.SCHEMA_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_LOCATION:
	          case GraphQLFederationParser.FIELD_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION:
	          case GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION:
	          case GraphQLFederationParser.INLINE_FRAGMENT_LOCATION:
	          case GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION:
	          case GraphQLFederationParser.OBJECT_LOCATION:
	          case GraphQLFederationParser.FIELD_DEFINITION_LOCATION:
	          case GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION:
	          case GraphQLFederationParser.ENUM_VALUE_LOCATION:
	          case GraphQLFederationParser.INPUT_OBJECT_LOCATION:
	          case GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION:
	          case GraphQLFederationParser.FIELDS_KEYWORD:
	          case GraphQLFederationParser.FROM_KEYWORD:
	          case GraphQLFederationParser.RESOLVABLE_KEYWORD:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 991;
	            this.keyword();
	            break;

	          case GraphQLFederationParser.NAME:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 992;
	            this.match(GraphQLFederationParser.NAME);
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "name_f",
	    value: function name_f() {
	      var localctx = new Name_fContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 204, GraphQLFederationParser.RULE_name_f);

	      try {
	        this.state = 997;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLFederationParser.INPUT_KEYWORD_F:
	          case GraphQLFederationParser.TYPE_KEYWORD_F:
	          case GraphQLFederationParser.ENUM_KEYWORD_F:
	          case GraphQLFederationParser.SCALAR_KEYWORD_F:
	          case GraphQLFederationParser.INTERFACE_KEYWORD_F:
	          case GraphQLFederationParser.DIRECTIVE_KEYWORD_F:
	          case GraphQLFederationParser.EXTEND_KEYWORD_F:
	          case GraphQLFederationParser.UNION_KEYWORD_F:
	          case GraphQLFederationParser.IMPLEMENTS_KEYWORD_F:
	          case GraphQLFederationParser.QUERY_KEYWORD_F:
	          case GraphQLFederationParser.MUTATION_KEYWORD_F:
	          case GraphQLFederationParser.SUBSCRIPTION_KEYWORD_F:
	          case GraphQLFederationParser.SCHEMA_KEYWORD_F:
	          case GraphQLFederationParser.FRAGMENT_KEYWORD_F:
	          case GraphQLFederationParser.ON_KEYWORD_F:
	          case GraphQLFederationParser.REPEATABLE_KEYWORD_F:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 995;
	            this.keyword_f();
	            break;

	          case GraphQLFederationParser.NAME_F:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 996;
	            this.match(GraphQLFederationParser.NAME_F);
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "booleanValue_f",
	    value: function booleanValue_f() {
	      var localctx = new BooleanValue_fContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 206, GraphQLFederationParser.RULE_booleanValue_f);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 999;
	        _la = this._input.LA(1);

	        if (!(_la === GraphQLFederationParser.TRUE_F || _la === GraphQLFederationParser.FALSE_F)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "keyword",
	    value: function keyword() {
	      var localctx = new KeywordContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 208, GraphQLFederationParser.RULE_keyword);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1001;
	        _la = this._input.LA(1);

	        if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLFederationParser.INPUT_KEYWORD | 1 << GraphQLFederationParser.TYPE_KEYWORD | 1 << GraphQLFederationParser.ENUM_KEYWORD | 1 << GraphQLFederationParser.SCALAR_KEYWORD | 1 << GraphQLFederationParser.INTERFACE_KEYWORD | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD | 1 << GraphQLFederationParser.EXTEND_KEYWORD | 1 << GraphQLFederationParser.UNION_KEYWORD | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD | 1 << GraphQLFederationParser.QUERY_KEYWORD | 1 << GraphQLFederationParser.MUTATION_KEYWORD | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD | 1 << GraphQLFederationParser.SCHEMA_KEYWORD | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD | 1 << GraphQLFederationParser.ON_KEYWORD | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD | 1 << GraphQLFederationParser.INPUT_LOCATION | 1 << GraphQLFederationParser.TYPE_LOCATION | 1 << GraphQLFederationParser.ENUM_LOCATION | 1 << GraphQLFederationParser.SCALAR_LOCATION | 1 << GraphQLFederationParser.INTERFACE_LOCATION | 1 << GraphQLFederationParser.DIRECTIVE_LOCATION | 1 << GraphQLFederationParser.EXTEND_LOCATION)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLFederationParser.UNION_LOCATION - 32 | 1 << GraphQLFederationParser.IMPLEMENTS_LOCATION - 32 | 1 << GraphQLFederationParser.QUERY_LOCATION - 32 | 1 << GraphQLFederationParser.MUTATION_LOCATION - 32 | 1 << GraphQLFederationParser.SUBSCRIPTION_LOCATION - 32 | 1 << GraphQLFederationParser.SCHEMA_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION - 32 | 1 << GraphQLFederationParser.INLINE_FRAGMENT_LOCATION - 32 | 1 << GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.FIELD_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION - 32 | 1 << GraphQLFederationParser.ENUM_VALUE_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_OBJECT_LOCATION - 32 | 1 << GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION - 32)) !== 0 || (_la - 80 & ~0x1f) == 0 && (1 << _la - 80 & (1 << GraphQLFederationParser.FIELDS_KEYWORD - 80 | 1 << GraphQLFederationParser.FROM_KEYWORD - 80 | 1 << GraphQLFederationParser.RESOLVABLE_KEYWORD - 80)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "keyword_f",
	    value: function keyword_f() {
	      var localctx = new Keyword_fContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 210, GraphQLFederationParser.RULE_keyword_f);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1003;
	        _la = this._input.LA(1);

	        if (!((_la - 93 & ~0x1f) == 0 && (1 << _la - 93 & (1 << GraphQLFederationParser.INPUT_KEYWORD_F - 93 | 1 << GraphQLFederationParser.TYPE_KEYWORD_F - 93 | 1 << GraphQLFederationParser.ENUM_KEYWORD_F - 93 | 1 << GraphQLFederationParser.SCALAR_KEYWORD_F - 93 | 1 << GraphQLFederationParser.INTERFACE_KEYWORD_F - 93 | 1 << GraphQLFederationParser.DIRECTIVE_KEYWORD_F - 93 | 1 << GraphQLFederationParser.EXTEND_KEYWORD_F - 93 | 1 << GraphQLFederationParser.UNION_KEYWORD_F - 93 | 1 << GraphQLFederationParser.IMPLEMENTS_KEYWORD_F - 93 | 1 << GraphQLFederationParser.QUERY_KEYWORD_F - 93 | 1 << GraphQLFederationParser.MUTATION_KEYWORD_F - 93 | 1 << GraphQLFederationParser.SUBSCRIPTION_KEYWORD_F - 93 | 1 << GraphQLFederationParser.SCHEMA_KEYWORD_F - 93 | 1 << GraphQLFederationParser.FRAGMENT_KEYWORD_F - 93 | 1 << GraphQLFederationParser.ON_KEYWORD_F - 93 | 1 << GraphQLFederationParser.REPEATABLE_KEYWORD_F - 93)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }]);

	  return GraphQLFederationParser;
	}(_antlr["default"].Parser);

	exports["default"] = GraphQLFederationParser;

	_defineProperty(GraphQLFederationParser, "grammarFileName", "GraphQLFederationParser.g4");

	_defineProperty(GraphQLFederationParser, "literalNames", [null, "'@external'", "'@inaccessible'", "'@requires'", "'@provides'", "'@key'", "'@shareable'", "'@override'", "'@link'", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "'INPUT'", "'TYPE'", "'ENUM'", "'SCALAR'", "'INTERFACE'", "'DIRECTIVE'", "'EXTEND'", "'UNION'", "'IMPLEMENTS'", "'QUERY'", "'MUTATION'", "'SUBSCRIPTION'", "'SCHEMA'", "'FRAGMENT'", "'FIELD'", "'FRAGMENT_DEFINITION'", "'FRAGMENT_SPREAD'", "'INLINE_FRAGMENT'", "'VARIABLE_DEFINITION'", "'OBJECT'", "'FIELD_DEFINITION'", "'ARGUMENT_DEFINITION'", "'ENUM_VALUE'", "'INPUT_OBJECT'", "'INPUT_FIELD_DEFINITION'", null, null, "'['", "']'", null, null, "'@'", "'&'", "'='", null, "'...'", "'!'", "'|'", "'$'", null, null, null, "'null'", null, null, null, null, null, null, null, null, null, "'\uEFBBBF'", "'\uFEFF'", "'\0FEFF'", "'fields'", "'from'", "'resolvable'"]);

	_defineProperty(GraphQLFederationParser, "symbolicNames", [null, "EXTERNAL", "INACCESSIBLE", "REQUIRES", "PROVIDES", "KEY", "SHAREABLE", "OVERRIDE", "LINK", "INPUT_KEYWORD", "TYPE_KEYWORD", "ENUM_KEYWORD", "SCALAR_KEYWORD", "INTERFACE_KEYWORD", "DIRECTIVE_KEYWORD", "EXTEND_KEYWORD", "UNION_KEYWORD", "IMPLEMENTS_KEYWORD", "QUERY_KEYWORD", "MUTATION_KEYWORD", "SUBSCRIPTION_KEYWORD", "SCHEMA_KEYWORD", "FRAGMENT_KEYWORD", "ON_KEYWORD", "REPEATABLE_KEYWORD", "INPUT_LOCATION", "TYPE_LOCATION", "ENUM_LOCATION", "SCALAR_LOCATION", "INTERFACE_LOCATION", "DIRECTIVE_LOCATION", "EXTEND_LOCATION", "UNION_LOCATION", "IMPLEMENTS_LOCATION", "QUERY_LOCATION", "MUTATION_LOCATION", "SUBSCRIPTION_LOCATION", "SCHEMA_LOCATION", "FRAGMENT_LOCATION", "FIELD_LOCATION", "FRAGMENT_DEFINITION_LOCATION", "FRAGMENT_SPREAD_LOCATION", "INLINE_FRAGMENT_LOCATION", "VARIABLE_DEFINITION_LOCATION", "OBJECT_LOCATION", "FIELD_DEFINITION_LOCATION", "ARGUMENT_DEFINITION_LOCATION", "ENUM_VALUE_LOCATION", "INPUT_OBJECT_LOCATION", "INPUT_FIELD_DEFINITION_LOCATION", "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "LPAREN", "RPAREN", "AT", "AMP", "EQ", "COLON", "ELLIPSIS", "EXCL", "VSLASH", "DOLLAR", "DQUOTE", "TRUE", "FALSE", "NULL", "NAME", "STRING", "BLOCK_STRING", "FLOAT", "INT", "WS", "COMMA", "LineComment", "UNICODE_BOM", "UTF8_BOM", "UTF16_BOM", "UTF32_BOM", "FIELDS_KEYWORD", "FROM_KEYWORD", "RESOLVABLE_KEYWORD", "TRUE_F", "FALSE_F", "WS_F", "NAME_F", "DQUOTE_F", "COLON_F", "LBRACE_F", "RBRACE_F", "LPAREN_F", "RPAREN_F", "INPUT_KEYWORD_F", "TYPE_KEYWORD_F", "ENUM_KEYWORD_F", "SCALAR_KEYWORD_F", "INTERFACE_KEYWORD_F", "DIRECTIVE_KEYWORD_F", "EXTEND_KEYWORD_F", "UNION_KEYWORD_F", "IMPLEMENTS_KEYWORD_F", "QUERY_KEYWORD_F", "MUTATION_KEYWORD_F", "SUBSCRIPTION_KEYWORD_F", "SCHEMA_KEYWORD_F", "FRAGMENT_KEYWORD_F", "ON_KEYWORD_F", "REPEATABLE_KEYWORD_F", "COMMA_F", "STRING_LINK", "WS_LINK"]);

	_defineProperty(GraphQLFederationParser, "ruleNames", ["document", "definition", "executableDefinition", "operationDefinition", "operationType", "selectionSet", "selection", "field", "arguments", "argument", "alias", "fragmentSpread", "fragmentDefinition", "fragmentName", "typeCondition", "inlineFragment", "value", "intValue", "floatValue", "booleanValue", "stringValue", "nullValue", "enumValue", "listValue", "objectValue", "objectField", "variable", "variableDefinitions", "variableDefinition", "defaultValue", "type_", "namedType", "listType", "directives", "directive", "typeSystemDefinition", "typeSystemExtension", "schemaDefinition", "rootOperationTypeDefinition", "schemaExtension", "operationTypeDefinition", "description", "typeDefinition", "typeExtension", "scalarTypeDefinition", "scalarTypeExtension", "objectTypeDefinition", "implementsInterfaces", "fieldsDefinition", "fieldDefinition", "argumentsDefinition", "inputValueDefinition", "objectTypeExtension", "interfaceTypeDefinition", "interfaceTypeExtension", "unionTypeDefinition", "unionMemberTypes", "unionTypeExtension", "enumTypeDefinition", "enumValuesDefinition", "enumValueDefinition", "enumTypeExtension", "inputObjectTypeDefinition", "inputFieldsDefinition", "inputObjectTypeExtension", "directiveDefinition", "directiveLocations", "directiveLocation", "executableDirectiveLocation", "typeSystemDirectiveLocation", "externalDirective", "inaccessibleDirective", "requiresDirective", "providesDirective", "keyDirective", "shareableDirective", "overrideDirective", "linkDirective", "fieldSet", "fieldSetComponent", "nestedFieldSet", "schemaDirective", "schemaFederationDirective", "scalarDirective", "scalarFederationDirective", "objectDirective", "objectFederationDirective", "interfaceDirective", "interfaceFederationDirective", "unionDirective", "unionFederationDirective", "enumDirective", "enumFederationDirective", "inputObjectDirective", "inputObjectFederationDirective", "inputValueDirective", "inputFieldFederationDirective", "fieldDirective", "fieldFederationDirective", "enumValueDirective", "enumValueFederationDirective", "name", "name_f", "booleanValue_f", "keyword", "keyword_f"]);

	GraphQLFederationParser.EOF = _antlr["default"].Token.EOF;
	GraphQLFederationParser.EXTERNAL = 1;
	GraphQLFederationParser.INACCESSIBLE = 2;
	GraphQLFederationParser.REQUIRES = 3;
	GraphQLFederationParser.PROVIDES = 4;
	GraphQLFederationParser.KEY = 5;
	GraphQLFederationParser.SHAREABLE = 6;
	GraphQLFederationParser.OVERRIDE = 7;
	GraphQLFederationParser.LINK = 8;
	GraphQLFederationParser.INPUT_KEYWORD = 9;
	GraphQLFederationParser.TYPE_KEYWORD = 10;
	GraphQLFederationParser.ENUM_KEYWORD = 11;
	GraphQLFederationParser.SCALAR_KEYWORD = 12;
	GraphQLFederationParser.INTERFACE_KEYWORD = 13;
	GraphQLFederationParser.DIRECTIVE_KEYWORD = 14;
	GraphQLFederationParser.EXTEND_KEYWORD = 15;
	GraphQLFederationParser.UNION_KEYWORD = 16;
	GraphQLFederationParser.IMPLEMENTS_KEYWORD = 17;
	GraphQLFederationParser.QUERY_KEYWORD = 18;
	GraphQLFederationParser.MUTATION_KEYWORD = 19;
	GraphQLFederationParser.SUBSCRIPTION_KEYWORD = 20;
	GraphQLFederationParser.SCHEMA_KEYWORD = 21;
	GraphQLFederationParser.FRAGMENT_KEYWORD = 22;
	GraphQLFederationParser.ON_KEYWORD = 23;
	GraphQLFederationParser.REPEATABLE_KEYWORD = 24;
	GraphQLFederationParser.INPUT_LOCATION = 25;
	GraphQLFederationParser.TYPE_LOCATION = 26;
	GraphQLFederationParser.ENUM_LOCATION = 27;
	GraphQLFederationParser.SCALAR_LOCATION = 28;
	GraphQLFederationParser.INTERFACE_LOCATION = 29;
	GraphQLFederationParser.DIRECTIVE_LOCATION = 30;
	GraphQLFederationParser.EXTEND_LOCATION = 31;
	GraphQLFederationParser.UNION_LOCATION = 32;
	GraphQLFederationParser.IMPLEMENTS_LOCATION = 33;
	GraphQLFederationParser.QUERY_LOCATION = 34;
	GraphQLFederationParser.MUTATION_LOCATION = 35;
	GraphQLFederationParser.SUBSCRIPTION_LOCATION = 36;
	GraphQLFederationParser.SCHEMA_LOCATION = 37;
	GraphQLFederationParser.FRAGMENT_LOCATION = 38;
	GraphQLFederationParser.FIELD_LOCATION = 39;
	GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION = 40;
	GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION = 41;
	GraphQLFederationParser.INLINE_FRAGMENT_LOCATION = 42;
	GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION = 43;
	GraphQLFederationParser.OBJECT_LOCATION = 44;
	GraphQLFederationParser.FIELD_DEFINITION_LOCATION = 45;
	GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION = 46;
	GraphQLFederationParser.ENUM_VALUE_LOCATION = 47;
	GraphQLFederationParser.INPUT_OBJECT_LOCATION = 48;
	GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION = 49;
	GraphQLFederationParser.LBRACE = 50;
	GraphQLFederationParser.RBRACE = 51;
	GraphQLFederationParser.LBRACKET = 52;
	GraphQLFederationParser.RBRACKET = 53;
	GraphQLFederationParser.LPAREN = 54;
	GraphQLFederationParser.RPAREN = 55;
	GraphQLFederationParser.AT = 56;
	GraphQLFederationParser.AMP = 57;
	GraphQLFederationParser.EQ = 58;
	GraphQLFederationParser.COLON = 59;
	GraphQLFederationParser.ELLIPSIS = 60;
	GraphQLFederationParser.EXCL = 61;
	GraphQLFederationParser.VSLASH = 62;
	GraphQLFederationParser.DOLLAR = 63;
	GraphQLFederationParser.DQUOTE = 64;
	GraphQLFederationParser.TRUE = 65;
	GraphQLFederationParser.FALSE = 66;
	GraphQLFederationParser.NULL = 67;
	GraphQLFederationParser.NAME = 68;
	GraphQLFederationParser.STRING = 69;
	GraphQLFederationParser.BLOCK_STRING = 70;
	GraphQLFederationParser.FLOAT = 71;
	GraphQLFederationParser.INT = 72;
	GraphQLFederationParser.WS = 73;
	GraphQLFederationParser.COMMA = 74;
	GraphQLFederationParser.LineComment = 75;
	GraphQLFederationParser.UNICODE_BOM = 76;
	GraphQLFederationParser.UTF8_BOM = 77;
	GraphQLFederationParser.UTF16_BOM = 78;
	GraphQLFederationParser.UTF32_BOM = 79;
	GraphQLFederationParser.FIELDS_KEYWORD = 80;
	GraphQLFederationParser.FROM_KEYWORD = 81;
	GraphQLFederationParser.RESOLVABLE_KEYWORD = 82;
	GraphQLFederationParser.TRUE_F = 83;
	GraphQLFederationParser.FALSE_F = 84;
	GraphQLFederationParser.WS_F = 85;
	GraphQLFederationParser.NAME_F = 86;
	GraphQLFederationParser.DQUOTE_F = 87;
	GraphQLFederationParser.COLON_F = 88;
	GraphQLFederationParser.LBRACE_F = 89;
	GraphQLFederationParser.RBRACE_F = 90;
	GraphQLFederationParser.LPAREN_F = 91;
	GraphQLFederationParser.RPAREN_F = 92;
	GraphQLFederationParser.INPUT_KEYWORD_F = 93;
	GraphQLFederationParser.TYPE_KEYWORD_F = 94;
	GraphQLFederationParser.ENUM_KEYWORD_F = 95;
	GraphQLFederationParser.SCALAR_KEYWORD_F = 96;
	GraphQLFederationParser.INTERFACE_KEYWORD_F = 97;
	GraphQLFederationParser.DIRECTIVE_KEYWORD_F = 98;
	GraphQLFederationParser.EXTEND_KEYWORD_F = 99;
	GraphQLFederationParser.UNION_KEYWORD_F = 100;
	GraphQLFederationParser.IMPLEMENTS_KEYWORD_F = 101;
	GraphQLFederationParser.QUERY_KEYWORD_F = 102;
	GraphQLFederationParser.MUTATION_KEYWORD_F = 103;
	GraphQLFederationParser.SUBSCRIPTION_KEYWORD_F = 104;
	GraphQLFederationParser.SCHEMA_KEYWORD_F = 105;
	GraphQLFederationParser.FRAGMENT_KEYWORD_F = 106;
	GraphQLFederationParser.ON_KEYWORD_F = 107;
	GraphQLFederationParser.REPEATABLE_KEYWORD_F = 108;
	GraphQLFederationParser.COMMA_F = 109;
	GraphQLFederationParser.STRING_LINK = 110;
	GraphQLFederationParser.WS_LINK = 111;
	GraphQLFederationParser.RULE_document = 0;
	GraphQLFederationParser.RULE_definition = 1;
	GraphQLFederationParser.RULE_executableDefinition = 2;
	GraphQLFederationParser.RULE_operationDefinition = 3;
	GraphQLFederationParser.RULE_operationType = 4;
	GraphQLFederationParser.RULE_selectionSet = 5;
	GraphQLFederationParser.RULE_selection = 6;
	GraphQLFederationParser.RULE_field = 7;
	GraphQLFederationParser.RULE_arguments = 8;
	GraphQLFederationParser.RULE_argument = 9;
	GraphQLFederationParser.RULE_alias = 10;
	GraphQLFederationParser.RULE_fragmentSpread = 11;
	GraphQLFederationParser.RULE_fragmentDefinition = 12;
	GraphQLFederationParser.RULE_fragmentName = 13;
	GraphQLFederationParser.RULE_typeCondition = 14;
	GraphQLFederationParser.RULE_inlineFragment = 15;
	GraphQLFederationParser.RULE_value = 16;
	GraphQLFederationParser.RULE_intValue = 17;
	GraphQLFederationParser.RULE_floatValue = 18;
	GraphQLFederationParser.RULE_booleanValue = 19;
	GraphQLFederationParser.RULE_stringValue = 20;
	GraphQLFederationParser.RULE_nullValue = 21;
	GraphQLFederationParser.RULE_enumValue = 22;
	GraphQLFederationParser.RULE_listValue = 23;
	GraphQLFederationParser.RULE_objectValue = 24;
	GraphQLFederationParser.RULE_objectField = 25;
	GraphQLFederationParser.RULE_variable = 26;
	GraphQLFederationParser.RULE_variableDefinitions = 27;
	GraphQLFederationParser.RULE_variableDefinition = 28;
	GraphQLFederationParser.RULE_defaultValue = 29;
	GraphQLFederationParser.RULE_type_ = 30;
	GraphQLFederationParser.RULE_namedType = 31;
	GraphQLFederationParser.RULE_listType = 32;
	GraphQLFederationParser.RULE_directives = 33;
	GraphQLFederationParser.RULE_directive = 34;
	GraphQLFederationParser.RULE_typeSystemDefinition = 35;
	GraphQLFederationParser.RULE_typeSystemExtension = 36;
	GraphQLFederationParser.RULE_schemaDefinition = 37;
	GraphQLFederationParser.RULE_rootOperationTypeDefinition = 38;
	GraphQLFederationParser.RULE_schemaExtension = 39;
	GraphQLFederationParser.RULE_operationTypeDefinition = 40;
	GraphQLFederationParser.RULE_description = 41;
	GraphQLFederationParser.RULE_typeDefinition = 42;
	GraphQLFederationParser.RULE_typeExtension = 43;
	GraphQLFederationParser.RULE_scalarTypeDefinition = 44;
	GraphQLFederationParser.RULE_scalarTypeExtension = 45;
	GraphQLFederationParser.RULE_objectTypeDefinition = 46;
	GraphQLFederationParser.RULE_implementsInterfaces = 47;
	GraphQLFederationParser.RULE_fieldsDefinition = 48;
	GraphQLFederationParser.RULE_fieldDefinition = 49;
	GraphQLFederationParser.RULE_argumentsDefinition = 50;
	GraphQLFederationParser.RULE_inputValueDefinition = 51;
	GraphQLFederationParser.RULE_objectTypeExtension = 52;
	GraphQLFederationParser.RULE_interfaceTypeDefinition = 53;
	GraphQLFederationParser.RULE_interfaceTypeExtension = 54;
	GraphQLFederationParser.RULE_unionTypeDefinition = 55;
	GraphQLFederationParser.RULE_unionMemberTypes = 56;
	GraphQLFederationParser.RULE_unionTypeExtension = 57;
	GraphQLFederationParser.RULE_enumTypeDefinition = 58;
	GraphQLFederationParser.RULE_enumValuesDefinition = 59;
	GraphQLFederationParser.RULE_enumValueDefinition = 60;
	GraphQLFederationParser.RULE_enumTypeExtension = 61;
	GraphQLFederationParser.RULE_inputObjectTypeDefinition = 62;
	GraphQLFederationParser.RULE_inputFieldsDefinition = 63;
	GraphQLFederationParser.RULE_inputObjectTypeExtension = 64;
	GraphQLFederationParser.RULE_directiveDefinition = 65;
	GraphQLFederationParser.RULE_directiveLocations = 66;
	GraphQLFederationParser.RULE_directiveLocation = 67;
	GraphQLFederationParser.RULE_executableDirectiveLocation = 68;
	GraphQLFederationParser.RULE_typeSystemDirectiveLocation = 69;
	GraphQLFederationParser.RULE_externalDirective = 70;
	GraphQLFederationParser.RULE_inaccessibleDirective = 71;
	GraphQLFederationParser.RULE_requiresDirective = 72;
	GraphQLFederationParser.RULE_providesDirective = 73;
	GraphQLFederationParser.RULE_keyDirective = 74;
	GraphQLFederationParser.RULE_shareableDirective = 75;
	GraphQLFederationParser.RULE_overrideDirective = 76;
	GraphQLFederationParser.RULE_linkDirective = 77;
	GraphQLFederationParser.RULE_fieldSet = 78;
	GraphQLFederationParser.RULE_fieldSetComponent = 79;
	GraphQLFederationParser.RULE_nestedFieldSet = 80;
	GraphQLFederationParser.RULE_schemaDirective = 81;
	GraphQLFederationParser.RULE_schemaFederationDirective = 82;
	GraphQLFederationParser.RULE_scalarDirective = 83;
	GraphQLFederationParser.RULE_scalarFederationDirective = 84;
	GraphQLFederationParser.RULE_objectDirective = 85;
	GraphQLFederationParser.RULE_objectFederationDirective = 86;
	GraphQLFederationParser.RULE_interfaceDirective = 87;
	GraphQLFederationParser.RULE_interfaceFederationDirective = 88;
	GraphQLFederationParser.RULE_unionDirective = 89;
	GraphQLFederationParser.RULE_unionFederationDirective = 90;
	GraphQLFederationParser.RULE_enumDirective = 91;
	GraphQLFederationParser.RULE_enumFederationDirective = 92;
	GraphQLFederationParser.RULE_inputObjectDirective = 93;
	GraphQLFederationParser.RULE_inputObjectFederationDirective = 94;
	GraphQLFederationParser.RULE_inputValueDirective = 95;
	GraphQLFederationParser.RULE_inputFieldFederationDirective = 96;
	GraphQLFederationParser.RULE_fieldDirective = 97;
	GraphQLFederationParser.RULE_fieldFederationDirective = 98;
	GraphQLFederationParser.RULE_enumValueDirective = 99;
	GraphQLFederationParser.RULE_enumValueFederationDirective = 100;
	GraphQLFederationParser.RULE_name = 101;
	GraphQLFederationParser.RULE_name_f = 102;
	GraphQLFederationParser.RULE_booleanValue_f = 103;
	GraphQLFederationParser.RULE_keyword = 104;
	GraphQLFederationParser.RULE_keyword_f = 105;

	var DocumentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon) {
	  _inherits(DocumentContext, _antlr4$ParserRuleCon);

	  var _super2 = _createSuper(DocumentContext);

	  function DocumentContext(parser, parent, invokingState) {
	    var _this2;

	    _classCallCheck(this, DocumentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this2 = _super2.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this2), "definition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(DefinitionContext);
	      } else {
	        return this.getTypedRuleContext(DefinitionContext, i);
	      }
	    });

	    _this2.parser = parser;
	    _this2.ruleIndex = GraphQLFederationParser.RULE_document;
	    return _this2;
	  }

	  _createClass(DocumentContext, [{
	    key: "EOF",
	    value: function EOF() {
	      return this.getToken(GraphQLFederationParser.EOF, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDocument(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDocument(this);
	      }
	    }
	  }]);

	  return DocumentContext;
	}(_antlr["default"].ParserRuleContext);

	var DefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon2) {
	  _inherits(DefinitionContext, _antlr4$ParserRuleCon2);

	  var _super3 = _createSuper(DefinitionContext);

	  function DefinitionContext(parser, parent, invokingState) {
	    var _this3;

	    _classCallCheck(this, DefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this3 = _super3.call(this, parent, invokingState);
	    _this3.parser = parser;
	    _this3.ruleIndex = GraphQLFederationParser.RULE_definition;
	    return _this3;
	  }

	  _createClass(DefinitionContext, [{
	    key: "executableDefinition",
	    value: function executableDefinition() {
	      return this.getTypedRuleContext(ExecutableDefinitionContext, 0);
	    }
	  }, {
	    key: "typeSystemDefinition",
	    value: function typeSystemDefinition() {
	      return this.getTypedRuleContext(TypeSystemDefinitionContext, 0);
	    }
	  }, {
	    key: "typeSystemExtension",
	    value: function typeSystemExtension() {
	      return this.getTypedRuleContext(TypeSystemExtensionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDefinition(this);
	      }
	    }
	  }]);

	  return DefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ExecutableDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon3) {
	  _inherits(ExecutableDefinitionContext, _antlr4$ParserRuleCon3);

	  var _super4 = _createSuper(ExecutableDefinitionContext);

	  function ExecutableDefinitionContext(parser, parent, invokingState) {
	    var _this4;

	    _classCallCheck(this, ExecutableDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this4 = _super4.call(this, parent, invokingState);
	    _this4.parser = parser;
	    _this4.ruleIndex = GraphQLFederationParser.RULE_executableDefinition;
	    return _this4;
	  }

	  _createClass(ExecutableDefinitionContext, [{
	    key: "operationDefinition",
	    value: function operationDefinition() {
	      return this.getTypedRuleContext(OperationDefinitionContext, 0);
	    }
	  }, {
	    key: "fragmentDefinition",
	    value: function fragmentDefinition() {
	      return this.getTypedRuleContext(FragmentDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterExecutableDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitExecutableDefinition(this);
	      }
	    }
	  }]);

	  return ExecutableDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var OperationDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon4) {
	  _inherits(OperationDefinitionContext, _antlr4$ParserRuleCon4);

	  var _super5 = _createSuper(OperationDefinitionContext);

	  function OperationDefinitionContext(parser, parent, invokingState) {
	    var _this5;

	    _classCallCheck(this, OperationDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this5 = _super5.call(this, parent, invokingState);
	    _this5.parser = parser;
	    _this5.ruleIndex = GraphQLFederationParser.RULE_operationDefinition;
	    return _this5;
	  }

	  _createClass(OperationDefinitionContext, [{
	    key: "operationType",
	    value: function operationType() {
	      return this.getTypedRuleContext(OperationTypeContext, 0);
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      return this.getTypedRuleContext(SelectionSetContext, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "variableDefinitions",
	    value: function variableDefinitions() {
	      return this.getTypedRuleContext(VariableDefinitionsContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterOperationDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitOperationDefinition(this);
	      }
	    }
	  }]);

	  return OperationDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var OperationTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon5) {
	  _inherits(OperationTypeContext, _antlr4$ParserRuleCon5);

	  var _super6 = _createSuper(OperationTypeContext);

	  function OperationTypeContext(parser, parent, invokingState) {
	    var _this6;

	    _classCallCheck(this, OperationTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this6 = _super6.call(this, parent, invokingState);
	    _this6.parser = parser;
	    _this6.ruleIndex = GraphQLFederationParser.RULE_operationType;
	    return _this6;
	  }

	  _createClass(OperationTypeContext, [{
	    key: "QUERY_KEYWORD",
	    value: function QUERY_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.QUERY_KEYWORD, 0);
	    }
	  }, {
	    key: "MUTATION_KEYWORD",
	    value: function MUTATION_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.MUTATION_KEYWORD, 0);
	    }
	  }, {
	    key: "SUBSCRIPTION_KEYWORD",
	    value: function SUBSCRIPTION_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.SUBSCRIPTION_KEYWORD, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterOperationType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitOperationType(this);
	      }
	    }
	  }]);

	  return OperationTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var SelectionSetContext = /*#__PURE__*/function (_antlr4$ParserRuleCon6) {
	  _inherits(SelectionSetContext, _antlr4$ParserRuleCon6);

	  var _super7 = _createSuper(SelectionSetContext);

	  function SelectionSetContext(parser, parent, invokingState) {
	    var _this7;

	    _classCallCheck(this, SelectionSetContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this7 = _super7.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this7), "selection", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(SelectionContext);
	      } else {
	        return this.getTypedRuleContext(SelectionContext, i);
	      }
	    });

	    _this7.parser = parser;
	    _this7.ruleIndex = GraphQLFederationParser.RULE_selectionSet;
	    return _this7;
	  }

	  _createClass(SelectionSetContext, [{
	    key: "LBRACE",
	    value: function LBRACE() {
	      return this.getToken(GraphQLFederationParser.LBRACE, 0);
	    }
	  }, {
	    key: "RBRACE",
	    value: function RBRACE() {
	      return this.getToken(GraphQLFederationParser.RBRACE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterSelectionSet(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitSelectionSet(this);
	      }
	    }
	  }]);

	  return SelectionSetContext;
	}(_antlr["default"].ParserRuleContext);

	var SelectionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon7) {
	  _inherits(SelectionContext, _antlr4$ParserRuleCon7);

	  var _super8 = _createSuper(SelectionContext);

	  function SelectionContext(parser, parent, invokingState) {
	    var _this8;

	    _classCallCheck(this, SelectionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this8 = _super8.call(this, parent, invokingState);
	    _this8.parser = parser;
	    _this8.ruleIndex = GraphQLFederationParser.RULE_selection;
	    return _this8;
	  }

	  _createClass(SelectionContext, [{
	    key: "field",
	    value: function field() {
	      return this.getTypedRuleContext(FieldContext, 0);
	    }
	  }, {
	    key: "fragmentSpread",
	    value: function fragmentSpread() {
	      return this.getTypedRuleContext(FragmentSpreadContext, 0);
	    }
	  }, {
	    key: "inlineFragment",
	    value: function inlineFragment() {
	      return this.getTypedRuleContext(InlineFragmentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterSelection(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitSelection(this);
	      }
	    }
	  }]);

	  return SelectionContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldContext = /*#__PURE__*/function (_antlr4$ParserRuleCon8) {
	  _inherits(FieldContext, _antlr4$ParserRuleCon8);

	  var _super9 = _createSuper(FieldContext);

	  function FieldContext(parser, parent, invokingState) {
	    var _this9;

	    _classCallCheck(this, FieldContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this9 = _super9.call(this, parent, invokingState);
	    _this9.parser = parser;
	    _this9.ruleIndex = GraphQLFederationParser.RULE_field;
	    return _this9;
	  }

	  _createClass(FieldContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "alias",
	    value: function alias() {
	      return this.getTypedRuleContext(AliasContext, 0);
	    }
	  }, {
	    key: "arguments",
	    value: function _arguments() {
	      return this.getTypedRuleContext(ArgumentsContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      return this.getTypedRuleContext(SelectionSetContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterField(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitField(this);
	      }
	    }
	  }]);

	  return FieldContext;
	}(_antlr["default"].ParserRuleContext);

	var ArgumentsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon9) {
	  _inherits(ArgumentsContext, _antlr4$ParserRuleCon9);

	  var _super10 = _createSuper(ArgumentsContext);

	  function ArgumentsContext(parser, parent, invokingState) {
	    var _this10;

	    _classCallCheck(this, ArgumentsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this10 = _super10.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this10), "argument", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ArgumentContext);
	      } else {
	        return this.getTypedRuleContext(ArgumentContext, i);
	      }
	    });

	    _this10.parser = parser;
	    _this10.ruleIndex = GraphQLFederationParser.RULE_arguments;
	    return _this10;
	  }

	  _createClass(ArgumentsContext, [{
	    key: "LPAREN",
	    value: function LPAREN() {
	      return this.getToken(GraphQLFederationParser.LPAREN, 0);
	    }
	  }, {
	    key: "RPAREN",
	    value: function RPAREN() {
	      return this.getToken(GraphQLFederationParser.RPAREN, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterArguments(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitArguments(this);
	      }
	    }
	  }]);

	  return ArgumentsContext;
	}(_antlr["default"].ParserRuleContext);

	var ArgumentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon10) {
	  _inherits(ArgumentContext, _antlr4$ParserRuleCon10);

	  var _super11 = _createSuper(ArgumentContext);

	  function ArgumentContext(parser, parent, invokingState) {
	    var _this11;

	    _classCallCheck(this, ArgumentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this11 = _super11.call(this, parent, invokingState);
	    _this11.parser = parser;
	    _this11.ruleIndex = GraphQLFederationParser.RULE_argument;
	    return _this11;
	  }

	  _createClass(ArgumentContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "COLON",
	    value: function COLON() {
	      return this.getToken(GraphQLFederationParser.COLON, 0);
	    }
	  }, {
	    key: "value",
	    value: function value() {
	      return this.getTypedRuleContext(ValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterArgument(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitArgument(this);
	      }
	    }
	  }]);

	  return ArgumentContext;
	}(_antlr["default"].ParserRuleContext);

	var AliasContext = /*#__PURE__*/function (_antlr4$ParserRuleCon11) {
	  _inherits(AliasContext, _antlr4$ParserRuleCon11);

	  var _super12 = _createSuper(AliasContext);

	  function AliasContext(parser, parent, invokingState) {
	    var _this12;

	    _classCallCheck(this, AliasContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this12 = _super12.call(this, parent, invokingState);
	    _this12.parser = parser;
	    _this12.ruleIndex = GraphQLFederationParser.RULE_alias;
	    return _this12;
	  }

	  _createClass(AliasContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "COLON",
	    value: function COLON() {
	      return this.getToken(GraphQLFederationParser.COLON, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterAlias(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitAlias(this);
	      }
	    }
	  }]);

	  return AliasContext;
	}(_antlr["default"].ParserRuleContext);

	var FragmentSpreadContext = /*#__PURE__*/function (_antlr4$ParserRuleCon12) {
	  _inherits(FragmentSpreadContext, _antlr4$ParserRuleCon12);

	  var _super13 = _createSuper(FragmentSpreadContext);

	  function FragmentSpreadContext(parser, parent, invokingState) {
	    var _this13;

	    _classCallCheck(this, FragmentSpreadContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this13 = _super13.call(this, parent, invokingState);
	    _this13.parser = parser;
	    _this13.ruleIndex = GraphQLFederationParser.RULE_fragmentSpread;
	    return _this13;
	  }

	  _createClass(FragmentSpreadContext, [{
	    key: "ELLIPSIS",
	    value: function ELLIPSIS() {
	      return this.getToken(GraphQLFederationParser.ELLIPSIS, 0);
	    }
	  }, {
	    key: "fragmentName",
	    value: function fragmentName() {
	      return this.getTypedRuleContext(FragmentNameContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFragmentSpread(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFragmentSpread(this);
	      }
	    }
	  }]);

	  return FragmentSpreadContext;
	}(_antlr["default"].ParserRuleContext);

	var FragmentDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon13) {
	  _inherits(FragmentDefinitionContext, _antlr4$ParserRuleCon13);

	  var _super14 = _createSuper(FragmentDefinitionContext);

	  function FragmentDefinitionContext(parser, parent, invokingState) {
	    var _this14;

	    _classCallCheck(this, FragmentDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this14 = _super14.call(this, parent, invokingState);
	    _this14.parser = parser;
	    _this14.ruleIndex = GraphQLFederationParser.RULE_fragmentDefinition;
	    return _this14;
	  }

	  _createClass(FragmentDefinitionContext, [{
	    key: "FRAGMENT_KEYWORD",
	    value: function FRAGMENT_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.FRAGMENT_KEYWORD, 0);
	    }
	  }, {
	    key: "fragmentName",
	    value: function fragmentName() {
	      return this.getTypedRuleContext(FragmentNameContext, 0);
	    }
	  }, {
	    key: "typeCondition",
	    value: function typeCondition() {
	      return this.getTypedRuleContext(TypeConditionContext, 0);
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      return this.getTypedRuleContext(SelectionSetContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFragmentDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFragmentDefinition(this);
	      }
	    }
	  }]);

	  return FragmentDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var FragmentNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon14) {
	  _inherits(FragmentNameContext, _antlr4$ParserRuleCon14);

	  var _super15 = _createSuper(FragmentNameContext);

	  function FragmentNameContext(parser, parent, invokingState) {
	    var _this15;

	    _classCallCheck(this, FragmentNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this15 = _super15.call(this, parent, invokingState);
	    _this15.parser = parser;
	    _this15.ruleIndex = GraphQLFederationParser.RULE_fragmentName;
	    return _this15;
	  }

	  _createClass(FragmentNameContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFragmentName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFragmentName(this);
	      }
	    }
	  }]);

	  return FragmentNameContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeConditionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon15) {
	  _inherits(TypeConditionContext, _antlr4$ParserRuleCon15);

	  var _super16 = _createSuper(TypeConditionContext);

	  function TypeConditionContext(parser, parent, invokingState) {
	    var _this16;

	    _classCallCheck(this, TypeConditionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this16 = _super16.call(this, parent, invokingState);
	    _this16.parser = parser;
	    _this16.ruleIndex = GraphQLFederationParser.RULE_typeCondition;
	    return _this16;
	  }

	  _createClass(TypeConditionContext, [{
	    key: "ON_KEYWORD",
	    value: function ON_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.ON_KEYWORD, 0);
	    }
	  }, {
	    key: "namedType",
	    value: function namedType() {
	      return this.getTypedRuleContext(NamedTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterTypeCondition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitTypeCondition(this);
	      }
	    }
	  }]);

	  return TypeConditionContext;
	}(_antlr["default"].ParserRuleContext);

	var InlineFragmentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon16) {
	  _inherits(InlineFragmentContext, _antlr4$ParserRuleCon16);

	  var _super17 = _createSuper(InlineFragmentContext);

	  function InlineFragmentContext(parser, parent, invokingState) {
	    var _this17;

	    _classCallCheck(this, InlineFragmentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this17 = _super17.call(this, parent, invokingState);
	    _this17.parser = parser;
	    _this17.ruleIndex = GraphQLFederationParser.RULE_inlineFragment;
	    return _this17;
	  }

	  _createClass(InlineFragmentContext, [{
	    key: "ELLIPSIS",
	    value: function ELLIPSIS() {
	      return this.getToken(GraphQLFederationParser.ELLIPSIS, 0);
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      return this.getTypedRuleContext(SelectionSetContext, 0);
	    }
	  }, {
	    key: "typeCondition",
	    value: function typeCondition() {
	      return this.getTypedRuleContext(TypeConditionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInlineFragment(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInlineFragment(this);
	      }
	    }
	  }]);

	  return InlineFragmentContext;
	}(_antlr["default"].ParserRuleContext);

	var ValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon17) {
	  _inherits(ValueContext, _antlr4$ParserRuleCon17);

	  var _super18 = _createSuper(ValueContext);

	  function ValueContext(parser, parent, invokingState) {
	    var _this18;

	    _classCallCheck(this, ValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this18 = _super18.call(this, parent, invokingState);
	    _this18.parser = parser;
	    _this18.ruleIndex = GraphQLFederationParser.RULE_value;
	    return _this18;
	  }

	  _createClass(ValueContext, [{
	    key: "variable",
	    value: function variable() {
	      return this.getTypedRuleContext(VariableContext, 0);
	    }
	  }, {
	    key: "intValue",
	    value: function intValue() {
	      return this.getTypedRuleContext(IntValueContext, 0);
	    }
	  }, {
	    key: "floatValue",
	    value: function floatValue() {
	      return this.getTypedRuleContext(FloatValueContext, 0);
	    }
	  }, {
	    key: "stringValue",
	    value: function stringValue() {
	      return this.getTypedRuleContext(StringValueContext, 0);
	    }
	  }, {
	    key: "booleanValue",
	    value: function booleanValue() {
	      return this.getTypedRuleContext(BooleanValueContext, 0);
	    }
	  }, {
	    key: "nullValue",
	    value: function nullValue() {
	      return this.getTypedRuleContext(NullValueContext, 0);
	    }
	  }, {
	    key: "enumValue",
	    value: function enumValue() {
	      return this.getTypedRuleContext(EnumValueContext, 0);
	    }
	  }, {
	    key: "listValue",
	    value: function listValue() {
	      return this.getTypedRuleContext(ListValueContext, 0);
	    }
	  }, {
	    key: "objectValue",
	    value: function objectValue() {
	      return this.getTypedRuleContext(ObjectValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitValue(this);
	      }
	    }
	  }]);

	  return ValueContext;
	}(_antlr["default"].ParserRuleContext);

	var IntValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon18) {
	  _inherits(IntValueContext, _antlr4$ParserRuleCon18);

	  var _super19 = _createSuper(IntValueContext);

	  function IntValueContext(parser, parent, invokingState) {
	    var _this19;

	    _classCallCheck(this, IntValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this19 = _super19.call(this, parent, invokingState);
	    _this19.parser = parser;
	    _this19.ruleIndex = GraphQLFederationParser.RULE_intValue;
	    return _this19;
	  }

	  _createClass(IntValueContext, [{
	    key: "INT",
	    value: function INT() {
	      return this.getToken(GraphQLFederationParser.INT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterIntValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitIntValue(this);
	      }
	    }
	  }]);

	  return IntValueContext;
	}(_antlr["default"].ParserRuleContext);

	var FloatValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon19) {
	  _inherits(FloatValueContext, _antlr4$ParserRuleCon19);

	  var _super20 = _createSuper(FloatValueContext);

	  function FloatValueContext(parser, parent, invokingState) {
	    var _this20;

	    _classCallCheck(this, FloatValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this20 = _super20.call(this, parent, invokingState);
	    _this20.parser = parser;
	    _this20.ruleIndex = GraphQLFederationParser.RULE_floatValue;
	    return _this20;
	  }

	  _createClass(FloatValueContext, [{
	    key: "FLOAT",
	    value: function FLOAT() {
	      return this.getToken(GraphQLFederationParser.FLOAT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFloatValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFloatValue(this);
	      }
	    }
	  }]);

	  return FloatValueContext;
	}(_antlr["default"].ParserRuleContext);

	var BooleanValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon20) {
	  _inherits(BooleanValueContext, _antlr4$ParserRuleCon20);

	  var _super21 = _createSuper(BooleanValueContext);

	  function BooleanValueContext(parser, parent, invokingState) {
	    var _this21;

	    _classCallCheck(this, BooleanValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this21 = _super21.call(this, parent, invokingState);
	    _this21.parser = parser;
	    _this21.ruleIndex = GraphQLFederationParser.RULE_booleanValue;
	    return _this21;
	  }

	  _createClass(BooleanValueContext, [{
	    key: "TRUE",
	    value: function TRUE() {
	      return this.getToken(GraphQLFederationParser.TRUE, 0);
	    }
	  }, {
	    key: "FALSE",
	    value: function FALSE() {
	      return this.getToken(GraphQLFederationParser.FALSE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterBooleanValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitBooleanValue(this);
	      }
	    }
	  }]);

	  return BooleanValueContext;
	}(_antlr["default"].ParserRuleContext);

	var StringValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon21) {
	  _inherits(StringValueContext, _antlr4$ParserRuleCon21);

	  var _super22 = _createSuper(StringValueContext);

	  function StringValueContext(parser, parent, invokingState) {
	    var _this22;

	    _classCallCheck(this, StringValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this22 = _super22.call(this, parent, invokingState);
	    _this22.parser = parser;
	    _this22.ruleIndex = GraphQLFederationParser.RULE_stringValue;
	    return _this22;
	  }

	  _createClass(StringValueContext, [{
	    key: "STRING",
	    value: function STRING() {
	      return this.getToken(GraphQLFederationParser.STRING, 0);
	    }
	  }, {
	    key: "BLOCK_STRING",
	    value: function BLOCK_STRING() {
	      return this.getToken(GraphQLFederationParser.BLOCK_STRING, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterStringValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitStringValue(this);
	      }
	    }
	  }]);

	  return StringValueContext;
	}(_antlr["default"].ParserRuleContext);

	var NullValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon22) {
	  _inherits(NullValueContext, _antlr4$ParserRuleCon22);

	  var _super23 = _createSuper(NullValueContext);

	  function NullValueContext(parser, parent, invokingState) {
	    var _this23;

	    _classCallCheck(this, NullValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this23 = _super23.call(this, parent, invokingState);
	    _this23.parser = parser;
	    _this23.ruleIndex = GraphQLFederationParser.RULE_nullValue;
	    return _this23;
	  }

	  _createClass(NullValueContext, [{
	    key: "NULL",
	    value: function NULL() {
	      return this.getToken(GraphQLFederationParser.NULL, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterNullValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitNullValue(this);
	      }
	    }
	  }]);

	  return NullValueContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon23) {
	  _inherits(EnumValueContext, _antlr4$ParserRuleCon23);

	  var _super24 = _createSuper(EnumValueContext);

	  function EnumValueContext(parser, parent, invokingState) {
	    var _this24;

	    _classCallCheck(this, EnumValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this24 = _super24.call(this, parent, invokingState);
	    _this24.parser = parser;
	    _this24.ruleIndex = GraphQLFederationParser.RULE_enumValue;
	    return _this24;
	  }

	  _createClass(EnumValueContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumValue(this);
	      }
	    }
	  }]);

	  return EnumValueContext;
	}(_antlr["default"].ParserRuleContext);

	var ListValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon24) {
	  _inherits(ListValueContext, _antlr4$ParserRuleCon24);

	  var _super25 = _createSuper(ListValueContext);

	  function ListValueContext(parser, parent, invokingState) {
	    var _this25;

	    _classCallCheck(this, ListValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this25 = _super25.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this25), "value", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ValueContext);
	      } else {
	        return this.getTypedRuleContext(ValueContext, i);
	      }
	    });

	    _this25.parser = parser;
	    _this25.ruleIndex = GraphQLFederationParser.RULE_listValue;
	    return _this25;
	  }

	  _createClass(ListValueContext, [{
	    key: "LBRACKET",
	    value: function LBRACKET() {
	      return this.getToken(GraphQLFederationParser.LBRACKET, 0);
	    }
	  }, {
	    key: "RBRACKET",
	    value: function RBRACKET() {
	      return this.getToken(GraphQLFederationParser.RBRACKET, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterListValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitListValue(this);
	      }
	    }
	  }]);

	  return ListValueContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon25) {
	  _inherits(ObjectValueContext, _antlr4$ParserRuleCon25);

	  var _super26 = _createSuper(ObjectValueContext);

	  function ObjectValueContext(parser, parent, invokingState) {
	    var _this26;

	    _classCallCheck(this, ObjectValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this26 = _super26.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this26), "objectField", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ObjectFieldContext);
	      } else {
	        return this.getTypedRuleContext(ObjectFieldContext, i);
	      }
	    });

	    _this26.parser = parser;
	    _this26.ruleIndex = GraphQLFederationParser.RULE_objectValue;
	    return _this26;
	  }

	  _createClass(ObjectValueContext, [{
	    key: "LBRACE",
	    value: function LBRACE() {
	      return this.getToken(GraphQLFederationParser.LBRACE, 0);
	    }
	  }, {
	    key: "RBRACE",
	    value: function RBRACE() {
	      return this.getToken(GraphQLFederationParser.RBRACE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterObjectValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitObjectValue(this);
	      }
	    }
	  }]);

	  return ObjectValueContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectFieldContext = /*#__PURE__*/function (_antlr4$ParserRuleCon26) {
	  _inherits(ObjectFieldContext, _antlr4$ParserRuleCon26);

	  var _super27 = _createSuper(ObjectFieldContext);

	  function ObjectFieldContext(parser, parent, invokingState) {
	    var _this27;

	    _classCallCheck(this, ObjectFieldContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this27 = _super27.call(this, parent, invokingState);
	    _this27.parser = parser;
	    _this27.ruleIndex = GraphQLFederationParser.RULE_objectField;
	    return _this27;
	  }

	  _createClass(ObjectFieldContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "COLON",
	    value: function COLON() {
	      return this.getToken(GraphQLFederationParser.COLON, 0);
	    }
	  }, {
	    key: "value",
	    value: function value() {
	      return this.getTypedRuleContext(ValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterObjectField(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitObjectField(this);
	      }
	    }
	  }]);

	  return ObjectFieldContext;
	}(_antlr["default"].ParserRuleContext);

	var VariableContext = /*#__PURE__*/function (_antlr4$ParserRuleCon27) {
	  _inherits(VariableContext, _antlr4$ParserRuleCon27);

	  var _super28 = _createSuper(VariableContext);

	  function VariableContext(parser, parent, invokingState) {
	    var _this28;

	    _classCallCheck(this, VariableContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this28 = _super28.call(this, parent, invokingState);
	    _this28.parser = parser;
	    _this28.ruleIndex = GraphQLFederationParser.RULE_variable;
	    return _this28;
	  }

	  _createClass(VariableContext, [{
	    key: "DOLLAR",
	    value: function DOLLAR() {
	      return this.getToken(GraphQLFederationParser.DOLLAR, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterVariable(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitVariable(this);
	      }
	    }
	  }]);

	  return VariableContext;
	}(_antlr["default"].ParserRuleContext);

	var VariableDefinitionsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon28) {
	  _inherits(VariableDefinitionsContext, _antlr4$ParserRuleCon28);

	  var _super29 = _createSuper(VariableDefinitionsContext);

	  function VariableDefinitionsContext(parser, parent, invokingState) {
	    var _this29;

	    _classCallCheck(this, VariableDefinitionsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this29 = _super29.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this29), "variableDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(VariableDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(VariableDefinitionContext, i);
	      }
	    });

	    _this29.parser = parser;
	    _this29.ruleIndex = GraphQLFederationParser.RULE_variableDefinitions;
	    return _this29;
	  }

	  _createClass(VariableDefinitionsContext, [{
	    key: "LPAREN",
	    value: function LPAREN() {
	      return this.getToken(GraphQLFederationParser.LPAREN, 0);
	    }
	  }, {
	    key: "RPAREN",
	    value: function RPAREN() {
	      return this.getToken(GraphQLFederationParser.RPAREN, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterVariableDefinitions(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitVariableDefinitions(this);
	      }
	    }
	  }]);

	  return VariableDefinitionsContext;
	}(_antlr["default"].ParserRuleContext);

	var VariableDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon29) {
	  _inherits(VariableDefinitionContext, _antlr4$ParserRuleCon29);

	  var _super30 = _createSuper(VariableDefinitionContext);

	  function VariableDefinitionContext(parser, parent, invokingState) {
	    var _this30;

	    _classCallCheck(this, VariableDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this30 = _super30.call(this, parent, invokingState);
	    _this30.parser = parser;
	    _this30.ruleIndex = GraphQLFederationParser.RULE_variableDefinition;
	    return _this30;
	  }

	  _createClass(VariableDefinitionContext, [{
	    key: "variable",
	    value: function variable() {
	      return this.getTypedRuleContext(VariableContext, 0);
	    }
	  }, {
	    key: "COLON",
	    value: function COLON() {
	      return this.getToken(GraphQLFederationParser.COLON, 0);
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "defaultValue",
	    value: function defaultValue() {
	      return this.getTypedRuleContext(DefaultValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterVariableDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitVariableDefinition(this);
	      }
	    }
	  }]);

	  return VariableDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var DefaultValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon30) {
	  _inherits(DefaultValueContext, _antlr4$ParserRuleCon30);

	  var _super31 = _createSuper(DefaultValueContext);

	  function DefaultValueContext(parser, parent, invokingState) {
	    var _this31;

	    _classCallCheck(this, DefaultValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this31 = _super31.call(this, parent, invokingState);
	    _this31.parser = parser;
	    _this31.ruleIndex = GraphQLFederationParser.RULE_defaultValue;
	    return _this31;
	  }

	  _createClass(DefaultValueContext, [{
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(GraphQLFederationParser.EQ, 0);
	    }
	  }, {
	    key: "value",
	    value: function value() {
	      return this.getTypedRuleContext(ValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDefaultValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDefaultValue(this);
	      }
	    }
	  }]);

	  return DefaultValueContext;
	}(_antlr["default"].ParserRuleContext);

	var Type_Context = /*#__PURE__*/function (_antlr4$ParserRuleCon31) {
	  _inherits(Type_Context, _antlr4$ParserRuleCon31);

	  var _super32 = _createSuper(Type_Context);

	  function Type_Context(parser, parent, invokingState) {
	    var _this32;

	    _classCallCheck(this, Type_Context);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this32 = _super32.call(this, parent, invokingState);
	    _this32.parser = parser;
	    _this32.ruleIndex = GraphQLFederationParser.RULE_type_;
	    return _this32;
	  }

	  _createClass(Type_Context, [{
	    key: "namedType",
	    value: function namedType() {
	      return this.getTypedRuleContext(NamedTypeContext, 0);
	    }
	  }, {
	    key: "EXCL",
	    value: function EXCL() {
	      return this.getToken(GraphQLFederationParser.EXCL, 0);
	    }
	  }, {
	    key: "listType",
	    value: function listType() {
	      return this.getTypedRuleContext(ListTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterType_(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitType_(this);
	      }
	    }
	  }]);

	  return Type_Context;
	}(_antlr["default"].ParserRuleContext);

	var NamedTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon32) {
	  _inherits(NamedTypeContext, _antlr4$ParserRuleCon32);

	  var _super33 = _createSuper(NamedTypeContext);

	  function NamedTypeContext(parser, parent, invokingState) {
	    var _this33;

	    _classCallCheck(this, NamedTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this33 = _super33.call(this, parent, invokingState);
	    _this33.parser = parser;
	    _this33.ruleIndex = GraphQLFederationParser.RULE_namedType;
	    return _this33;
	  }

	  _createClass(NamedTypeContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterNamedType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitNamedType(this);
	      }
	    }
	  }]);

	  return NamedTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var ListTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon33) {
	  _inherits(ListTypeContext, _antlr4$ParserRuleCon33);

	  var _super34 = _createSuper(ListTypeContext);

	  function ListTypeContext(parser, parent, invokingState) {
	    var _this34;

	    _classCallCheck(this, ListTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this34 = _super34.call(this, parent, invokingState);
	    _this34.parser = parser;
	    _this34.ruleIndex = GraphQLFederationParser.RULE_listType;
	    return _this34;
	  }

	  _createClass(ListTypeContext, [{
	    key: "LBRACKET",
	    value: function LBRACKET() {
	      return this.getToken(GraphQLFederationParser.LBRACKET, 0);
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "RBRACKET",
	    value: function RBRACKET() {
	      return this.getToken(GraphQLFederationParser.RBRACKET, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterListType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitListType(this);
	      }
	    }
	  }]);

	  return ListTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectivesContext = /*#__PURE__*/function (_antlr4$ParserRuleCon34) {
	  _inherits(DirectivesContext, _antlr4$ParserRuleCon34);

	  var _super35 = _createSuper(DirectivesContext);

	  function DirectivesContext(parser, parent, invokingState) {
	    var _this35;

	    _classCallCheck(this, DirectivesContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this35 = _super35.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this35), "directive", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(DirectiveContext);
	      } else {
	        return this.getTypedRuleContext(DirectiveContext, i);
	      }
	    });

	    _this35.parser = parser;
	    _this35.ruleIndex = GraphQLFederationParser.RULE_directives;
	    return _this35;
	  }

	  _createClass(DirectivesContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDirectives(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDirectives(this);
	      }
	    }
	  }]);

	  return DirectivesContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon35) {
	  _inherits(DirectiveContext, _antlr4$ParserRuleCon35);

	  var _super36 = _createSuper(DirectiveContext);

	  function DirectiveContext(parser, parent, invokingState) {
	    var _this36;

	    _classCallCheck(this, DirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this36 = _super36.call(this, parent, invokingState);
	    _this36.parser = parser;
	    _this36.ruleIndex = GraphQLFederationParser.RULE_directive;
	    return _this36;
	  }

	  _createClass(DirectiveContext, [{
	    key: "AT",
	    value: function AT() {
	      return this.getToken(GraphQLFederationParser.AT, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "arguments",
	    value: function _arguments() {
	      return this.getTypedRuleContext(ArgumentsContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDirective(this);
	      }
	    }
	  }]);

	  return DirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeSystemDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon36) {
	  _inherits(TypeSystemDefinitionContext, _antlr4$ParserRuleCon36);

	  var _super37 = _createSuper(TypeSystemDefinitionContext);

	  function TypeSystemDefinitionContext(parser, parent, invokingState) {
	    var _this37;

	    _classCallCheck(this, TypeSystemDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this37 = _super37.call(this, parent, invokingState);
	    _this37.parser = parser;
	    _this37.ruleIndex = GraphQLFederationParser.RULE_typeSystemDefinition;
	    return _this37;
	  }

	  _createClass(TypeSystemDefinitionContext, [{
	    key: "schemaDefinition",
	    value: function schemaDefinition() {
	      return this.getTypedRuleContext(SchemaDefinitionContext, 0);
	    }
	  }, {
	    key: "typeDefinition",
	    value: function typeDefinition() {
	      return this.getTypedRuleContext(TypeDefinitionContext, 0);
	    }
	  }, {
	    key: "directiveDefinition",
	    value: function directiveDefinition() {
	      return this.getTypedRuleContext(DirectiveDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterTypeSystemDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitTypeSystemDefinition(this);
	      }
	    }
	  }]);

	  return TypeSystemDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeSystemExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon37) {
	  _inherits(TypeSystemExtensionContext, _antlr4$ParserRuleCon37);

	  var _super38 = _createSuper(TypeSystemExtensionContext);

	  function TypeSystemExtensionContext(parser, parent, invokingState) {
	    var _this38;

	    _classCallCheck(this, TypeSystemExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this38 = _super38.call(this, parent, invokingState);
	    _this38.parser = parser;
	    _this38.ruleIndex = GraphQLFederationParser.RULE_typeSystemExtension;
	    return _this38;
	  }

	  _createClass(TypeSystemExtensionContext, [{
	    key: "schemaExtension",
	    value: function schemaExtension() {
	      return this.getTypedRuleContext(SchemaExtensionContext, 0);
	    }
	  }, {
	    key: "typeExtension",
	    value: function typeExtension() {
	      return this.getTypedRuleContext(TypeExtensionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterTypeSystemExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitTypeSystemExtension(this);
	      }
	    }
	  }]);

	  return TypeSystemExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var SchemaDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon38) {
	  _inherits(SchemaDefinitionContext, _antlr4$ParserRuleCon38);

	  var _super39 = _createSuper(SchemaDefinitionContext);

	  function SchemaDefinitionContext(parser, parent, invokingState) {
	    var _this39;

	    _classCallCheck(this, SchemaDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this39 = _super39.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this39), "schemaDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(SchemaDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(SchemaDirectiveContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this39), "rootOperationTypeDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(RootOperationTypeDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(RootOperationTypeDefinitionContext, i);
	      }
	    });

	    _this39.parser = parser;
	    _this39.ruleIndex = GraphQLFederationParser.RULE_schemaDefinition;
	    return _this39;
	  }

	  _createClass(SchemaDefinitionContext, [{
	    key: "SCHEMA_KEYWORD",
	    value: function SCHEMA_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.SCHEMA_KEYWORD, 0);
	    }
	  }, {
	    key: "LBRACE",
	    value: function LBRACE() {
	      return this.getToken(GraphQLFederationParser.LBRACE, 0);
	    }
	  }, {
	    key: "RBRACE",
	    value: function RBRACE() {
	      return this.getToken(GraphQLFederationParser.RBRACE, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterSchemaDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitSchemaDefinition(this);
	      }
	    }
	  }]);

	  return SchemaDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var RootOperationTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon39) {
	  _inherits(RootOperationTypeDefinitionContext, _antlr4$ParserRuleCon39);

	  var _super40 = _createSuper(RootOperationTypeDefinitionContext);

	  function RootOperationTypeDefinitionContext(parser, parent, invokingState) {
	    var _this40;

	    _classCallCheck(this, RootOperationTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this40 = _super40.call(this, parent, invokingState);
	    _this40.parser = parser;
	    _this40.ruleIndex = GraphQLFederationParser.RULE_rootOperationTypeDefinition;
	    return _this40;
	  }

	  _createClass(RootOperationTypeDefinitionContext, [{
	    key: "operationType",
	    value: function operationType() {
	      return this.getTypedRuleContext(OperationTypeContext, 0);
	    }
	  }, {
	    key: "COLON",
	    value: function COLON() {
	      return this.getToken(GraphQLFederationParser.COLON, 0);
	    }
	  }, {
	    key: "namedType",
	    value: function namedType() {
	      return this.getTypedRuleContext(NamedTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterRootOperationTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitRootOperationTypeDefinition(this);
	      }
	    }
	  }]);

	  return RootOperationTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var SchemaExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon40) {
	  _inherits(SchemaExtensionContext, _antlr4$ParserRuleCon40);

	  var _super41 = _createSuper(SchemaExtensionContext);

	  function SchemaExtensionContext(parser, parent, invokingState) {
	    var _this41;

	    _classCallCheck(this, SchemaExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this41 = _super41.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this41), "schemaDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(SchemaDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(SchemaDirectiveContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this41), "operationTypeDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(OperationTypeDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(OperationTypeDefinitionContext, i);
	      }
	    });

	    _this41.parser = parser;
	    _this41.ruleIndex = GraphQLFederationParser.RULE_schemaExtension;
	    return _this41;
	  }

	  _createClass(SchemaExtensionContext, [{
	    key: "EXTEND_KEYWORD",
	    value: function EXTEND_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD, 0);
	    }
	  }, {
	    key: "SCHEMA_KEYWORD",
	    value: function SCHEMA_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.SCHEMA_KEYWORD, 0);
	    }
	  }, {
	    key: "LBRACE",
	    value: function LBRACE() {
	      return this.getToken(GraphQLFederationParser.LBRACE, 0);
	    }
	  }, {
	    key: "RBRACE",
	    value: function RBRACE() {
	      return this.getToken(GraphQLFederationParser.RBRACE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterSchemaExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitSchemaExtension(this);
	      }
	    }
	  }]);

	  return SchemaExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var OperationTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon41) {
	  _inherits(OperationTypeDefinitionContext, _antlr4$ParserRuleCon41);

	  var _super42 = _createSuper(OperationTypeDefinitionContext);

	  function OperationTypeDefinitionContext(parser, parent, invokingState) {
	    var _this42;

	    _classCallCheck(this, OperationTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this42 = _super42.call(this, parent, invokingState);
	    _this42.parser = parser;
	    _this42.ruleIndex = GraphQLFederationParser.RULE_operationTypeDefinition;
	    return _this42;
	  }

	  _createClass(OperationTypeDefinitionContext, [{
	    key: "operationType",
	    value: function operationType() {
	      return this.getTypedRuleContext(OperationTypeContext, 0);
	    }
	  }, {
	    key: "COLON",
	    value: function COLON() {
	      return this.getToken(GraphQLFederationParser.COLON, 0);
	    }
	  }, {
	    key: "namedType",
	    value: function namedType() {
	      return this.getTypedRuleContext(NamedTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterOperationTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitOperationTypeDefinition(this);
	      }
	    }
	  }]);

	  return OperationTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var DescriptionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon42) {
	  _inherits(DescriptionContext, _antlr4$ParserRuleCon42);

	  var _super43 = _createSuper(DescriptionContext);

	  function DescriptionContext(parser, parent, invokingState) {
	    var _this43;

	    _classCallCheck(this, DescriptionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this43 = _super43.call(this, parent, invokingState);
	    _this43.parser = parser;
	    _this43.ruleIndex = GraphQLFederationParser.RULE_description;
	    return _this43;
	  }

	  _createClass(DescriptionContext, [{
	    key: "stringValue",
	    value: function stringValue() {
	      return this.getTypedRuleContext(StringValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDescription(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDescription(this);
	      }
	    }
	  }]);

	  return DescriptionContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon43) {
	  _inherits(TypeDefinitionContext, _antlr4$ParserRuleCon43);

	  var _super44 = _createSuper(TypeDefinitionContext);

	  function TypeDefinitionContext(parser, parent, invokingState) {
	    var _this44;

	    _classCallCheck(this, TypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this44 = _super44.call(this, parent, invokingState);
	    _this44.parser = parser;
	    _this44.ruleIndex = GraphQLFederationParser.RULE_typeDefinition;
	    return _this44;
	  }

	  _createClass(TypeDefinitionContext, [{
	    key: "scalarTypeDefinition",
	    value: function scalarTypeDefinition() {
	      return this.getTypedRuleContext(ScalarTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "objectTypeDefinition",
	    value: function objectTypeDefinition() {
	      return this.getTypedRuleContext(ObjectTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "interfaceTypeDefinition",
	    value: function interfaceTypeDefinition() {
	      return this.getTypedRuleContext(InterfaceTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "unionTypeDefinition",
	    value: function unionTypeDefinition() {
	      return this.getTypedRuleContext(UnionTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "enumTypeDefinition",
	    value: function enumTypeDefinition() {
	      return this.getTypedRuleContext(EnumTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "inputObjectTypeDefinition",
	    value: function inputObjectTypeDefinition() {
	      return this.getTypedRuleContext(InputObjectTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitTypeDefinition(this);
	      }
	    }
	  }]);

	  return TypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon44) {
	  _inherits(TypeExtensionContext, _antlr4$ParserRuleCon44);

	  var _super45 = _createSuper(TypeExtensionContext);

	  function TypeExtensionContext(parser, parent, invokingState) {
	    var _this45;

	    _classCallCheck(this, TypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this45 = _super45.call(this, parent, invokingState);
	    _this45.parser = parser;
	    _this45.ruleIndex = GraphQLFederationParser.RULE_typeExtension;
	    return _this45;
	  }

	  _createClass(TypeExtensionContext, [{
	    key: "scalarTypeExtension",
	    value: function scalarTypeExtension() {
	      return this.getTypedRuleContext(ScalarTypeExtensionContext, 0);
	    }
	  }, {
	    key: "objectTypeExtension",
	    value: function objectTypeExtension() {
	      return this.getTypedRuleContext(ObjectTypeExtensionContext, 0);
	    }
	  }, {
	    key: "interfaceTypeExtension",
	    value: function interfaceTypeExtension() {
	      return this.getTypedRuleContext(InterfaceTypeExtensionContext, 0);
	    }
	  }, {
	    key: "unionTypeExtension",
	    value: function unionTypeExtension() {
	      return this.getTypedRuleContext(UnionTypeExtensionContext, 0);
	    }
	  }, {
	    key: "enumTypeExtension",
	    value: function enumTypeExtension() {
	      return this.getTypedRuleContext(EnumTypeExtensionContext, 0);
	    }
	  }, {
	    key: "inputObjectTypeExtension",
	    value: function inputObjectTypeExtension() {
	      return this.getTypedRuleContext(InputObjectTypeExtensionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitTypeExtension(this);
	      }
	    }
	  }]);

	  return TypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var ScalarTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon45) {
	  _inherits(ScalarTypeDefinitionContext, _antlr4$ParserRuleCon45);

	  var _super46 = _createSuper(ScalarTypeDefinitionContext);

	  function ScalarTypeDefinitionContext(parser, parent, invokingState) {
	    var _this46;

	    _classCallCheck(this, ScalarTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this46 = _super46.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this46), "scalarDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ScalarDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(ScalarDirectiveContext, i);
	      }
	    });

	    _this46.parser = parser;
	    _this46.ruleIndex = GraphQLFederationParser.RULE_scalarTypeDefinition;
	    return _this46;
	  }

	  _createClass(ScalarTypeDefinitionContext, [{
	    key: "SCALAR_KEYWORD",
	    value: function SCALAR_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.SCALAR_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterScalarTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitScalarTypeDefinition(this);
	      }
	    }
	  }]);

	  return ScalarTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ScalarTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon46) {
	  _inherits(ScalarTypeExtensionContext, _antlr4$ParserRuleCon46);

	  var _super47 = _createSuper(ScalarTypeExtensionContext);

	  function ScalarTypeExtensionContext(parser, parent, invokingState) {
	    var _this47;

	    _classCallCheck(this, ScalarTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this47 = _super47.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this47), "scalarDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ScalarDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(ScalarDirectiveContext, i);
	      }
	    });

	    _this47.parser = parser;
	    _this47.ruleIndex = GraphQLFederationParser.RULE_scalarTypeExtension;
	    return _this47;
	  }

	  _createClass(ScalarTypeExtensionContext, [{
	    key: "EXTEND_KEYWORD",
	    value: function EXTEND_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD, 0);
	    }
	  }, {
	    key: "SCALAR_KEYWORD",
	    value: function SCALAR_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.SCALAR_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterScalarTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitScalarTypeExtension(this);
	      }
	    }
	  }]);

	  return ScalarTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon47) {
	  _inherits(ObjectTypeDefinitionContext, _antlr4$ParserRuleCon47);

	  var _super48 = _createSuper(ObjectTypeDefinitionContext);

	  function ObjectTypeDefinitionContext(parser, parent, invokingState) {
	    var _this48;

	    _classCallCheck(this, ObjectTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this48 = _super48.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this48), "objectDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ObjectDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(ObjectDirectiveContext, i);
	      }
	    });

	    _this48.parser = parser;
	    _this48.ruleIndex = GraphQLFederationParser.RULE_objectTypeDefinition;
	    return _this48;
	  }

	  _createClass(ObjectTypeDefinitionContext, [{
	    key: "TYPE_KEYWORD",
	    value: function TYPE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.TYPE_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      return this.getTypedRuleContext(ImplementsInterfacesContext, 0);
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      return this.getTypedRuleContext(FieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterObjectTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitObjectTypeDefinition(this);
	      }
	    }
	  }]);

	  return ObjectTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ImplementsInterfacesContext = /*#__PURE__*/function (_antlr4$ParserRuleCon48) {
	  _inherits(ImplementsInterfacesContext, _antlr4$ParserRuleCon48);

	  var _super49 = _createSuper(ImplementsInterfacesContext);

	  function ImplementsInterfacesContext(parser, parent, invokingState) {
	    var _this49;

	    _classCallCheck(this, ImplementsInterfacesContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this49 = _super49.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this49), "namedType", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(NamedTypeContext);
	      } else {
	        return this.getTypedRuleContext(NamedTypeContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this49), "AMP", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(GraphQLFederationParser.AMP);
	      } else {
	        return this.getToken(GraphQLFederationParser.AMP, i);
	      }
	    });

	    _this49.parser = parser;
	    _this49.ruleIndex = GraphQLFederationParser.RULE_implementsInterfaces;
	    return _this49;
	  }

	  _createClass(ImplementsInterfacesContext, [{
	    key: "IMPLEMENTS_KEYWORD",
	    value: function IMPLEMENTS_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.IMPLEMENTS_KEYWORD, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterImplementsInterfaces(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitImplementsInterfaces(this);
	      }
	    }
	  }]);

	  return ImplementsInterfacesContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldsDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon49) {
	  _inherits(FieldsDefinitionContext, _antlr4$ParserRuleCon49);

	  var _super50 = _createSuper(FieldsDefinitionContext);

	  function FieldsDefinitionContext(parser, parent, invokingState) {
	    var _this50;

	    _classCallCheck(this, FieldsDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this50 = _super50.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this50), "fieldDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(FieldDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(FieldDefinitionContext, i);
	      }
	    });

	    _this50.parser = parser;
	    _this50.ruleIndex = GraphQLFederationParser.RULE_fieldsDefinition;
	    return _this50;
	  }

	  _createClass(FieldsDefinitionContext, [{
	    key: "LBRACE",
	    value: function LBRACE() {
	      return this.getToken(GraphQLFederationParser.LBRACE, 0);
	    }
	  }, {
	    key: "RBRACE",
	    value: function RBRACE() {
	      return this.getToken(GraphQLFederationParser.RBRACE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFieldsDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFieldsDefinition(this);
	      }
	    }
	  }]);

	  return FieldsDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon50) {
	  _inherits(FieldDefinitionContext, _antlr4$ParserRuleCon50);

	  var _super51 = _createSuper(FieldDefinitionContext);

	  function FieldDefinitionContext(parser, parent, invokingState) {
	    var _this51;

	    _classCallCheck(this, FieldDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this51 = _super51.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this51), "fieldDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(FieldDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(FieldDirectiveContext, i);
	      }
	    });

	    _this51.parser = parser;
	    _this51.ruleIndex = GraphQLFederationParser.RULE_fieldDefinition;
	    _this51._name = null; // NameContext

	    return _this51;
	  }

	  _createClass(FieldDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "COLON",
	    value: function COLON() {
	      return this.getToken(GraphQLFederationParser.COLON, 0);
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "argumentsDefinition",
	    value: function argumentsDefinition() {
	      return this.getTypedRuleContext(ArgumentsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFieldDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFieldDefinition(this);
	      }
	    }
	  }]);

	  return FieldDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ArgumentsDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon51) {
	  _inherits(ArgumentsDefinitionContext, _antlr4$ParserRuleCon51);

	  var _super52 = _createSuper(ArgumentsDefinitionContext);

	  function ArgumentsDefinitionContext(parser, parent, invokingState) {
	    var _this52;

	    _classCallCheck(this, ArgumentsDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this52 = _super52.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this52), "inputValueDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InputValueDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(InputValueDefinitionContext, i);
	      }
	    });

	    _this52.parser = parser;
	    _this52.ruleIndex = GraphQLFederationParser.RULE_argumentsDefinition;
	    return _this52;
	  }

	  _createClass(ArgumentsDefinitionContext, [{
	    key: "LPAREN",
	    value: function LPAREN() {
	      return this.getToken(GraphQLFederationParser.LPAREN, 0);
	    }
	  }, {
	    key: "RPAREN",
	    value: function RPAREN() {
	      return this.getToken(GraphQLFederationParser.RPAREN, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterArgumentsDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitArgumentsDefinition(this);
	      }
	    }
	  }]);

	  return ArgumentsDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var InputValueDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon52) {
	  _inherits(InputValueDefinitionContext, _antlr4$ParserRuleCon52);

	  var _super53 = _createSuper(InputValueDefinitionContext);

	  function InputValueDefinitionContext(parser, parent, invokingState) {
	    var _this53;

	    _classCallCheck(this, InputValueDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this53 = _super53.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this53), "inputValueDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InputValueDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(InputValueDirectiveContext, i);
	      }
	    });

	    _this53.parser = parser;
	    _this53.ruleIndex = GraphQLFederationParser.RULE_inputValueDefinition;
	    return _this53;
	  }

	  _createClass(InputValueDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "COLON",
	    value: function COLON() {
	      return this.getToken(GraphQLFederationParser.COLON, 0);
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "defaultValue",
	    value: function defaultValue() {
	      return this.getTypedRuleContext(DefaultValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInputValueDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInputValueDefinition(this);
	      }
	    }
	  }]);

	  return InputValueDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon53) {
	  _inherits(ObjectTypeExtensionContext, _antlr4$ParserRuleCon53);

	  var _super54 = _createSuper(ObjectTypeExtensionContext);

	  function ObjectTypeExtensionContext(parser, parent, invokingState) {
	    var _this54;

	    _classCallCheck(this, ObjectTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this54 = _super54.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this54), "objectDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ObjectDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(ObjectDirectiveContext, i);
	      }
	    });

	    _this54.parser = parser;
	    _this54.ruleIndex = GraphQLFederationParser.RULE_objectTypeExtension;
	    return _this54;
	  }

	  _createClass(ObjectTypeExtensionContext, [{
	    key: "EXTEND_KEYWORD",
	    value: function EXTEND_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD, 0);
	    }
	  }, {
	    key: "TYPE_KEYWORD",
	    value: function TYPE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.TYPE_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      return this.getTypedRuleContext(FieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      return this.getTypedRuleContext(ImplementsInterfacesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterObjectTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitObjectTypeExtension(this);
	      }
	    }
	  }]);

	  return ObjectTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var InterfaceTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon54) {
	  _inherits(InterfaceTypeDefinitionContext, _antlr4$ParserRuleCon54);

	  var _super55 = _createSuper(InterfaceTypeDefinitionContext);

	  function InterfaceTypeDefinitionContext(parser, parent, invokingState) {
	    var _this55;

	    _classCallCheck(this, InterfaceTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this55 = _super55.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this55), "interfaceDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InterfaceDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(InterfaceDirectiveContext, i);
	      }
	    });

	    _this55.parser = parser;
	    _this55.ruleIndex = GraphQLFederationParser.RULE_interfaceTypeDefinition;
	    return _this55;
	  }

	  _createClass(InterfaceTypeDefinitionContext, [{
	    key: "INTERFACE_KEYWORD",
	    value: function INTERFACE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.INTERFACE_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      return this.getTypedRuleContext(ImplementsInterfacesContext, 0);
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      return this.getTypedRuleContext(FieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInterfaceTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInterfaceTypeDefinition(this);
	      }
	    }
	  }]);

	  return InterfaceTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var InterfaceTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon55) {
	  _inherits(InterfaceTypeExtensionContext, _antlr4$ParserRuleCon55);

	  var _super56 = _createSuper(InterfaceTypeExtensionContext);

	  function InterfaceTypeExtensionContext(parser, parent, invokingState) {
	    var _this56;

	    _classCallCheck(this, InterfaceTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this56 = _super56.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this56), "interfaceDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InterfaceDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(InterfaceDirectiveContext, i);
	      }
	    });

	    _this56.parser = parser;
	    _this56.ruleIndex = GraphQLFederationParser.RULE_interfaceTypeExtension;
	    return _this56;
	  }

	  _createClass(InterfaceTypeExtensionContext, [{
	    key: "EXTEND_KEYWORD",
	    value: function EXTEND_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD, 0);
	    }
	  }, {
	    key: "INTERFACE_KEYWORD",
	    value: function INTERFACE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.INTERFACE_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      return this.getTypedRuleContext(FieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      return this.getTypedRuleContext(ImplementsInterfacesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInterfaceTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInterfaceTypeExtension(this);
	      }
	    }
	  }]);

	  return InterfaceTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var UnionTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon56) {
	  _inherits(UnionTypeDefinitionContext, _antlr4$ParserRuleCon56);

	  var _super57 = _createSuper(UnionTypeDefinitionContext);

	  function UnionTypeDefinitionContext(parser, parent, invokingState) {
	    var _this57;

	    _classCallCheck(this, UnionTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this57 = _super57.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this57), "unionDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(UnionDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(UnionDirectiveContext, i);
	      }
	    });

	    _this57.parser = parser;
	    _this57.ruleIndex = GraphQLFederationParser.RULE_unionTypeDefinition;
	    return _this57;
	  }

	  _createClass(UnionTypeDefinitionContext, [{
	    key: "UNION_KEYWORD",
	    value: function UNION_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.UNION_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "unionMemberTypes",
	    value: function unionMemberTypes() {
	      return this.getTypedRuleContext(UnionMemberTypesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterUnionTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitUnionTypeDefinition(this);
	      }
	    }
	  }]);

	  return UnionTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var UnionMemberTypesContext = /*#__PURE__*/function (_antlr4$ParserRuleCon57) {
	  _inherits(UnionMemberTypesContext, _antlr4$ParserRuleCon57);

	  var _super58 = _createSuper(UnionMemberTypesContext);

	  function UnionMemberTypesContext(parser, parent, invokingState) {
	    var _this58;

	    _classCallCheck(this, UnionMemberTypesContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this58 = _super58.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this58), "namedType", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(NamedTypeContext);
	      } else {
	        return this.getTypedRuleContext(NamedTypeContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this58), "VSLASH", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(GraphQLFederationParser.VSLASH);
	      } else {
	        return this.getToken(GraphQLFederationParser.VSLASH, i);
	      }
	    });

	    _this58.parser = parser;
	    _this58.ruleIndex = GraphQLFederationParser.RULE_unionMemberTypes;
	    return _this58;
	  }

	  _createClass(UnionMemberTypesContext, [{
	    key: "EQ",
	    value: function EQ() {
	      return this.getToken(GraphQLFederationParser.EQ, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterUnionMemberTypes(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitUnionMemberTypes(this);
	      }
	    }
	  }]);

	  return UnionMemberTypesContext;
	}(_antlr["default"].ParserRuleContext);

	var UnionTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon58) {
	  _inherits(UnionTypeExtensionContext, _antlr4$ParserRuleCon58);

	  var _super59 = _createSuper(UnionTypeExtensionContext);

	  function UnionTypeExtensionContext(parser, parent, invokingState) {
	    var _this59;

	    _classCallCheck(this, UnionTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this59 = _super59.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this59), "unionDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(UnionDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(UnionDirectiveContext, i);
	      }
	    });

	    _this59.parser = parser;
	    _this59.ruleIndex = GraphQLFederationParser.RULE_unionTypeExtension;
	    return _this59;
	  }

	  _createClass(UnionTypeExtensionContext, [{
	    key: "EXTEND_KEYWORD",
	    value: function EXTEND_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD, 0);
	    }
	  }, {
	    key: "UNION_KEYWORD",
	    value: function UNION_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.UNION_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "unionMemberTypes",
	    value: function unionMemberTypes() {
	      return this.getTypedRuleContext(UnionMemberTypesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterUnionTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitUnionTypeExtension(this);
	      }
	    }
	  }]);

	  return UnionTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon59) {
	  _inherits(EnumTypeDefinitionContext, _antlr4$ParserRuleCon59);

	  var _super60 = _createSuper(EnumTypeDefinitionContext);

	  function EnumTypeDefinitionContext(parser, parent, invokingState) {
	    var _this60;

	    _classCallCheck(this, EnumTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this60 = _super60.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this60), "enumDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EnumDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(EnumDirectiveContext, i);
	      }
	    });

	    _this60.parser = parser;
	    _this60.ruleIndex = GraphQLFederationParser.RULE_enumTypeDefinition;
	    return _this60;
	  }

	  _createClass(EnumTypeDefinitionContext, [{
	    key: "ENUM_KEYWORD",
	    value: function ENUM_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.ENUM_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "enumValuesDefinition",
	    value: function enumValuesDefinition() {
	      return this.getTypedRuleContext(EnumValuesDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumTypeDefinition(this);
	      }
	    }
	  }]);

	  return EnumTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValuesDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon60) {
	  _inherits(EnumValuesDefinitionContext, _antlr4$ParserRuleCon60);

	  var _super61 = _createSuper(EnumValuesDefinitionContext);

	  function EnumValuesDefinitionContext(parser, parent, invokingState) {
	    var _this61;

	    _classCallCheck(this, EnumValuesDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this61 = _super61.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this61), "enumValueDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EnumValueDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(EnumValueDefinitionContext, i);
	      }
	    });

	    _this61.parser = parser;
	    _this61.ruleIndex = GraphQLFederationParser.RULE_enumValuesDefinition;
	    return _this61;
	  }

	  _createClass(EnumValuesDefinitionContext, [{
	    key: "LBRACE",
	    value: function LBRACE() {
	      return this.getToken(GraphQLFederationParser.LBRACE, 0);
	    }
	  }, {
	    key: "RBRACE",
	    value: function RBRACE() {
	      return this.getToken(GraphQLFederationParser.RBRACE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumValuesDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumValuesDefinition(this);
	      }
	    }
	  }]);

	  return EnumValuesDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValueDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon61) {
	  _inherits(EnumValueDefinitionContext, _antlr4$ParserRuleCon61);

	  var _super62 = _createSuper(EnumValueDefinitionContext);

	  function EnumValueDefinitionContext(parser, parent, invokingState) {
	    var _this62;

	    _classCallCheck(this, EnumValueDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this62 = _super62.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this62), "enumValueDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EnumValueDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(EnumValueDirectiveContext, i);
	      }
	    });

	    _this62.parser = parser;
	    _this62.ruleIndex = GraphQLFederationParser.RULE_enumValueDefinition;
	    return _this62;
	  }

	  _createClass(EnumValueDefinitionContext, [{
	    key: "enumValue",
	    value: function enumValue() {
	      return this.getTypedRuleContext(EnumValueContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumValueDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumValueDefinition(this);
	      }
	    }
	  }]);

	  return EnumValueDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon62) {
	  _inherits(EnumTypeExtensionContext, _antlr4$ParserRuleCon62);

	  var _super63 = _createSuper(EnumTypeExtensionContext);

	  function EnumTypeExtensionContext(parser, parent, invokingState) {
	    var _this63;

	    _classCallCheck(this, EnumTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this63 = _super63.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this63), "enumDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EnumDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(EnumDirectiveContext, i);
	      }
	    });

	    _this63.parser = parser;
	    _this63.ruleIndex = GraphQLFederationParser.RULE_enumTypeExtension;
	    return _this63;
	  }

	  _createClass(EnumTypeExtensionContext, [{
	    key: "EXTEND_KEYWORD",
	    value: function EXTEND_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD, 0);
	    }
	  }, {
	    key: "ENUM_KEYWORD",
	    value: function ENUM_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.ENUM_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enumValuesDefinition",
	    value: function enumValuesDefinition() {
	      return this.getTypedRuleContext(EnumValuesDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumTypeExtension(this);
	      }
	    }
	  }]);

	  return EnumTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var InputObjectTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon63) {
	  _inherits(InputObjectTypeDefinitionContext, _antlr4$ParserRuleCon63);

	  var _super64 = _createSuper(InputObjectTypeDefinitionContext);

	  function InputObjectTypeDefinitionContext(parser, parent, invokingState) {
	    var _this64;

	    _classCallCheck(this, InputObjectTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this64 = _super64.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this64), "inputObjectDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InputObjectDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(InputObjectDirectiveContext, i);
	      }
	    });

	    _this64.parser = parser;
	    _this64.ruleIndex = GraphQLFederationParser.RULE_inputObjectTypeDefinition;
	    return _this64;
	  }

	  _createClass(InputObjectTypeDefinitionContext, [{
	    key: "INPUT_KEYWORD",
	    value: function INPUT_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.INPUT_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "inputFieldsDefinition",
	    value: function inputFieldsDefinition() {
	      return this.getTypedRuleContext(InputFieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInputObjectTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInputObjectTypeDefinition(this);
	      }
	    }
	  }]);

	  return InputObjectTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var InputFieldsDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon64) {
	  _inherits(InputFieldsDefinitionContext, _antlr4$ParserRuleCon64);

	  var _super65 = _createSuper(InputFieldsDefinitionContext);

	  function InputFieldsDefinitionContext(parser, parent, invokingState) {
	    var _this65;

	    _classCallCheck(this, InputFieldsDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this65 = _super65.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this65), "inputValueDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InputValueDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(InputValueDefinitionContext, i);
	      }
	    });

	    _this65.parser = parser;
	    _this65.ruleIndex = GraphQLFederationParser.RULE_inputFieldsDefinition;
	    return _this65;
	  }

	  _createClass(InputFieldsDefinitionContext, [{
	    key: "LBRACE",
	    value: function LBRACE() {
	      return this.getToken(GraphQLFederationParser.LBRACE, 0);
	    }
	  }, {
	    key: "RBRACE",
	    value: function RBRACE() {
	      return this.getToken(GraphQLFederationParser.RBRACE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInputFieldsDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInputFieldsDefinition(this);
	      }
	    }
	  }]);

	  return InputFieldsDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var InputObjectTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon65) {
	  _inherits(InputObjectTypeExtensionContext, _antlr4$ParserRuleCon65);

	  var _super66 = _createSuper(InputObjectTypeExtensionContext);

	  function InputObjectTypeExtensionContext(parser, parent, invokingState) {
	    var _this66;

	    _classCallCheck(this, InputObjectTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this66 = _super66.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this66), "inputObjectDirective", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InputObjectDirectiveContext);
	      } else {
	        return this.getTypedRuleContext(InputObjectDirectiveContext, i);
	      }
	    });

	    _this66.parser = parser;
	    _this66.ruleIndex = GraphQLFederationParser.RULE_inputObjectTypeExtension;
	    return _this66;
	  }

	  _createClass(InputObjectTypeExtensionContext, [{
	    key: "EXTEND_KEYWORD",
	    value: function EXTEND_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD, 0);
	    }
	  }, {
	    key: "INPUT_KEYWORD",
	    value: function INPUT_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.INPUT_KEYWORD, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "inputFieldsDefinition",
	    value: function inputFieldsDefinition() {
	      return this.getTypedRuleContext(InputFieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInputObjectTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInputObjectTypeExtension(this);
	      }
	    }
	  }]);

	  return InputObjectTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectiveDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon66) {
	  _inherits(DirectiveDefinitionContext, _antlr4$ParserRuleCon66);

	  var _super67 = _createSuper(DirectiveDefinitionContext);

	  function DirectiveDefinitionContext(parser, parent, invokingState) {
	    var _this67;

	    _classCallCheck(this, DirectiveDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this67 = _super67.call(this, parent, invokingState);
	    _this67.parser = parser;
	    _this67.ruleIndex = GraphQLFederationParser.RULE_directiveDefinition;
	    return _this67;
	  }

	  _createClass(DirectiveDefinitionContext, [{
	    key: "DIRECTIVE_KEYWORD",
	    value: function DIRECTIVE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.DIRECTIVE_KEYWORD, 0);
	    }
	  }, {
	    key: "AT",
	    value: function AT() {
	      return this.getToken(GraphQLFederationParser.AT, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "ON_KEYWORD",
	    value: function ON_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.ON_KEYWORD, 0);
	    }
	  }, {
	    key: "directiveLocations",
	    value: function directiveLocations() {
	      return this.getTypedRuleContext(DirectiveLocationsContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "argumentsDefinition",
	    value: function argumentsDefinition() {
	      return this.getTypedRuleContext(ArgumentsDefinitionContext, 0);
	    }
	  }, {
	    key: "REPEATABLE_KEYWORD",
	    value: function REPEATABLE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.REPEATABLE_KEYWORD, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDirectiveDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDirectiveDefinition(this);
	      }
	    }
	  }]);

	  return DirectiveDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectiveLocationsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon67) {
	  _inherits(DirectiveLocationsContext, _antlr4$ParserRuleCon67);

	  var _super68 = _createSuper(DirectiveLocationsContext);

	  function DirectiveLocationsContext(parser, parent, invokingState) {
	    var _this68;

	    _classCallCheck(this, DirectiveLocationsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this68 = _super68.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this68), "directiveLocation", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(DirectiveLocationContext);
	      } else {
	        return this.getTypedRuleContext(DirectiveLocationContext, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this68), "VSLASH", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(GraphQLFederationParser.VSLASH);
	      } else {
	        return this.getToken(GraphQLFederationParser.VSLASH, i);
	      }
	    });

	    _this68.parser = parser;
	    _this68.ruleIndex = GraphQLFederationParser.RULE_directiveLocations;
	    return _this68;
	  }

	  _createClass(DirectiveLocationsContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDirectiveLocations(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDirectiveLocations(this);
	      }
	    }
	  }]);

	  return DirectiveLocationsContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectiveLocationContext = /*#__PURE__*/function (_antlr4$ParserRuleCon68) {
	  _inherits(DirectiveLocationContext, _antlr4$ParserRuleCon68);

	  var _super69 = _createSuper(DirectiveLocationContext);

	  function DirectiveLocationContext(parser, parent, invokingState) {
	    var _this69;

	    _classCallCheck(this, DirectiveLocationContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this69 = _super69.call(this, parent, invokingState);
	    _this69.parser = parser;
	    _this69.ruleIndex = GraphQLFederationParser.RULE_directiveLocation;
	    return _this69;
	  }

	  _createClass(DirectiveLocationContext, [{
	    key: "executableDirectiveLocation",
	    value: function executableDirectiveLocation() {
	      return this.getTypedRuleContext(ExecutableDirectiveLocationContext, 0);
	    }
	  }, {
	    key: "typeSystemDirectiveLocation",
	    value: function typeSystemDirectiveLocation() {
	      return this.getTypedRuleContext(TypeSystemDirectiveLocationContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterDirectiveLocation(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitDirectiveLocation(this);
	      }
	    }
	  }]);

	  return DirectiveLocationContext;
	}(_antlr["default"].ParserRuleContext);

	var ExecutableDirectiveLocationContext = /*#__PURE__*/function (_antlr4$ParserRuleCon69) {
	  _inherits(ExecutableDirectiveLocationContext, _antlr4$ParserRuleCon69);

	  var _super70 = _createSuper(ExecutableDirectiveLocationContext);

	  function ExecutableDirectiveLocationContext(parser, parent, invokingState) {
	    var _this70;

	    _classCallCheck(this, ExecutableDirectiveLocationContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this70 = _super70.call(this, parent, invokingState);
	    _this70.parser = parser;
	    _this70.ruleIndex = GraphQLFederationParser.RULE_executableDirectiveLocation;
	    return _this70;
	  }

	  _createClass(ExecutableDirectiveLocationContext, [{
	    key: "QUERY_LOCATION",
	    value: function QUERY_LOCATION() {
	      return this.getToken(GraphQLFederationParser.QUERY_LOCATION, 0);
	    }
	  }, {
	    key: "MUTATION_LOCATION",
	    value: function MUTATION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.MUTATION_LOCATION, 0);
	    }
	  }, {
	    key: "SUBSCRIPTION_LOCATION",
	    value: function SUBSCRIPTION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.SUBSCRIPTION_LOCATION, 0);
	    }
	  }, {
	    key: "FIELD_LOCATION",
	    value: function FIELD_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FIELD_LOCATION, 0);
	    }
	  }, {
	    key: "FRAGMENT_DEFINITION_LOCATION",
	    value: function FRAGMENT_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "FRAGMENT_SPREAD_LOCATION",
	    value: function FRAGMENT_SPREAD_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION, 0);
	    }
	  }, {
	    key: "INLINE_FRAGMENT_LOCATION",
	    value: function INLINE_FRAGMENT_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INLINE_FRAGMENT_LOCATION, 0);
	    }
	  }, {
	    key: "VARIABLE_DEFINITION_LOCATION",
	    value: function VARIABLE_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterExecutableDirectiveLocation(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitExecutableDirectiveLocation(this);
	      }
	    }
	  }]);

	  return ExecutableDirectiveLocationContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeSystemDirectiveLocationContext = /*#__PURE__*/function (_antlr4$ParserRuleCon70) {
	  _inherits(TypeSystemDirectiveLocationContext, _antlr4$ParserRuleCon70);

	  var _super71 = _createSuper(TypeSystemDirectiveLocationContext);

	  function TypeSystemDirectiveLocationContext(parser, parent, invokingState) {
	    var _this71;

	    _classCallCheck(this, TypeSystemDirectiveLocationContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this71 = _super71.call(this, parent, invokingState);
	    _this71.parser = parser;
	    _this71.ruleIndex = GraphQLFederationParser.RULE_typeSystemDirectiveLocation;
	    return _this71;
	  }

	  _createClass(TypeSystemDirectiveLocationContext, [{
	    key: "SCHEMA_LOCATION",
	    value: function SCHEMA_LOCATION() {
	      return this.getToken(GraphQLFederationParser.SCHEMA_LOCATION, 0);
	    }
	  }, {
	    key: "SCALAR_LOCATION",
	    value: function SCALAR_LOCATION() {
	      return this.getToken(GraphQLFederationParser.SCALAR_LOCATION, 0);
	    }
	  }, {
	    key: "OBJECT_LOCATION",
	    value: function OBJECT_LOCATION() {
	      return this.getToken(GraphQLFederationParser.OBJECT_LOCATION, 0);
	    }
	  }, {
	    key: "FIELD_DEFINITION_LOCATION",
	    value: function FIELD_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FIELD_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "ARGUMENT_DEFINITION_LOCATION",
	    value: function ARGUMENT_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "INTERFACE_LOCATION",
	    value: function INTERFACE_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INTERFACE_LOCATION, 0);
	    }
	  }, {
	    key: "UNION_LOCATION",
	    value: function UNION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.UNION_LOCATION, 0);
	    }
	  }, {
	    key: "ENUM_LOCATION",
	    value: function ENUM_LOCATION() {
	      return this.getToken(GraphQLFederationParser.ENUM_LOCATION, 0);
	    }
	  }, {
	    key: "ENUM_VALUE_LOCATION",
	    value: function ENUM_VALUE_LOCATION() {
	      return this.getToken(GraphQLFederationParser.ENUM_VALUE_LOCATION, 0);
	    }
	  }, {
	    key: "INPUT_OBJECT_LOCATION",
	    value: function INPUT_OBJECT_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INPUT_OBJECT_LOCATION, 0);
	    }
	  }, {
	    key: "INPUT_FIELD_DEFINITION_LOCATION",
	    value: function INPUT_FIELD_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterTypeSystemDirectiveLocation(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitTypeSystemDirectiveLocation(this);
	      }
	    }
	  }]);

	  return TypeSystemDirectiveLocationContext;
	}(_antlr["default"].ParserRuleContext);

	var ExternalDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon71) {
	  _inherits(ExternalDirectiveContext, _antlr4$ParserRuleCon71);

	  var _super72 = _createSuper(ExternalDirectiveContext);

	  function ExternalDirectiveContext(parser, parent, invokingState) {
	    var _this72;

	    _classCallCheck(this, ExternalDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this72 = _super72.call(this, parent, invokingState);
	    _this72.parser = parser;
	    _this72.ruleIndex = GraphQLFederationParser.RULE_externalDirective;
	    return _this72;
	  }

	  _createClass(ExternalDirectiveContext, [{
	    key: "EXTERNAL",
	    value: function EXTERNAL() {
	      return this.getToken(GraphQLFederationParser.EXTERNAL, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterExternalDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitExternalDirective(this);
	      }
	    }
	  }]);

	  return ExternalDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var InaccessibleDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon72) {
	  _inherits(InaccessibleDirectiveContext, _antlr4$ParserRuleCon72);

	  var _super73 = _createSuper(InaccessibleDirectiveContext);

	  function InaccessibleDirectiveContext(parser, parent, invokingState) {
	    var _this73;

	    _classCallCheck(this, InaccessibleDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this73 = _super73.call(this, parent, invokingState);
	    _this73.parser = parser;
	    _this73.ruleIndex = GraphQLFederationParser.RULE_inaccessibleDirective;
	    return _this73;
	  }

	  _createClass(InaccessibleDirectiveContext, [{
	    key: "INACCESSIBLE",
	    value: function INACCESSIBLE() {
	      return this.getToken(GraphQLFederationParser.INACCESSIBLE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInaccessibleDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInaccessibleDirective(this);
	      }
	    }
	  }]);

	  return InaccessibleDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var RequiresDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon73) {
	  _inherits(RequiresDirectiveContext, _antlr4$ParserRuleCon73);

	  var _super74 = _createSuper(RequiresDirectiveContext);

	  function RequiresDirectiveContext(parser, parent, invokingState) {
	    var _this74;

	    _classCallCheck(this, RequiresDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this74 = _super74.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this74), "DQUOTE_F", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(GraphQLFederationParser.DQUOTE_F);
	      } else {
	        return this.getToken(GraphQLFederationParser.DQUOTE_F, i);
	      }
	    });

	    _this74.parser = parser;
	    _this74.ruleIndex = GraphQLFederationParser.RULE_requiresDirective;
	    return _this74;
	  }

	  _createClass(RequiresDirectiveContext, [{
	    key: "REQUIRES",
	    value: function REQUIRES() {
	      return this.getToken(GraphQLFederationParser.REQUIRES, 0);
	    }
	  }, {
	    key: "LPAREN_F",
	    value: function LPAREN_F() {
	      return this.getToken(GraphQLFederationParser.LPAREN_F, 0);
	    }
	  }, {
	    key: "FIELDS_KEYWORD",
	    value: function FIELDS_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.FIELDS_KEYWORD, 0);
	    }
	  }, {
	    key: "COLON_F",
	    value: function COLON_F() {
	      return this.getToken(GraphQLFederationParser.COLON_F, 0);
	    }
	  }, {
	    key: "fieldSet",
	    value: function fieldSet() {
	      return this.getTypedRuleContext(FieldSetContext, 0);
	    }
	  }, {
	    key: "RPAREN_F",
	    value: function RPAREN_F() {
	      return this.getToken(GraphQLFederationParser.RPAREN_F, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterRequiresDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitRequiresDirective(this);
	      }
	    }
	  }]);

	  return RequiresDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var ProvidesDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon74) {
	  _inherits(ProvidesDirectiveContext, _antlr4$ParserRuleCon74);

	  var _super75 = _createSuper(ProvidesDirectiveContext);

	  function ProvidesDirectiveContext(parser, parent, invokingState) {
	    var _this75;

	    _classCallCheck(this, ProvidesDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this75 = _super75.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this75), "DQUOTE_F", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(GraphQLFederationParser.DQUOTE_F);
	      } else {
	        return this.getToken(GraphQLFederationParser.DQUOTE_F, i);
	      }
	    });

	    _this75.parser = parser;
	    _this75.ruleIndex = GraphQLFederationParser.RULE_providesDirective;
	    return _this75;
	  }

	  _createClass(ProvidesDirectiveContext, [{
	    key: "PROVIDES",
	    value: function PROVIDES() {
	      return this.getToken(GraphQLFederationParser.PROVIDES, 0);
	    }
	  }, {
	    key: "LPAREN_F",
	    value: function LPAREN_F() {
	      return this.getToken(GraphQLFederationParser.LPAREN_F, 0);
	    }
	  }, {
	    key: "FIELDS_KEYWORD",
	    value: function FIELDS_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.FIELDS_KEYWORD, 0);
	    }
	  }, {
	    key: "COLON_F",
	    value: function COLON_F() {
	      return this.getToken(GraphQLFederationParser.COLON_F, 0);
	    }
	  }, {
	    key: "fieldSet",
	    value: function fieldSet() {
	      return this.getTypedRuleContext(FieldSetContext, 0);
	    }
	  }, {
	    key: "RPAREN_F",
	    value: function RPAREN_F() {
	      return this.getToken(GraphQLFederationParser.RPAREN_F, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterProvidesDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitProvidesDirective(this);
	      }
	    }
	  }]);

	  return ProvidesDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var KeyDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon75) {
	  _inherits(KeyDirectiveContext, _antlr4$ParserRuleCon75);

	  var _super76 = _createSuper(KeyDirectiveContext);

	  function KeyDirectiveContext(parser, parent, invokingState) {
	    var _this76;

	    _classCallCheck(this, KeyDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this76 = _super76.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this76), "COLON_F", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(GraphQLFederationParser.COLON_F);
	      } else {
	        return this.getToken(GraphQLFederationParser.COLON_F, i);
	      }
	    });

	    _defineProperty(_assertThisInitialized(_this76), "DQUOTE_F", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(GraphQLFederationParser.DQUOTE_F);
	      } else {
	        return this.getToken(GraphQLFederationParser.DQUOTE_F, i);
	      }
	    });

	    _this76.parser = parser;
	    _this76.ruleIndex = GraphQLFederationParser.RULE_keyDirective;
	    return _this76;
	  }

	  _createClass(KeyDirectiveContext, [{
	    key: "KEY",
	    value: function KEY() {
	      return this.getToken(GraphQLFederationParser.KEY, 0);
	    }
	  }, {
	    key: "LPAREN_F",
	    value: function LPAREN_F() {
	      return this.getToken(GraphQLFederationParser.LPAREN_F, 0);
	    }
	  }, {
	    key: "FIELDS_KEYWORD",
	    value: function FIELDS_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.FIELDS_KEYWORD, 0);
	    }
	  }, {
	    key: "fieldSet",
	    value: function fieldSet() {
	      return this.getTypedRuleContext(FieldSetContext, 0);
	    }
	  }, {
	    key: "RPAREN_F",
	    value: function RPAREN_F() {
	      return this.getToken(GraphQLFederationParser.RPAREN_F, 0);
	    }
	  }, {
	    key: "RESOLVABLE_KEYWORD",
	    value: function RESOLVABLE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.RESOLVABLE_KEYWORD, 0);
	    }
	  }, {
	    key: "booleanValue_f",
	    value: function booleanValue_f() {
	      return this.getTypedRuleContext(BooleanValue_fContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterKeyDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitKeyDirective(this);
	      }
	    }
	  }]);

	  return KeyDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var ShareableDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon76) {
	  _inherits(ShareableDirectiveContext, _antlr4$ParserRuleCon76);

	  var _super77 = _createSuper(ShareableDirectiveContext);

	  function ShareableDirectiveContext(parser, parent, invokingState) {
	    var _this77;

	    _classCallCheck(this, ShareableDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this77 = _super77.call(this, parent, invokingState);
	    _this77.parser = parser;
	    _this77.ruleIndex = GraphQLFederationParser.RULE_shareableDirective;
	    return _this77;
	  }

	  _createClass(ShareableDirectiveContext, [{
	    key: "SHAREABLE",
	    value: function SHAREABLE() {
	      return this.getToken(GraphQLFederationParser.SHAREABLE, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterShareableDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitShareableDirective(this);
	      }
	    }
	  }]);

	  return ShareableDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var OverrideDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon77) {
	  _inherits(OverrideDirectiveContext, _antlr4$ParserRuleCon77);

	  var _super78 = _createSuper(OverrideDirectiveContext);

	  function OverrideDirectiveContext(parser, parent, invokingState) {
	    var _this78;

	    _classCallCheck(this, OverrideDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this78 = _super78.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this78), "DQUOTE_F", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTokens(GraphQLFederationParser.DQUOTE_F);
	      } else {
	        return this.getToken(GraphQLFederationParser.DQUOTE_F, i);
	      }
	    });

	    _this78.parser = parser;
	    _this78.ruleIndex = GraphQLFederationParser.RULE_overrideDirective;
	    return _this78;
	  }

	  _createClass(OverrideDirectiveContext, [{
	    key: "OVERRIDE",
	    value: function OVERRIDE() {
	      return this.getToken(GraphQLFederationParser.OVERRIDE, 0);
	    }
	  }, {
	    key: "LPAREN_F",
	    value: function LPAREN_F() {
	      return this.getToken(GraphQLFederationParser.LPAREN_F, 0);
	    }
	  }, {
	    key: "FROM_KEYWORD",
	    value: function FROM_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.FROM_KEYWORD, 0);
	    }
	  }, {
	    key: "COLON_F",
	    value: function COLON_F() {
	      return this.getToken(GraphQLFederationParser.COLON_F, 0);
	    }
	  }, {
	    key: "name_f",
	    value: function name_f() {
	      return this.getTypedRuleContext(Name_fContext, 0);
	    }
	  }, {
	    key: "RPAREN_F",
	    value: function RPAREN_F() {
	      return this.getToken(GraphQLFederationParser.RPAREN_F, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterOverrideDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitOverrideDirective(this);
	      }
	    }
	  }]);

	  return OverrideDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var LinkDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon78) {
	  _inherits(LinkDirectiveContext, _antlr4$ParserRuleCon78);

	  var _super79 = _createSuper(LinkDirectiveContext);

	  function LinkDirectiveContext(parser, parent, invokingState) {
	    var _this79;

	    _classCallCheck(this, LinkDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this79 = _super79.call(this, parent, invokingState);
	    _this79.parser = parser;
	    _this79.ruleIndex = GraphQLFederationParser.RULE_linkDirective;
	    return _this79;
	  }

	  _createClass(LinkDirectiveContext, [{
	    key: "LINK",
	    value: function LINK() {
	      return this.getToken(GraphQLFederationParser.LINK, 0);
	    }
	  }, {
	    key: "STRING_LINK",
	    value: function STRING_LINK() {
	      return this.getToken(GraphQLFederationParser.STRING_LINK, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterLinkDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitLinkDirective(this);
	      }
	    }
	  }]);

	  return LinkDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldSetContext = /*#__PURE__*/function (_antlr4$ParserRuleCon79) {
	  _inherits(FieldSetContext, _antlr4$ParserRuleCon79);

	  var _super80 = _createSuper(FieldSetContext);

	  function FieldSetContext(parser, parent, invokingState) {
	    var _this80;

	    _classCallCheck(this, FieldSetContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this80 = _super80.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this80), "fieldSetComponent", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(FieldSetComponentContext);
	      } else {
	        return this.getTypedRuleContext(FieldSetComponentContext, i);
	      }
	    });

	    _this80.parser = parser;
	    _this80.ruleIndex = GraphQLFederationParser.RULE_fieldSet;
	    return _this80;
	  }

	  _createClass(FieldSetContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFieldSet(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFieldSet(this);
	      }
	    }
	  }]);

	  return FieldSetContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldSetComponentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon80) {
	  _inherits(FieldSetComponentContext, _antlr4$ParserRuleCon80);

	  var _super81 = _createSuper(FieldSetComponentContext);

	  function FieldSetComponentContext(parser, parent, invokingState) {
	    var _this81;

	    _classCallCheck(this, FieldSetComponentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this81 = _super81.call(this, parent, invokingState);
	    _this81.parser = parser;
	    _this81.ruleIndex = GraphQLFederationParser.RULE_fieldSetComponent;
	    return _this81;
	  }

	  _createClass(FieldSetComponentContext, [{
	    key: "name_f",
	    value: function name_f() {
	      return this.getTypedRuleContext(Name_fContext, 0);
	    }
	  }, {
	    key: "nestedFieldSet",
	    value: function nestedFieldSet() {
	      return this.getTypedRuleContext(NestedFieldSetContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFieldSetComponent(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFieldSetComponent(this);
	      }
	    }
	  }]);

	  return FieldSetComponentContext;
	}(_antlr["default"].ParserRuleContext);

	var NestedFieldSetContext = /*#__PURE__*/function (_antlr4$ParserRuleCon81) {
	  _inherits(NestedFieldSetContext, _antlr4$ParserRuleCon81);

	  var _super82 = _createSuper(NestedFieldSetContext);

	  function NestedFieldSetContext(parser, parent, invokingState) {
	    var _this82;

	    _classCallCheck(this, NestedFieldSetContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this82 = _super82.call(this, parent, invokingState);
	    _this82.parser = parser;
	    _this82.ruleIndex = GraphQLFederationParser.RULE_nestedFieldSet;
	    return _this82;
	  }

	  _createClass(NestedFieldSetContext, [{
	    key: "LBRACE_F",
	    value: function LBRACE_F() {
	      return this.getToken(GraphQLFederationParser.LBRACE_F, 0);
	    }
	  }, {
	    key: "fieldSet",
	    value: function fieldSet() {
	      return this.getTypedRuleContext(FieldSetContext, 0);
	    }
	  }, {
	    key: "RBRACE_F",
	    value: function RBRACE_F() {
	      return this.getToken(GraphQLFederationParser.RBRACE_F, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterNestedFieldSet(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitNestedFieldSet(this);
	      }
	    }
	  }]);

	  return NestedFieldSetContext;
	}(_antlr["default"].ParserRuleContext);

	var SchemaDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon82) {
	  _inherits(SchemaDirectiveContext, _antlr4$ParserRuleCon82);

	  var _super83 = _createSuper(SchemaDirectiveContext);

	  function SchemaDirectiveContext(parser, parent, invokingState) {
	    var _this83;

	    _classCallCheck(this, SchemaDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this83 = _super83.call(this, parent, invokingState);
	    _this83.parser = parser;
	    _this83.ruleIndex = GraphQLFederationParser.RULE_schemaDirective;
	    return _this83;
	  }

	  _createClass(SchemaDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "schemaFederationDirective",
	    value: function schemaFederationDirective() {
	      return this.getTypedRuleContext(SchemaFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterSchemaDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitSchemaDirective(this);
	      }
	    }
	  }]);

	  return SchemaDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var SchemaFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon83) {
	  _inherits(SchemaFederationDirectiveContext, _antlr4$ParserRuleCon83);

	  var _super84 = _createSuper(SchemaFederationDirectiveContext);

	  function SchemaFederationDirectiveContext(parser, parent, invokingState) {
	    var _this84;

	    _classCallCheck(this, SchemaFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this84 = _super84.call(this, parent, invokingState);
	    _this84.parser = parser;
	    _this84.ruleIndex = GraphQLFederationParser.RULE_schemaFederationDirective;
	    return _this84;
	  }

	  _createClass(SchemaFederationDirectiveContext, [{
	    key: "linkDirective",
	    value: function linkDirective() {
	      return this.getTypedRuleContext(LinkDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterSchemaFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitSchemaFederationDirective(this);
	      }
	    }
	  }]);

	  return SchemaFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var ScalarDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon84) {
	  _inherits(ScalarDirectiveContext, _antlr4$ParserRuleCon84);

	  var _super85 = _createSuper(ScalarDirectiveContext);

	  function ScalarDirectiveContext(parser, parent, invokingState) {
	    var _this85;

	    _classCallCheck(this, ScalarDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this85 = _super85.call(this, parent, invokingState);
	    _this85.parser = parser;
	    _this85.ruleIndex = GraphQLFederationParser.RULE_scalarDirective;
	    return _this85;
	  }

	  _createClass(ScalarDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "scalarFederationDirective",
	    value: function scalarFederationDirective() {
	      return this.getTypedRuleContext(ScalarFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterScalarDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitScalarDirective(this);
	      }
	    }
	  }]);

	  return ScalarDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var ScalarFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon85) {
	  _inherits(ScalarFederationDirectiveContext, _antlr4$ParserRuleCon85);

	  var _super86 = _createSuper(ScalarFederationDirectiveContext);

	  function ScalarFederationDirectiveContext(parser, parent, invokingState) {
	    var _this86;

	    _classCallCheck(this, ScalarFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this86 = _super86.call(this, parent, invokingState);
	    _this86.parser = parser;
	    _this86.ruleIndex = GraphQLFederationParser.RULE_scalarFederationDirective;
	    return _this86;
	  }

	  _createClass(ScalarFederationDirectiveContext, [{
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterScalarFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitScalarFederationDirective(this);
	      }
	    }
	  }]);

	  return ScalarFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon86) {
	  _inherits(ObjectDirectiveContext, _antlr4$ParserRuleCon86);

	  var _super87 = _createSuper(ObjectDirectiveContext);

	  function ObjectDirectiveContext(parser, parent, invokingState) {
	    var _this87;

	    _classCallCheck(this, ObjectDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this87 = _super87.call(this, parent, invokingState);
	    _this87.parser = parser;
	    _this87.ruleIndex = GraphQLFederationParser.RULE_objectDirective;
	    return _this87;
	  }

	  _createClass(ObjectDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "objectFederationDirective",
	    value: function objectFederationDirective() {
	      return this.getTypedRuleContext(ObjectFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterObjectDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitObjectDirective(this);
	      }
	    }
	  }]);

	  return ObjectDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon87) {
	  _inherits(ObjectFederationDirectiveContext, _antlr4$ParserRuleCon87);

	  var _super88 = _createSuper(ObjectFederationDirectiveContext);

	  function ObjectFederationDirectiveContext(parser, parent, invokingState) {
	    var _this88;

	    _classCallCheck(this, ObjectFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this88 = _super88.call(this, parent, invokingState);
	    _this88.parser = parser;
	    _this88.ruleIndex = GraphQLFederationParser.RULE_objectFederationDirective;
	    return _this88;
	  }

	  _createClass(ObjectFederationDirectiveContext, [{
	    key: "keyDirective",
	    value: function keyDirective() {
	      return this.getTypedRuleContext(KeyDirectiveContext, 0);
	    }
	  }, {
	    key: "shareableDirective",
	    value: function shareableDirective() {
	      return this.getTypedRuleContext(ShareableDirectiveContext, 0);
	    }
	  }, {
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterObjectFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitObjectFederationDirective(this);
	      }
	    }
	  }]);

	  return ObjectFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var InterfaceDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon88) {
	  _inherits(InterfaceDirectiveContext, _antlr4$ParserRuleCon88);

	  var _super89 = _createSuper(InterfaceDirectiveContext);

	  function InterfaceDirectiveContext(parser, parent, invokingState) {
	    var _this89;

	    _classCallCheck(this, InterfaceDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this89 = _super89.call(this, parent, invokingState);
	    _this89.parser = parser;
	    _this89.ruleIndex = GraphQLFederationParser.RULE_interfaceDirective;
	    return _this89;
	  }

	  _createClass(InterfaceDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "interfaceFederationDirective",
	    value: function interfaceFederationDirective() {
	      return this.getTypedRuleContext(InterfaceFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInterfaceDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInterfaceDirective(this);
	      }
	    }
	  }]);

	  return InterfaceDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var InterfaceFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon89) {
	  _inherits(InterfaceFederationDirectiveContext, _antlr4$ParserRuleCon89);

	  var _super90 = _createSuper(InterfaceFederationDirectiveContext);

	  function InterfaceFederationDirectiveContext(parser, parent, invokingState) {
	    var _this90;

	    _classCallCheck(this, InterfaceFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this90 = _super90.call(this, parent, invokingState);
	    _this90.parser = parser;
	    _this90.ruleIndex = GraphQLFederationParser.RULE_interfaceFederationDirective;
	    return _this90;
	  }

	  _createClass(InterfaceFederationDirectiveContext, [{
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "keyDirective",
	    value: function keyDirective() {
	      return this.getTypedRuleContext(KeyDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInterfaceFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInterfaceFederationDirective(this);
	      }
	    }
	  }]);

	  return InterfaceFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var UnionDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon90) {
	  _inherits(UnionDirectiveContext, _antlr4$ParserRuleCon90);

	  var _super91 = _createSuper(UnionDirectiveContext);

	  function UnionDirectiveContext(parser, parent, invokingState) {
	    var _this91;

	    _classCallCheck(this, UnionDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this91 = _super91.call(this, parent, invokingState);
	    _this91.parser = parser;
	    _this91.ruleIndex = GraphQLFederationParser.RULE_unionDirective;
	    return _this91;
	  }

	  _createClass(UnionDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "unionFederationDirective",
	    value: function unionFederationDirective() {
	      return this.getTypedRuleContext(UnionFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterUnionDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitUnionDirective(this);
	      }
	    }
	  }]);

	  return UnionDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var UnionFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon91) {
	  _inherits(UnionFederationDirectiveContext, _antlr4$ParserRuleCon91);

	  var _super92 = _createSuper(UnionFederationDirectiveContext);

	  function UnionFederationDirectiveContext(parser, parent, invokingState) {
	    var _this92;

	    _classCallCheck(this, UnionFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this92 = _super92.call(this, parent, invokingState);
	    _this92.parser = parser;
	    _this92.ruleIndex = GraphQLFederationParser.RULE_unionFederationDirective;
	    return _this92;
	  }

	  _createClass(UnionFederationDirectiveContext, [{
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterUnionFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitUnionFederationDirective(this);
	      }
	    }
	  }]);

	  return UnionFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon92) {
	  _inherits(EnumDirectiveContext, _antlr4$ParserRuleCon92);

	  var _super93 = _createSuper(EnumDirectiveContext);

	  function EnumDirectiveContext(parser, parent, invokingState) {
	    var _this93;

	    _classCallCheck(this, EnumDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this93 = _super93.call(this, parent, invokingState);
	    _this93.parser = parser;
	    _this93.ruleIndex = GraphQLFederationParser.RULE_enumDirective;
	    return _this93;
	  }

	  _createClass(EnumDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "enumFederationDirective",
	    value: function enumFederationDirective() {
	      return this.getTypedRuleContext(EnumFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumDirective(this);
	      }
	    }
	  }]);

	  return EnumDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon93) {
	  _inherits(EnumFederationDirectiveContext, _antlr4$ParserRuleCon93);

	  var _super94 = _createSuper(EnumFederationDirectiveContext);

	  function EnumFederationDirectiveContext(parser, parent, invokingState) {
	    var _this94;

	    _classCallCheck(this, EnumFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this94 = _super94.call(this, parent, invokingState);
	    _this94.parser = parser;
	    _this94.ruleIndex = GraphQLFederationParser.RULE_enumFederationDirective;
	    return _this94;
	  }

	  _createClass(EnumFederationDirectiveContext, [{
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumFederationDirective(this);
	      }
	    }
	  }]);

	  return EnumFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var InputObjectDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon94) {
	  _inherits(InputObjectDirectiveContext, _antlr4$ParserRuleCon94);

	  var _super95 = _createSuper(InputObjectDirectiveContext);

	  function InputObjectDirectiveContext(parser, parent, invokingState) {
	    var _this95;

	    _classCallCheck(this, InputObjectDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this95 = _super95.call(this, parent, invokingState);
	    _this95.parser = parser;
	    _this95.ruleIndex = GraphQLFederationParser.RULE_inputObjectDirective;
	    return _this95;
	  }

	  _createClass(InputObjectDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "inputObjectFederationDirective",
	    value: function inputObjectFederationDirective() {
	      return this.getTypedRuleContext(InputObjectFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInputObjectDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInputObjectDirective(this);
	      }
	    }
	  }]);

	  return InputObjectDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var InputObjectFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon95) {
	  _inherits(InputObjectFederationDirectiveContext, _antlr4$ParserRuleCon95);

	  var _super96 = _createSuper(InputObjectFederationDirectiveContext);

	  function InputObjectFederationDirectiveContext(parser, parent, invokingState) {
	    var _this96;

	    _classCallCheck(this, InputObjectFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this96 = _super96.call(this, parent, invokingState);
	    _this96.parser = parser;
	    _this96.ruleIndex = GraphQLFederationParser.RULE_inputObjectFederationDirective;
	    return _this96;
	  }

	  _createClass(InputObjectFederationDirectiveContext, [{
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInputObjectFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInputObjectFederationDirective(this);
	      }
	    }
	  }]);

	  return InputObjectFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var InputValueDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon96) {
	  _inherits(InputValueDirectiveContext, _antlr4$ParserRuleCon96);

	  var _super97 = _createSuper(InputValueDirectiveContext);

	  function InputValueDirectiveContext(parser, parent, invokingState) {
	    var _this97;

	    _classCallCheck(this, InputValueDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this97 = _super97.call(this, parent, invokingState);
	    _this97.parser = parser;
	    _this97.ruleIndex = GraphQLFederationParser.RULE_inputValueDirective;
	    return _this97;
	  }

	  _createClass(InputValueDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "inputFieldFederationDirective",
	    value: function inputFieldFederationDirective() {
	      return this.getTypedRuleContext(InputFieldFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInputValueDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInputValueDirective(this);
	      }
	    }
	  }]);

	  return InputValueDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var InputFieldFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon97) {
	  _inherits(InputFieldFederationDirectiveContext, _antlr4$ParserRuleCon97);

	  var _super98 = _createSuper(InputFieldFederationDirectiveContext);

	  function InputFieldFederationDirectiveContext(parser, parent, invokingState) {
	    var _this98;

	    _classCallCheck(this, InputFieldFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this98 = _super98.call(this, parent, invokingState);
	    _this98.parser = parser;
	    _this98.ruleIndex = GraphQLFederationParser.RULE_inputFieldFederationDirective;
	    return _this98;
	  }

	  _createClass(InputFieldFederationDirectiveContext, [{
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterInputFieldFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitInputFieldFederationDirective(this);
	      }
	    }
	  }]);

	  return InputFieldFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon98) {
	  _inherits(FieldDirectiveContext, _antlr4$ParserRuleCon98);

	  var _super99 = _createSuper(FieldDirectiveContext);

	  function FieldDirectiveContext(parser, parent, invokingState) {
	    var _this99;

	    _classCallCheck(this, FieldDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this99 = _super99.call(this, parent, invokingState);
	    _this99.parser = parser;
	    _this99.ruleIndex = GraphQLFederationParser.RULE_fieldDirective;
	    return _this99;
	  }

	  _createClass(FieldDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "fieldFederationDirective",
	    value: function fieldFederationDirective() {
	      return this.getTypedRuleContext(FieldFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFieldDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFieldDirective(this);
	      }
	    }
	  }]);

	  return FieldDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon99) {
	  _inherits(FieldFederationDirectiveContext, _antlr4$ParserRuleCon99);

	  var _super100 = _createSuper(FieldFederationDirectiveContext);

	  function FieldFederationDirectiveContext(parser, parent, invokingState) {
	    var _this100;

	    _classCallCheck(this, FieldFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this100 = _super100.call(this, parent, invokingState);
	    _this100.parser = parser;
	    _this100.ruleIndex = GraphQLFederationParser.RULE_fieldFederationDirective;
	    return _this100;
	  }

	  _createClass(FieldFederationDirectiveContext, [{
	    key: "externalDirective",
	    value: function externalDirective() {
	      return this.getTypedRuleContext(ExternalDirectiveContext, 0);
	    }
	  }, {
	    key: "requiresDirective",
	    value: function requiresDirective() {
	      return this.getTypedRuleContext(RequiresDirectiveContext, 0);
	    }
	  }, {
	    key: "providesDirective",
	    value: function providesDirective() {
	      return this.getTypedRuleContext(ProvidesDirectiveContext, 0);
	    }
	  }, {
	    key: "shareableDirective",
	    value: function shareableDirective() {
	      return this.getTypedRuleContext(ShareableDirectiveContext, 0);
	    }
	  }, {
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "overrideDirective",
	    value: function overrideDirective() {
	      return this.getTypedRuleContext(OverrideDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterFieldFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitFieldFederationDirective(this);
	      }
	    }
	  }]);

	  return FieldFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValueDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon100) {
	  _inherits(EnumValueDirectiveContext, _antlr4$ParserRuleCon100);

	  var _super101 = _createSuper(EnumValueDirectiveContext);

	  function EnumValueDirectiveContext(parser, parent, invokingState) {
	    var _this101;

	    _classCallCheck(this, EnumValueDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this101 = _super101.call(this, parent, invokingState);
	    _this101.parser = parser;
	    _this101.ruleIndex = GraphQLFederationParser.RULE_enumValueDirective;
	    return _this101;
	  }

	  _createClass(EnumValueDirectiveContext, [{
	    key: "directive",
	    value: function directive() {
	      return this.getTypedRuleContext(DirectiveContext, 0);
	    }
	  }, {
	    key: "enumValueFederationDirective",
	    value: function enumValueFederationDirective() {
	      return this.getTypedRuleContext(EnumValueFederationDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumValueDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumValueDirective(this);
	      }
	    }
	  }]);

	  return EnumValueDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValueFederationDirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon101) {
	  _inherits(EnumValueFederationDirectiveContext, _antlr4$ParserRuleCon101);

	  var _super102 = _createSuper(EnumValueFederationDirectiveContext);

	  function EnumValueFederationDirectiveContext(parser, parent, invokingState) {
	    var _this102;

	    _classCallCheck(this, EnumValueFederationDirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this102 = _super102.call(this, parent, invokingState);
	    _this102.parser = parser;
	    _this102.ruleIndex = GraphQLFederationParser.RULE_enumValueFederationDirective;
	    return _this102;
	  }

	  _createClass(EnumValueFederationDirectiveContext, [{
	    key: "inaccessibleDirective",
	    value: function inaccessibleDirective() {
	      return this.getTypedRuleContext(InaccessibleDirectiveContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterEnumValueFederationDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitEnumValueFederationDirective(this);
	      }
	    }
	  }]);

	  return EnumValueFederationDirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var NameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon102) {
	  _inherits(NameContext, _antlr4$ParserRuleCon102);

	  var _super103 = _createSuper(NameContext);

	  function NameContext(parser, parent, invokingState) {
	    var _this103;

	    _classCallCheck(this, NameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this103 = _super103.call(this, parent, invokingState);
	    _this103.parser = parser;
	    _this103.ruleIndex = GraphQLFederationParser.RULE_name;
	    return _this103;
	  }

	  _createClass(NameContext, [{
	    key: "keyword",
	    value: function keyword() {
	      return this.getTypedRuleContext(KeywordContext, 0);
	    }
	  }, {
	    key: "NAME",
	    value: function NAME() {
	      return this.getToken(GraphQLFederationParser.NAME, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitName(this);
	      }
	    }
	  }]);

	  return NameContext;
	}(_antlr["default"].ParserRuleContext);

	var Name_fContext = /*#__PURE__*/function (_antlr4$ParserRuleCon103) {
	  _inherits(Name_fContext, _antlr4$ParserRuleCon103);

	  var _super104 = _createSuper(Name_fContext);

	  function Name_fContext(parser, parent, invokingState) {
	    var _this104;

	    _classCallCheck(this, Name_fContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this104 = _super104.call(this, parent, invokingState);
	    _this104.parser = parser;
	    _this104.ruleIndex = GraphQLFederationParser.RULE_name_f;
	    return _this104;
	  }

	  _createClass(Name_fContext, [{
	    key: "keyword_f",
	    value: function keyword_f() {
	      return this.getTypedRuleContext(Keyword_fContext, 0);
	    }
	  }, {
	    key: "NAME_F",
	    value: function NAME_F() {
	      return this.getToken(GraphQLFederationParser.NAME_F, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterName_f(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitName_f(this);
	      }
	    }
	  }]);

	  return Name_fContext;
	}(_antlr["default"].ParserRuleContext);

	var BooleanValue_fContext = /*#__PURE__*/function (_antlr4$ParserRuleCon104) {
	  _inherits(BooleanValue_fContext, _antlr4$ParserRuleCon104);

	  var _super105 = _createSuper(BooleanValue_fContext);

	  function BooleanValue_fContext(parser, parent, invokingState) {
	    var _this105;

	    _classCallCheck(this, BooleanValue_fContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this105 = _super105.call(this, parent, invokingState);
	    _this105.parser = parser;
	    _this105.ruleIndex = GraphQLFederationParser.RULE_booleanValue_f;
	    return _this105;
	  }

	  _createClass(BooleanValue_fContext, [{
	    key: "TRUE_F",
	    value: function TRUE_F() {
	      return this.getToken(GraphQLFederationParser.TRUE_F, 0);
	    }
	  }, {
	    key: "FALSE_F",
	    value: function FALSE_F() {
	      return this.getToken(GraphQLFederationParser.FALSE_F, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterBooleanValue_f(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitBooleanValue_f(this);
	      }
	    }
	  }]);

	  return BooleanValue_fContext;
	}(_antlr["default"].ParserRuleContext);

	var KeywordContext = /*#__PURE__*/function (_antlr4$ParserRuleCon105) {
	  _inherits(KeywordContext, _antlr4$ParserRuleCon105);

	  var _super106 = _createSuper(KeywordContext);

	  function KeywordContext(parser, parent, invokingState) {
	    var _this106;

	    _classCallCheck(this, KeywordContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this106 = _super106.call(this, parent, invokingState);
	    _this106.parser = parser;
	    _this106.ruleIndex = GraphQLFederationParser.RULE_keyword;
	    return _this106;
	  }

	  _createClass(KeywordContext, [{
	    key: "INPUT_KEYWORD",
	    value: function INPUT_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.INPUT_KEYWORD, 0);
	    }
	  }, {
	    key: "TYPE_KEYWORD",
	    value: function TYPE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.TYPE_KEYWORD, 0);
	    }
	  }, {
	    key: "ENUM_KEYWORD",
	    value: function ENUM_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.ENUM_KEYWORD, 0);
	    }
	  }, {
	    key: "SCALAR_KEYWORD",
	    value: function SCALAR_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.SCALAR_KEYWORD, 0);
	    }
	  }, {
	    key: "INTERFACE_KEYWORD",
	    value: function INTERFACE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.INTERFACE_KEYWORD, 0);
	    }
	  }, {
	    key: "DIRECTIVE_KEYWORD",
	    value: function DIRECTIVE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.DIRECTIVE_KEYWORD, 0);
	    }
	  }, {
	    key: "EXTEND_KEYWORD",
	    value: function EXTEND_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD, 0);
	    }
	  }, {
	    key: "UNION_KEYWORD",
	    value: function UNION_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.UNION_KEYWORD, 0);
	    }
	  }, {
	    key: "IMPLEMENTS_KEYWORD",
	    value: function IMPLEMENTS_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.IMPLEMENTS_KEYWORD, 0);
	    }
	  }, {
	    key: "QUERY_KEYWORD",
	    value: function QUERY_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.QUERY_KEYWORD, 0);
	    }
	  }, {
	    key: "MUTATION_KEYWORD",
	    value: function MUTATION_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.MUTATION_KEYWORD, 0);
	    }
	  }, {
	    key: "SUBSCRIPTION_KEYWORD",
	    value: function SUBSCRIPTION_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.SUBSCRIPTION_KEYWORD, 0);
	    }
	  }, {
	    key: "SCHEMA_KEYWORD",
	    value: function SCHEMA_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.SCHEMA_KEYWORD, 0);
	    }
	  }, {
	    key: "FRAGMENT_KEYWORD",
	    value: function FRAGMENT_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.FRAGMENT_KEYWORD, 0);
	    }
	  }, {
	    key: "FIELDS_KEYWORD",
	    value: function FIELDS_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.FIELDS_KEYWORD, 0);
	    }
	  }, {
	    key: "FROM_KEYWORD",
	    value: function FROM_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.FROM_KEYWORD, 0);
	    }
	  }, {
	    key: "RESOLVABLE_KEYWORD",
	    value: function RESOLVABLE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.RESOLVABLE_KEYWORD, 0);
	    }
	  }, {
	    key: "ON_KEYWORD",
	    value: function ON_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.ON_KEYWORD, 0);
	    }
	  }, {
	    key: "REPEATABLE_KEYWORD",
	    value: function REPEATABLE_KEYWORD() {
	      return this.getToken(GraphQLFederationParser.REPEATABLE_KEYWORD, 0);
	    }
	  }, {
	    key: "INPUT_LOCATION",
	    value: function INPUT_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INPUT_LOCATION, 0);
	    }
	  }, {
	    key: "TYPE_LOCATION",
	    value: function TYPE_LOCATION() {
	      return this.getToken(GraphQLFederationParser.TYPE_LOCATION, 0);
	    }
	  }, {
	    key: "ENUM_LOCATION",
	    value: function ENUM_LOCATION() {
	      return this.getToken(GraphQLFederationParser.ENUM_LOCATION, 0);
	    }
	  }, {
	    key: "SCALAR_LOCATION",
	    value: function SCALAR_LOCATION() {
	      return this.getToken(GraphQLFederationParser.SCALAR_LOCATION, 0);
	    }
	  }, {
	    key: "INTERFACE_LOCATION",
	    value: function INTERFACE_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INTERFACE_LOCATION, 0);
	    }
	  }, {
	    key: "DIRECTIVE_LOCATION",
	    value: function DIRECTIVE_LOCATION() {
	      return this.getToken(GraphQLFederationParser.DIRECTIVE_LOCATION, 0);
	    }
	  }, {
	    key: "EXTEND_LOCATION",
	    value: function EXTEND_LOCATION() {
	      return this.getToken(GraphQLFederationParser.EXTEND_LOCATION, 0);
	    }
	  }, {
	    key: "UNION_LOCATION",
	    value: function UNION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.UNION_LOCATION, 0);
	    }
	  }, {
	    key: "IMPLEMENTS_LOCATION",
	    value: function IMPLEMENTS_LOCATION() {
	      return this.getToken(GraphQLFederationParser.IMPLEMENTS_LOCATION, 0);
	    }
	  }, {
	    key: "QUERY_LOCATION",
	    value: function QUERY_LOCATION() {
	      return this.getToken(GraphQLFederationParser.QUERY_LOCATION, 0);
	    }
	  }, {
	    key: "MUTATION_LOCATION",
	    value: function MUTATION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.MUTATION_LOCATION, 0);
	    }
	  }, {
	    key: "SUBSCRIPTION_LOCATION",
	    value: function SUBSCRIPTION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.SUBSCRIPTION_LOCATION, 0);
	    }
	  }, {
	    key: "SCHEMA_LOCATION",
	    value: function SCHEMA_LOCATION() {
	      return this.getToken(GraphQLFederationParser.SCHEMA_LOCATION, 0);
	    }
	  }, {
	    key: "FRAGMENT_LOCATION",
	    value: function FRAGMENT_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FRAGMENT_LOCATION, 0);
	    }
	  }, {
	    key: "FIELD_LOCATION",
	    value: function FIELD_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FIELD_LOCATION, 0);
	    }
	  }, {
	    key: "FRAGMENT_DEFINITION_LOCATION",
	    value: function FRAGMENT_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FRAGMENT_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "FRAGMENT_SPREAD_LOCATION",
	    value: function FRAGMENT_SPREAD_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FRAGMENT_SPREAD_LOCATION, 0);
	    }
	  }, {
	    key: "INLINE_FRAGMENT_LOCATION",
	    value: function INLINE_FRAGMENT_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INLINE_FRAGMENT_LOCATION, 0);
	    }
	  }, {
	    key: "VARIABLE_DEFINITION_LOCATION",
	    value: function VARIABLE_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.VARIABLE_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "OBJECT_LOCATION",
	    value: function OBJECT_LOCATION() {
	      return this.getToken(GraphQLFederationParser.OBJECT_LOCATION, 0);
	    }
	  }, {
	    key: "FIELD_DEFINITION_LOCATION",
	    value: function FIELD_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.FIELD_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "ARGUMENT_DEFINITION_LOCATION",
	    value: function ARGUMENT_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.ARGUMENT_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "ENUM_VALUE_LOCATION",
	    value: function ENUM_VALUE_LOCATION() {
	      return this.getToken(GraphQLFederationParser.ENUM_VALUE_LOCATION, 0);
	    }
	  }, {
	    key: "INPUT_OBJECT_LOCATION",
	    value: function INPUT_OBJECT_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INPUT_OBJECT_LOCATION, 0);
	    }
	  }, {
	    key: "INPUT_FIELD_DEFINITION_LOCATION",
	    value: function INPUT_FIELD_DEFINITION_LOCATION() {
	      return this.getToken(GraphQLFederationParser.INPUT_FIELD_DEFINITION_LOCATION, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterKeyword(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitKeyword(this);
	      }
	    }
	  }]);

	  return KeywordContext;
	}(_antlr["default"].ParserRuleContext);

	var Keyword_fContext = /*#__PURE__*/function (_antlr4$ParserRuleCon106) {
	  _inherits(Keyword_fContext, _antlr4$ParserRuleCon106);

	  var _super107 = _createSuper(Keyword_fContext);

	  function Keyword_fContext(parser, parent, invokingState) {
	    var _this107;

	    _classCallCheck(this, Keyword_fContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this107 = _super107.call(this, parent, invokingState);
	    _this107.parser = parser;
	    _this107.ruleIndex = GraphQLFederationParser.RULE_keyword_f;
	    return _this107;
	  }

	  _createClass(Keyword_fContext, [{
	    key: "INPUT_KEYWORD_F",
	    value: function INPUT_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.INPUT_KEYWORD_F, 0);
	    }
	  }, {
	    key: "TYPE_KEYWORD_F",
	    value: function TYPE_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.TYPE_KEYWORD_F, 0);
	    }
	  }, {
	    key: "ENUM_KEYWORD_F",
	    value: function ENUM_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.ENUM_KEYWORD_F, 0);
	    }
	  }, {
	    key: "SCALAR_KEYWORD_F",
	    value: function SCALAR_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.SCALAR_KEYWORD_F, 0);
	    }
	  }, {
	    key: "INTERFACE_KEYWORD_F",
	    value: function INTERFACE_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.INTERFACE_KEYWORD_F, 0);
	    }
	  }, {
	    key: "DIRECTIVE_KEYWORD_F",
	    value: function DIRECTIVE_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.DIRECTIVE_KEYWORD_F, 0);
	    }
	  }, {
	    key: "EXTEND_KEYWORD_F",
	    value: function EXTEND_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.EXTEND_KEYWORD_F, 0);
	    }
	  }, {
	    key: "UNION_KEYWORD_F",
	    value: function UNION_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.UNION_KEYWORD_F, 0);
	    }
	  }, {
	    key: "IMPLEMENTS_KEYWORD_F",
	    value: function IMPLEMENTS_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.IMPLEMENTS_KEYWORD_F, 0);
	    }
	  }, {
	    key: "QUERY_KEYWORD_F",
	    value: function QUERY_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.QUERY_KEYWORD_F, 0);
	    }
	  }, {
	    key: "MUTATION_KEYWORD_F",
	    value: function MUTATION_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.MUTATION_KEYWORD_F, 0);
	    }
	  }, {
	    key: "SUBSCRIPTION_KEYWORD_F",
	    value: function SUBSCRIPTION_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.SUBSCRIPTION_KEYWORD_F, 0);
	    }
	  }, {
	    key: "SCHEMA_KEYWORD_F",
	    value: function SCHEMA_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.SCHEMA_KEYWORD_F, 0);
	    }
	  }, {
	    key: "FRAGMENT_KEYWORD_F",
	    value: function FRAGMENT_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.FRAGMENT_KEYWORD_F, 0);
	    }
	  }, {
	    key: "ON_KEYWORD_F",
	    value: function ON_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.ON_KEYWORD_F, 0);
	    }
	  }, {
	    key: "REPEATABLE_KEYWORD_F",
	    value: function REPEATABLE_KEYWORD_F() {
	      return this.getToken(GraphQLFederationParser.REPEATABLE_KEYWORD_F, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.enterKeyword_f(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLFederationParserListener["default"]) {
	        listener.exitKeyword_f(this);
	      }
	    }
	  }]);

	  return Keyword_fContext;
	}(_antlr["default"].ParserRuleContext);

	GraphQLFederationParser.DocumentContext = DocumentContext;
	GraphQLFederationParser.DefinitionContext = DefinitionContext;
	GraphQLFederationParser.ExecutableDefinitionContext = ExecutableDefinitionContext;
	GraphQLFederationParser.OperationDefinitionContext = OperationDefinitionContext;
	GraphQLFederationParser.OperationTypeContext = OperationTypeContext;
	GraphQLFederationParser.SelectionSetContext = SelectionSetContext;
	GraphQLFederationParser.SelectionContext = SelectionContext;
	GraphQLFederationParser.FieldContext = FieldContext;
	GraphQLFederationParser.ArgumentsContext = ArgumentsContext;
	GraphQLFederationParser.ArgumentContext = ArgumentContext;
	GraphQLFederationParser.AliasContext = AliasContext;
	GraphQLFederationParser.FragmentSpreadContext = FragmentSpreadContext;
	GraphQLFederationParser.FragmentDefinitionContext = FragmentDefinitionContext;
	GraphQLFederationParser.FragmentNameContext = FragmentNameContext;
	GraphQLFederationParser.TypeConditionContext = TypeConditionContext;
	GraphQLFederationParser.InlineFragmentContext = InlineFragmentContext;
	GraphQLFederationParser.ValueContext = ValueContext;
	GraphQLFederationParser.IntValueContext = IntValueContext;
	GraphQLFederationParser.FloatValueContext = FloatValueContext;
	GraphQLFederationParser.BooleanValueContext = BooleanValueContext;
	GraphQLFederationParser.StringValueContext = StringValueContext;
	GraphQLFederationParser.NullValueContext = NullValueContext;
	GraphQLFederationParser.EnumValueContext = EnumValueContext;
	GraphQLFederationParser.ListValueContext = ListValueContext;
	GraphQLFederationParser.ObjectValueContext = ObjectValueContext;
	GraphQLFederationParser.ObjectFieldContext = ObjectFieldContext;
	GraphQLFederationParser.VariableContext = VariableContext;
	GraphQLFederationParser.VariableDefinitionsContext = VariableDefinitionsContext;
	GraphQLFederationParser.VariableDefinitionContext = VariableDefinitionContext;
	GraphQLFederationParser.DefaultValueContext = DefaultValueContext;
	GraphQLFederationParser.Type_Context = Type_Context;
	GraphQLFederationParser.NamedTypeContext = NamedTypeContext;
	GraphQLFederationParser.ListTypeContext = ListTypeContext;
	GraphQLFederationParser.DirectivesContext = DirectivesContext;
	GraphQLFederationParser.DirectiveContext = DirectiveContext;
	GraphQLFederationParser.TypeSystemDefinitionContext = TypeSystemDefinitionContext;
	GraphQLFederationParser.TypeSystemExtensionContext = TypeSystemExtensionContext;
	GraphQLFederationParser.SchemaDefinitionContext = SchemaDefinitionContext;
	GraphQLFederationParser.RootOperationTypeDefinitionContext = RootOperationTypeDefinitionContext;
	GraphQLFederationParser.SchemaExtensionContext = SchemaExtensionContext;
	GraphQLFederationParser.OperationTypeDefinitionContext = OperationTypeDefinitionContext;
	GraphQLFederationParser.DescriptionContext = DescriptionContext;
	GraphQLFederationParser.TypeDefinitionContext = TypeDefinitionContext;
	GraphQLFederationParser.TypeExtensionContext = TypeExtensionContext;
	GraphQLFederationParser.ScalarTypeDefinitionContext = ScalarTypeDefinitionContext;
	GraphQLFederationParser.ScalarTypeExtensionContext = ScalarTypeExtensionContext;
	GraphQLFederationParser.ObjectTypeDefinitionContext = ObjectTypeDefinitionContext;
	GraphQLFederationParser.ImplementsInterfacesContext = ImplementsInterfacesContext;
	GraphQLFederationParser.FieldsDefinitionContext = FieldsDefinitionContext;
	GraphQLFederationParser.FieldDefinitionContext = FieldDefinitionContext;
	GraphQLFederationParser.ArgumentsDefinitionContext = ArgumentsDefinitionContext;
	GraphQLFederationParser.InputValueDefinitionContext = InputValueDefinitionContext;
	GraphQLFederationParser.ObjectTypeExtensionContext = ObjectTypeExtensionContext;
	GraphQLFederationParser.InterfaceTypeDefinitionContext = InterfaceTypeDefinitionContext;
	GraphQLFederationParser.InterfaceTypeExtensionContext = InterfaceTypeExtensionContext;
	GraphQLFederationParser.UnionTypeDefinitionContext = UnionTypeDefinitionContext;
	GraphQLFederationParser.UnionMemberTypesContext = UnionMemberTypesContext;
	GraphQLFederationParser.UnionTypeExtensionContext = UnionTypeExtensionContext;
	GraphQLFederationParser.EnumTypeDefinitionContext = EnumTypeDefinitionContext;
	GraphQLFederationParser.EnumValuesDefinitionContext = EnumValuesDefinitionContext;
	GraphQLFederationParser.EnumValueDefinitionContext = EnumValueDefinitionContext;
	GraphQLFederationParser.EnumTypeExtensionContext = EnumTypeExtensionContext;
	GraphQLFederationParser.InputObjectTypeDefinitionContext = InputObjectTypeDefinitionContext;
	GraphQLFederationParser.InputFieldsDefinitionContext = InputFieldsDefinitionContext;
	GraphQLFederationParser.InputObjectTypeExtensionContext = InputObjectTypeExtensionContext;
	GraphQLFederationParser.DirectiveDefinitionContext = DirectiveDefinitionContext;
	GraphQLFederationParser.DirectiveLocationsContext = DirectiveLocationsContext;
	GraphQLFederationParser.DirectiveLocationContext = DirectiveLocationContext;
	GraphQLFederationParser.ExecutableDirectiveLocationContext = ExecutableDirectiveLocationContext;
	GraphQLFederationParser.TypeSystemDirectiveLocationContext = TypeSystemDirectiveLocationContext;
	GraphQLFederationParser.ExternalDirectiveContext = ExternalDirectiveContext;
	GraphQLFederationParser.InaccessibleDirectiveContext = InaccessibleDirectiveContext;
	GraphQLFederationParser.RequiresDirectiveContext = RequiresDirectiveContext;
	GraphQLFederationParser.ProvidesDirectiveContext = ProvidesDirectiveContext;
	GraphQLFederationParser.KeyDirectiveContext = KeyDirectiveContext;
	GraphQLFederationParser.ShareableDirectiveContext = ShareableDirectiveContext;
	GraphQLFederationParser.OverrideDirectiveContext = OverrideDirectiveContext;
	GraphQLFederationParser.LinkDirectiveContext = LinkDirectiveContext;
	GraphQLFederationParser.FieldSetContext = FieldSetContext;
	GraphQLFederationParser.FieldSetComponentContext = FieldSetComponentContext;
	GraphQLFederationParser.NestedFieldSetContext = NestedFieldSetContext;
	GraphQLFederationParser.SchemaDirectiveContext = SchemaDirectiveContext;
	GraphQLFederationParser.SchemaFederationDirectiveContext = SchemaFederationDirectiveContext;
	GraphQLFederationParser.ScalarDirectiveContext = ScalarDirectiveContext;
	GraphQLFederationParser.ScalarFederationDirectiveContext = ScalarFederationDirectiveContext;
	GraphQLFederationParser.ObjectDirectiveContext = ObjectDirectiveContext;
	GraphQLFederationParser.ObjectFederationDirectiveContext = ObjectFederationDirectiveContext;
	GraphQLFederationParser.InterfaceDirectiveContext = InterfaceDirectiveContext;
	GraphQLFederationParser.InterfaceFederationDirectiveContext = InterfaceFederationDirectiveContext;
	GraphQLFederationParser.UnionDirectiveContext = UnionDirectiveContext;
	GraphQLFederationParser.UnionFederationDirectiveContext = UnionFederationDirectiveContext;
	GraphQLFederationParser.EnumDirectiveContext = EnumDirectiveContext;
	GraphQLFederationParser.EnumFederationDirectiveContext = EnumFederationDirectiveContext;
	GraphQLFederationParser.InputObjectDirectiveContext = InputObjectDirectiveContext;
	GraphQLFederationParser.InputObjectFederationDirectiveContext = InputObjectFederationDirectiveContext;
	GraphQLFederationParser.InputValueDirectiveContext = InputValueDirectiveContext;
	GraphQLFederationParser.InputFieldFederationDirectiveContext = InputFieldFederationDirectiveContext;
	GraphQLFederationParser.FieldDirectiveContext = FieldDirectiveContext;
	GraphQLFederationParser.FieldFederationDirectiveContext = FieldFederationDirectiveContext;
	GraphQLFederationParser.EnumValueDirectiveContext = EnumValueDirectiveContext;
	GraphQLFederationParser.EnumValueFederationDirectiveContext = EnumValueFederationDirectiveContext;
	GraphQLFederationParser.NameContext = NameContext;
	GraphQLFederationParser.Name_fContext = Name_fContext;
	GraphQLFederationParser.BooleanValue_fContext = BooleanValue_fContext;
	GraphQLFederationParser.KeywordContext = KeywordContext;
	GraphQLFederationParser.Keyword_fContext = Keyword_fContext;
} (GraphQLFederationParser));

var GraphqlFederationParser = /*@__PURE__*/getDefaultExportFromCjs(GraphQLFederationParser);

var GraphQLFederationListener = {};

(function (exports) {

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function _typeof(obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();

	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	} // This class defines a complete listener for a parse tree produced by GraphQLFederationParser.


	var GraphQLFederationListener = /*#__PURE__*/function (_antlr4$tree$ParseTre) {
	  _inherits(GraphQLFederationListener, _antlr4$tree$ParseTre);

	  var _super = _createSuper(GraphQLFederationListener);

	  function GraphQLFederationListener() {
	    _classCallCheck(this, GraphQLFederationListener);

	    return _super.apply(this, arguments);
	  }

	  _createClass(GraphQLFederationListener, [{
	    key: "enterDocument",
	    value: // Enter a parse tree produced by GraphQLFederationParser#document.
	    function enterDocument(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#document.

	  }, {
	    key: "exitDocument",
	    value: function exitDocument(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#definition.

	  }, {
	    key: "enterDefinition",
	    value: function enterDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#definition.

	  }, {
	    key: "exitDefinition",
	    value: function exitDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#executableDefinition.

	  }, {
	    key: "enterExecutableDefinition",
	    value: function enterExecutableDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#executableDefinition.

	  }, {
	    key: "exitExecutableDefinition",
	    value: function exitExecutableDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#operationDefinition.

	  }, {
	    key: "enterOperationDefinition",
	    value: function enterOperationDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#operationDefinition.

	  }, {
	    key: "exitOperationDefinition",
	    value: function exitOperationDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#operationType.

	  }, {
	    key: "enterOperationType",
	    value: function enterOperationType(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#operationType.

	  }, {
	    key: "exitOperationType",
	    value: function exitOperationType(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#selectionSet.

	  }, {
	    key: "enterSelectionSet",
	    value: function enterSelectionSet(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#selectionSet.

	  }, {
	    key: "exitSelectionSet",
	    value: function exitSelectionSet(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#selection.

	  }, {
	    key: "enterSelection",
	    value: function enterSelection(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#selection.

	  }, {
	    key: "exitSelection",
	    value: function exitSelection(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#field.

	  }, {
	    key: "enterField",
	    value: function enterField(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#field.

	  }, {
	    key: "exitField",
	    value: function exitField(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#arguments.

	  }, {
	    key: "enterArguments",
	    value: function enterArguments(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#arguments.

	  }, {
	    key: "exitArguments",
	    value: function exitArguments(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#argument.

	  }, {
	    key: "enterArgument",
	    value: function enterArgument(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#argument.

	  }, {
	    key: "exitArgument",
	    value: function exitArgument(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#alias.

	  }, {
	    key: "enterAlias",
	    value: function enterAlias(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#alias.

	  }, {
	    key: "exitAlias",
	    value: function exitAlias(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fragmentSpread.

	  }, {
	    key: "enterFragmentSpread",
	    value: function enterFragmentSpread(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fragmentSpread.

	  }, {
	    key: "exitFragmentSpread",
	    value: function exitFragmentSpread(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fragmentDefinition.

	  }, {
	    key: "enterFragmentDefinition",
	    value: function enterFragmentDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fragmentDefinition.

	  }, {
	    key: "exitFragmentDefinition",
	    value: function exitFragmentDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fragmentName.

	  }, {
	    key: "enterFragmentName",
	    value: function enterFragmentName(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fragmentName.

	  }, {
	    key: "exitFragmentName",
	    value: function exitFragmentName(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeCondition.

	  }, {
	    key: "enterTypeCondition",
	    value: function enterTypeCondition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeCondition.

	  }, {
	    key: "exitTypeCondition",
	    value: function exitTypeCondition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inlineFragment.

	  }, {
	    key: "enterInlineFragment",
	    value: function enterInlineFragment(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inlineFragment.

	  }, {
	    key: "exitInlineFragment",
	    value: function exitInlineFragment(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#value.

	  }, {
	    key: "enterValue",
	    value: function enterValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#value.

	  }, {
	    key: "exitValue",
	    value: function exitValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#intValue.

	  }, {
	    key: "enterIntValue",
	    value: function enterIntValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#intValue.

	  }, {
	    key: "exitIntValue",
	    value: function exitIntValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#floatValue.

	  }, {
	    key: "enterFloatValue",
	    value: function enterFloatValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#floatValue.

	  }, {
	    key: "exitFloatValue",
	    value: function exitFloatValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#booleanValue.

	  }, {
	    key: "enterBooleanValue",
	    value: function enterBooleanValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#booleanValue.

	  }, {
	    key: "exitBooleanValue",
	    value: function exitBooleanValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#stringValue.

	  }, {
	    key: "enterStringValue",
	    value: function enterStringValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#stringValue.

	  }, {
	    key: "exitStringValue",
	    value: function exitStringValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#nullValue.

	  }, {
	    key: "enterNullValue",
	    value: function enterNullValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#nullValue.

	  }, {
	    key: "exitNullValue",
	    value: function exitNullValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumValue.

	  }, {
	    key: "enterEnumValue",
	    value: function enterEnumValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumValue.

	  }, {
	    key: "exitEnumValue",
	    value: function exitEnumValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#listValue.

	  }, {
	    key: "enterListValue",
	    value: function enterListValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#listValue.

	  }, {
	    key: "exitListValue",
	    value: function exitListValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectValue.

	  }, {
	    key: "enterObjectValue",
	    value: function enterObjectValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectValue.

	  }, {
	    key: "exitObjectValue",
	    value: function exitObjectValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectField.

	  }, {
	    key: "enterObjectField",
	    value: function enterObjectField(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectField.

	  }, {
	    key: "exitObjectField",
	    value: function exitObjectField(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#variable.

	  }, {
	    key: "enterVariable",
	    value: function enterVariable(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#variable.

	  }, {
	    key: "exitVariable",
	    value: function exitVariable(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#variableDefinitions.

	  }, {
	    key: "enterVariableDefinitions",
	    value: function enterVariableDefinitions(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#variableDefinitions.

	  }, {
	    key: "exitVariableDefinitions",
	    value: function exitVariableDefinitions(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#variableDefinition.

	  }, {
	    key: "enterVariableDefinition",
	    value: function enterVariableDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#variableDefinition.

	  }, {
	    key: "exitVariableDefinition",
	    value: function exitVariableDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#defaultValue.

	  }, {
	    key: "enterDefaultValue",
	    value: function enterDefaultValue(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#defaultValue.

	  }, {
	    key: "exitDefaultValue",
	    value: function exitDefaultValue(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#type_.

	  }, {
	    key: "enterType_",
	    value: function enterType_(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#type_.

	  }, {
	    key: "exitType_",
	    value: function exitType_(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#namedType.

	  }, {
	    key: "enterNamedType",
	    value: function enterNamedType(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#namedType.

	  }, {
	    key: "exitNamedType",
	    value: function exitNamedType(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#listType.

	  }, {
	    key: "enterListType",
	    value: function enterListType(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#listType.

	  }, {
	    key: "exitListType",
	    value: function exitListType(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directives.

	  }, {
	    key: "enterDirectives",
	    value: function enterDirectives(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directives.

	  }, {
	    key: "exitDirectives",
	    value: function exitDirectives(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directive.

	  }, {
	    key: "enterDirective",
	    value: function enterDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directive.

	  }, {
	    key: "exitDirective",
	    value: function exitDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeSystemDefinition.

	  }, {
	    key: "enterTypeSystemDefinition",
	    value: function enterTypeSystemDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeSystemDefinition.

	  }, {
	    key: "exitTypeSystemDefinition",
	    value: function exitTypeSystemDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeSystemExtension.

	  }, {
	    key: "enterTypeSystemExtension",
	    value: function enterTypeSystemExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeSystemExtension.

	  }, {
	    key: "exitTypeSystemExtension",
	    value: function exitTypeSystemExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#schemaDefinition.

	  }, {
	    key: "enterSchemaDefinition",
	    value: function enterSchemaDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#schemaDefinition.

	  }, {
	    key: "exitSchemaDefinition",
	    value: function exitSchemaDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#rootOperationTypeDefinition.

	  }, {
	    key: "enterRootOperationTypeDefinition",
	    value: function enterRootOperationTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#rootOperationTypeDefinition.

	  }, {
	    key: "exitRootOperationTypeDefinition",
	    value: function exitRootOperationTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#schemaExtension.

	  }, {
	    key: "enterSchemaExtension",
	    value: function enterSchemaExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#schemaExtension.

	  }, {
	    key: "exitSchemaExtension",
	    value: function exitSchemaExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#operationTypeDefinition.

	  }, {
	    key: "enterOperationTypeDefinition",
	    value: function enterOperationTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#operationTypeDefinition.

	  }, {
	    key: "exitOperationTypeDefinition",
	    value: function exitOperationTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#description.

	  }, {
	    key: "enterDescription",
	    value: function enterDescription(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#description.

	  }, {
	    key: "exitDescription",
	    value: function exitDescription(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeDefinition.

	  }, {
	    key: "enterTypeDefinition",
	    value: function enterTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeDefinition.

	  }, {
	    key: "exitTypeDefinition",
	    value: function exitTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeExtension.

	  }, {
	    key: "enterTypeExtension",
	    value: function enterTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeExtension.

	  }, {
	    key: "exitTypeExtension",
	    value: function exitTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#scalarTypeDefinition.

	  }, {
	    key: "enterScalarTypeDefinition",
	    value: function enterScalarTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#scalarTypeDefinition.

	  }, {
	    key: "exitScalarTypeDefinition",
	    value: function exitScalarTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#scalarTypeExtension.

	  }, {
	    key: "enterScalarTypeExtension",
	    value: function enterScalarTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#scalarTypeExtension.

	  }, {
	    key: "exitScalarTypeExtension",
	    value: function exitScalarTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectTypeDefinition.

	  }, {
	    key: "enterObjectTypeDefinition",
	    value: function enterObjectTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectTypeDefinition.

	  }, {
	    key: "exitObjectTypeDefinition",
	    value: function exitObjectTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#implementsInterfaces.

	  }, {
	    key: "enterImplementsInterfaces",
	    value: function enterImplementsInterfaces(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#implementsInterfaces.

	  }, {
	    key: "exitImplementsInterfaces",
	    value: function exitImplementsInterfaces(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldsDefinition.

	  }, {
	    key: "enterFieldsDefinition",
	    value: function enterFieldsDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldsDefinition.

	  }, {
	    key: "exitFieldsDefinition",
	    value: function exitFieldsDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldDefinition.

	  }, {
	    key: "enterFieldDefinition",
	    value: function enterFieldDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldDefinition.

	  }, {
	    key: "exitFieldDefinition",
	    value: function exitFieldDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#argumentsDefinition.

	  }, {
	    key: "enterArgumentsDefinition",
	    value: function enterArgumentsDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#argumentsDefinition.

	  }, {
	    key: "exitArgumentsDefinition",
	    value: function exitArgumentsDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputValueDefinition.

	  }, {
	    key: "enterInputValueDefinition",
	    value: function enterInputValueDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputValueDefinition.

	  }, {
	    key: "exitInputValueDefinition",
	    value: function exitInputValueDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#objectTypeExtension.

	  }, {
	    key: "enterObjectTypeExtension",
	    value: function enterObjectTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#objectTypeExtension.

	  }, {
	    key: "exitObjectTypeExtension",
	    value: function exitObjectTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#interfaceTypeDefinition.

	  }, {
	    key: "enterInterfaceTypeDefinition",
	    value: function enterInterfaceTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#interfaceTypeDefinition.

	  }, {
	    key: "exitInterfaceTypeDefinition",
	    value: function exitInterfaceTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#interfaceTypeExtension.

	  }, {
	    key: "enterInterfaceTypeExtension",
	    value: function enterInterfaceTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#interfaceTypeExtension.

	  }, {
	    key: "exitInterfaceTypeExtension",
	    value: function exitInterfaceTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#unionTypeDefinition.

	  }, {
	    key: "enterUnionTypeDefinition",
	    value: function enterUnionTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#unionTypeDefinition.

	  }, {
	    key: "exitUnionTypeDefinition",
	    value: function exitUnionTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#unionMemberTypes.

	  }, {
	    key: "enterUnionMemberTypes",
	    value: function enterUnionMemberTypes(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#unionMemberTypes.

	  }, {
	    key: "exitUnionMemberTypes",
	    value: function exitUnionMemberTypes(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#unionTypeExtension.

	  }, {
	    key: "enterUnionTypeExtension",
	    value: function enterUnionTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#unionTypeExtension.

	  }, {
	    key: "exitUnionTypeExtension",
	    value: function exitUnionTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumTypeDefinition.

	  }, {
	    key: "enterEnumTypeDefinition",
	    value: function enterEnumTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumTypeDefinition.

	  }, {
	    key: "exitEnumTypeDefinition",
	    value: function exitEnumTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumValuesDefinition.

	  }, {
	    key: "enterEnumValuesDefinition",
	    value: function enterEnumValuesDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumValuesDefinition.

	  }, {
	    key: "exitEnumValuesDefinition",
	    value: function exitEnumValuesDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumValueDefinition.

	  }, {
	    key: "enterEnumValueDefinition",
	    value: function enterEnumValueDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumValueDefinition.

	  }, {
	    key: "exitEnumValueDefinition",
	    value: function exitEnumValueDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#enumTypeExtension.

	  }, {
	    key: "enterEnumTypeExtension",
	    value: function enterEnumTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#enumTypeExtension.

	  }, {
	    key: "exitEnumTypeExtension",
	    value: function exitEnumTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputObjectTypeDefinition.

	  }, {
	    key: "enterInputObjectTypeDefinition",
	    value: function enterInputObjectTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputObjectTypeDefinition.

	  }, {
	    key: "exitInputObjectTypeDefinition",
	    value: function exitInputObjectTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputFieldsDefinition.

	  }, {
	    key: "enterInputFieldsDefinition",
	    value: function enterInputFieldsDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputFieldsDefinition.

	  }, {
	    key: "exitInputFieldsDefinition",
	    value: function exitInputFieldsDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#inputObjectTypeExtension.

	  }, {
	    key: "enterInputObjectTypeExtension",
	    value: function enterInputObjectTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#inputObjectTypeExtension.

	  }, {
	    key: "exitInputObjectTypeExtension",
	    value: function exitInputObjectTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directiveDefinition.

	  }, {
	    key: "enterDirectiveDefinition",
	    value: function enterDirectiveDefinition(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directiveDefinition.

	  }, {
	    key: "exitDirectiveDefinition",
	    value: function exitDirectiveDefinition(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directiveLocations.

	  }, {
	    key: "enterDirectiveLocations",
	    value: function enterDirectiveLocations(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directiveLocations.

	  }, {
	    key: "exitDirectiveLocations",
	    value: function exitDirectiveLocations(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#directiveLocation.

	  }, {
	    key: "enterDirectiveLocation",
	    value: function enterDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#directiveLocation.

	  }, {
	    key: "exitDirectiveLocation",
	    value: function exitDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#executableDirectiveLocation.

	  }, {
	    key: "enterExecutableDirectiveLocation",
	    value: function enterExecutableDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#executableDirectiveLocation.

	  }, {
	    key: "exitExecutableDirectiveLocation",
	    value: function exitExecutableDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeSystemDirectiveLocation.

	  }, {
	    key: "enterTypeSystemDirectiveLocation",
	    value: function enterTypeSystemDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeSystemDirectiveLocation.

	  }, {
	    key: "exitTypeSystemDirectiveLocation",
	    value: function exitTypeSystemDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#externalDirective.

	  }, {
	    key: "enterExternalDirective",
	    value: function enterExternalDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#externalDirective.

	  }, {
	    key: "exitExternalDirective",
	    value: function exitExternalDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#requiresDirective.

	  }, {
	    key: "enterRequiresDirective",
	    value: function enterRequiresDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#requiresDirective.

	  }, {
	    key: "exitRequiresDirective",
	    value: function exitRequiresDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#providesDirective.

	  }, {
	    key: "enterProvidesDirective",
	    value: function enterProvidesDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#providesDirective.

	  }, {
	    key: "exitProvidesDirective",
	    value: function exitProvidesDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#keyDirective.

	  }, {
	    key: "enterKeyDirective",
	    value: function enterKeyDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#keyDirective.

	  }, {
	    key: "exitKeyDirective",
	    value: function exitKeyDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#shareableDirective.

	  }, {
	    key: "enterShareableDirective",
	    value: function enterShareableDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#shareableDirective.

	  }, {
	    key: "exitShareableDirective",
	    value: function exitShareableDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#overrideDirective.

	  }, {
	    key: "enterOverrideDirective",
	    value: function enterOverrideDirective(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#overrideDirective.

	  }, {
	    key: "exitOverrideDirective",
	    value: function exitOverrideDirective(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldSet.

	  }, {
	    key: "enterFieldSet",
	    value: function enterFieldSet(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldSet.

	  }, {
	    key: "exitFieldSet",
	    value: function exitFieldSet(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldSetComponent.

	  }, {
	    key: "enterFieldSetComponent",
	    value: function enterFieldSetComponent(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldSetComponent.

	  }, {
	    key: "exitFieldSetComponent",
	    value: function exitFieldSetComponent(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#nestedFieldSet.

	  }, {
	    key: "enterNestedFieldSet",
	    value: function enterNestedFieldSet(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#nestedFieldSet.

	  }, {
	    key: "exitNestedFieldSet",
	    value: function exitNestedFieldSet(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#fieldDefinitionFederationDirectives.

	  }, {
	    key: "enterFieldDefinitionFederationDirectives",
	    value: function enterFieldDefinitionFederationDirectives(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#fieldDefinitionFederationDirectives.

	  }, {
	    key: "exitFieldDefinitionFederationDirectives",
	    value: function exitFieldDefinitionFederationDirectives(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeDefinitionFederationDirectives.

	  }, {
	    key: "enterTypeDefinitionFederationDirectives",
	    value: function enterTypeDefinitionFederationDirectives(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeDefinitionFederationDirectives.

	  }, {
	    key: "exitTypeDefinitionFederationDirectives",
	    value: function exitTypeDefinitionFederationDirectives(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#typeExtensionFederationDirectives.

	  }, {
	    key: "enterTypeExtensionFederationDirectives",
	    value: function enterTypeExtensionFederationDirectives(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#typeExtensionFederationDirectives.

	  }, {
	    key: "exitTypeExtensionFederationDirectives",
	    value: function exitTypeExtensionFederationDirectives(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#name.

	  }, {
	    key: "enterName",
	    value: function enterName(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#name.

	  }, {
	    key: "exitName",
	    value: function exitName(ctx) {} // Enter a parse tree produced by GraphQLFederationParser#keyword.

	  }, {
	    key: "enterKeyword",
	    value: function enterKeyword(ctx) {} // Exit a parse tree produced by GraphQLFederationParser#keyword.

	  }, {
	    key: "exitKeyword",
	    value: function exitKeyword(ctx) {}
	  }]);

	  return GraphQLFederationListener;
	}(_antlr["default"].tree.ParseTreeListener);

	exports["default"] = GraphQLFederationListener;
} (GraphQLFederationListener));

var GraphqlFederationListener = /*@__PURE__*/getDefaultExportFromCjs(GraphQLFederationListener);

class GraphqlFederationASTBuilderCB$1 extends GraphqlFederationListener {

    visitTerminal(node) {
        this.cb.visitTerminal(node, this.parser);
    }

    visitErrorNode(node) {
        this.cb.visitErrorNode(node, this.parser);
    }

    enterEveryRule(node) {
        this.cb.enterEveryRule(node, this.parser);
    }


    exitEveryRule(node) {
        this.cb.exitEveryRule();
    }

    run(input, cb, errorListener) {
        this.cb = cb;
        const chars = new antlr4.InputStream(input);
        const lexer = new GraphqlFederationLexer(chars);
        lexer.removeErrorListeners();
        lexer.addErrorListener(errorListener);
        const tokens = new antlr4.CommonTokenStream(lexer);
        const parser = new GraphqlFederationParser(tokens);
        parser.removeErrorListeners();
        parser.addErrorListener(errorListener);
        this.parser = parser;
        this.parser.buildParseTrees = true;
        const tree = this.parser.document();
        antlr4.tree.ParseTreeWalker.DEFAULT.walk(this, tree);
    }
}

var graphqlfederationcb_m = /*#__PURE__*/Object.freeze({
	__proto__: null,
	GraphqlFederationASTBuilderCB: GraphqlFederationASTBuilderCB$1
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(graphqlfederationcb_m);

var GraphQLLexer = {};

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var serializedATN = ["\x03\u608B\uA72A\u8133\uB9ED\u417C\u3BE7\u7786", "\u5964\x02J\u0308\b\x01\x04\x02\t\x02\x04\x03\t\x03", "\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07", "\t\x07\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\x0B\t\x0B\x04", "\f\t\f\x04\r\t\r\x04\x0E\t\x0E\x04\x0F\t\x0F\x04\x10", "\t\x10\x04\x11\t\x11\x04\x12\t\x12\x04\x13\t\x13", "\x04\x14\t\x14\x04\x15\t\x15\x04\x16\t\x16\x04\x17", "\t\x17\x04\x18\t\x18\x04\x19\t\x19\x04\x1A\t\x1A", "\x04\x1B\t\x1B\x04\x1C\t\x1C\x04\x1D\t\x1D\x04\x1E", "\t\x1E\x04\x1F\t\x1F\x04 \t \x04!\t!\x04\"\t\"\x04#", "\t#\x04$\t$\x04%\t%\x04&\t&\x04'\t'\x04(\t(\x04)\t)\x04", "*\t*\x04+\t+\x04,\t,\x04-\t-\x04.\t.\x04/\t/\x040\t0\x04", "1\t1\x042\t2\x043\t3\x044\t4\x045\t5\x046\t6\x047\t7\x04", "8\t8\x049\t9\x04:\t:\x04;\t;\x04<\t<\x04=\t=\x04>\t>\x04", "?\t?\x04@\t@\x04A\tA\x04B\tB\x04C\tC\x04D\tD\x04E\tE\x04", "F\tF\x04G\tG\x04H\tH\x04I\tI\x04J\tJ\x04K\tK\x04L\tL\x04", "M\tM\x04N\tN\x04O\tO\x04P\tP\x04Q\tQ\x04R\tR\x04S\tS\x04", "T\tT\x04U\tU\x03\x02\x03\x02\x03\x02\x03\x02\x03", "\x02\x03\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03", "\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x03", "\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03", "\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03", "\x05\x03\x05\x03\x06\x03\x06\x03\x07\x03\x07\x03", "\b\x03\b\x03\t\x03\t\x03\n\x03\n\x03\n\x03\n\x03\x0B", "\x03\x0B\x03\x0B\x03\x0B\x03\x0B\x03\x0B\x03\x0B", "\x03\x0B\x03\x0B\x03\f\x03\f\x03\f\x03\r\x03\r\x03", "\r\x03\r\x03\r\x03\x0E\x03\x0E\x03\x0E\x03\x0E\x03", "\x0E\x03\x0E\x03\x0F\x03\x0F\x03\x0F\x03\x0F\x03", "\x0F\x03\x10\x03\x10\x03\x11\x03\x11\x03\x12\x03", "\x12\x03\x13\x03\x13\x03\x14\x03\x14\x03\x15\x03", "\x15\x03\x16\x03\x16\x03\x16\x03\x16\x03\x16\x03", "\x16\x03\x16\x03\x17\x03\x17\x03\x17\x03\x17\x03", "\x17\x03\x17\x03\x17\x03\x18\x03\x18\x03\x18\x03", "\x18\x03\x18\x03\x18\x03\x18\x03\x19\x03\x19\x03", "\x19\x03\x19\x03\x19\x03\x1A\x03\x1A\x03\x1A\x03", "\x1A\x03\x1A\x03\x1A\x03\x1A\x03\x1A\x03\x1A\x03", "\x1A\x03\x1A\x03\x1B\x03\x1B\x03\x1C\x03\x1C\x03", "\x1C\x03\x1C\x03\x1C\x03\x1C\x03\x1C\x03\x1C\x03", "\x1C\x03\x1C\x03\x1D\x03\x1D\x03\x1D\x03\x1D\x03", "\x1D\x03\x1D\x03\x1E\x03\x1E\x03\x1F\x03\x1F\x03", "\x1F\x03\x1F\x03\x1F\x03 \x03 \x03 \x03 \x03 \x03", " \x03!\x03!\x03!\x03!\x03!\x03!\x03!\x03!\x03!\x03", "!\x03\"\x03\"\x03\"\x03\"\x03\"\x03\"\x03\"\x03\"\x03", "\"\x03\"\x03\"\x03#\x03#\x03#\x03#\x03#\x03#\x03$", "\x03$\x03$\x03$\x03$\x03$\x03$\x03$\x03$\x03%\x03", "%\x03%\x03%\x03%\x03%\x03%\x03%\x03%\x03%\x03%\x03", "%\x03%\x03&\x03&\x03&\x03&\x03&\x03&\x03'\x03'\x03", "'\x03'\x03'\x03'\x03'\x03'\x03'\x03'\x03'\x03", "'\x03'\x03'\x03'\x03'\x03'\x03'\x03'\x03'\x03", "(\x03(\x03(\x03(\x03(\x03(\x03(\x03(\x03(\x03(\x03", "(\x03(\x03(\x03(\x03(\x03(\x03)\x03)\x03)\x03)\x03", ")\x03)\x03)\x03)\x03)\x03)\x03)\x03)\x03)\x03)\x03", ")\x03)\x03*\x03*\x03*\x03*\x03*\x03*\x03*\x03*\x03", "*\x03*\x03*\x03*\x03*\x03*\x03*\x03*\x03*\x03*\x03", "*\x03*\x03+\x03+\x03+\x03+\x03+\x03+\x03+\x03,\x03", ",\x03,\x03,\x03,\x03,\x03,\x03-\x03-\x03-\x03-\x03", "-\x03-\x03-\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03", ".\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03.\x03", "/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03", "/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03/\x03", "0\x030\x030\x030\x030\x030\x030\x030\x030\x030\x03", "1\x031\x031\x031\x031\x031\x032\x032\x032\x032\x03", "2\x033\x033\x033\x033\x033\x033\x033\x033\x033\x03", "3\x033\x034\x034\x034\x034\x034\x034\x034\x034\x03", "4\x034\x034\x034\x034\x035\x035\x035\x035\x035\x03", "5\x035\x035\x035\x035\x035\x035\x035\x035\x035\x03", "5\x035\x035\x035\x035\x035\x035\x035\x036\x036\x03", "6\x036\x036\x036\x037\x037\x037\x037\x037\x038\x03", "8\x038\x038\x038\x038\x038\x038\x038\x038\x039\x03", "9\x039\x039\x039\x039\x039\x03:\x03:\x03:\x03:\x03", ":\x03:\x03:\x03:\x03:\x03:\x03:\x03;\x03;\x03;\x03", ";\x03;\x03;\x03;\x03;\x03;\x03<\x03<\x07<\u0271\n<\f", "<\x0E<\u0274\x0B<\x03=\x03=\x05=\u0278\n=\x03>\x03>\x07", ">\u027C\n>\f>\x0E>\u027F\x0B>\x03>\x03>\x03?\x03?\x03", "?\x03?\x03?\x07?\u0288\n?\f?\x0E?\u028B\x0B?\x03?\x03", "?\x03?\x03?\x03@\x03@\x03A\x03A\x03A\x05A\u0296\nA\x03", "B\x03B\x03B\x03B\x03B\x03B\x03C\x03C\x03D\x03D\x03", "E\x03E\x03F\x03F\x06F\u02A6\nF\rF\x0EF\u02A7\x03G\x03", "G\x05G\u02AC\nG\x03G\x06G\u02AF\nG\rG\x0EG\u02B0\x03H\x03", "H\x03I\x03I\x03J\x03J\x03K\x03K\x03K\x03K\x03K\x03", "K\x03K\x03K\x03K\x03K\x05K\u02C3\nK\x03L\x05L\u02C6\n", "L\x03L\x03L\x05L\u02CA\nL\x03L\x03L\x07L\u02CE\nL\fL\x0E", "L\u02D1\x0BL\x05L\u02D3\nL\x03M\x03M\x03M\x03M\x03M\x05", "M\u02DA\nM\x03N\x03N\x05N\u02DE\nN\x03N\x03N\x03O\x06", "O\u02E3\nO\rO\x0EO\u02E4\x03O\x03O\x03P\x03P\x03P\x03", "P\x03Q\x03Q\x07Q\u02EF\nQ\fQ\x0EQ\u02F2\x0BQ\x03Q\x03", "Q\x03R\x03R\x03R\x05R\u02F9\nR\x03R\x03R\x03S\x03S\x03", "S\x03S\x03T\x03T\x03U\x03U\x03U\x03U\x03U\x03U\x03", "\u0289\x02V\x03\x03\x05\x04\x07\x05\t\x06\x0B\x07", "\r\b\x0F\t\x11\n\x13\x0B\x15\f\x17\r\x19\x0E\x1B\x0F", "\x1D\x10\x1F\x11!\x12#\x13%\x14'\x15)\x16+\x17", "-\x18/\x191\x1A3\x1B5\x1C7\x1D9\x1E;\x1F= ?!A\"C#E$", "G%I&K'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s;u<w=y\x02{>}?\x7F", "@\x81\x02\x83\x02\x85\x02\x87\x02\x89\x02\x8B", "\x02\x8D\x02\x8F\x02\x91\x02\x93\x02\x95A\x97", "B\x99C\x9B\x02\x9DD\x9FE\xA1F\xA3G\xA5H\xA7I\xA9", "J\x03\x02\x0F\x05\x02C\\aac|\x06\x022;C\\aac|\x04\x02", "$$^^\n\x02$$11^^ddhhppttvv\x05\x022;CHch\x03\x023;\x03\x02", "2;\x04\x02GGgg\x04\x02--//\x05\x02##&&*+\b\x02<<??BB]", "]__}\x7F\x05\x02\x0B\f\x0F\x0F\"\"\x04\x02\f\f\x0F", "\x0F\x02\u0310\x02\x03\x03\x02\x02\x02\x02\x05\x03", "\x02\x02\x02\x02\x07\x03\x02\x02\x02\x02\t\x03", "\x02\x02\x02\x02\x0B\x03\x02\x02\x02\x02\r\x03", "\x02\x02\x02\x02\x0F\x03\x02\x02\x02\x02\x11\x03", "\x02\x02\x02\x02\x13\x03\x02\x02\x02\x02\x15\x03", "\x02\x02\x02\x02\x17\x03\x02\x02\x02\x02\x19\x03", "\x02\x02\x02\x02\x1B\x03\x02\x02\x02\x02\x1D\x03", "\x02\x02\x02\x02\x1F\x03\x02\x02\x02\x02!\x03", "\x02\x02\x02\x02#\x03\x02\x02\x02\x02%\x03\x02", "\x02\x02\x02'\x03\x02\x02\x02\x02)\x03\x02\x02", "\x02\x02+\x03\x02\x02\x02\x02-\x03\x02\x02\x02", "\x02/\x03\x02\x02\x02\x021\x03\x02\x02\x02\x02", "3\x03\x02\x02\x02\x025\x03\x02\x02\x02\x027\x03", "\x02\x02\x02\x029\x03\x02\x02\x02\x02;\x03\x02", "\x02\x02\x02=\x03\x02\x02\x02\x02?\x03\x02\x02", "\x02\x02A\x03\x02\x02\x02\x02C\x03\x02\x02\x02", "\x02E\x03\x02\x02\x02\x02G\x03\x02\x02\x02\x02", "I\x03\x02\x02\x02\x02K\x03\x02\x02\x02\x02M\x03", "\x02\x02\x02\x02O\x03\x02\x02\x02\x02Q\x03\x02", "\x02\x02\x02S\x03\x02\x02\x02\x02U\x03\x02\x02", "\x02\x02W\x03\x02\x02\x02\x02Y\x03\x02\x02\x02", "\x02[\x03\x02\x02\x02\x02]\x03\x02\x02\x02\x02", "_\x03\x02\x02\x02\x02a\x03\x02\x02\x02\x02c\x03", "\x02\x02\x02\x02e\x03\x02\x02\x02\x02g\x03\x02", "\x02\x02\x02i\x03\x02\x02\x02\x02k\x03\x02\x02", "\x02\x02m\x03\x02\x02\x02\x02o\x03\x02\x02\x02", "\x02q\x03\x02\x02\x02\x02s\x03\x02\x02\x02\x02", "u\x03\x02\x02\x02\x02w\x03\x02\x02\x02\x02{\x03", "\x02\x02\x02\x02}\x03\x02\x02\x02\x02\x7F\x03", "\x02\x02\x02\x02\x95\x03\x02\x02\x02\x02\x97\x03", "\x02\x02\x02\x02\x99\x03\x02\x02\x02\x02\x9D\x03", "\x02\x02\x02\x02\x9F\x03\x02\x02\x02\x02\xA1\x03", "\x02\x02\x02\x02\xA3\x03\x02\x02\x02\x02\xA5\x03", "\x02\x02\x02\x02\xA7\x03\x02\x02\x02\x02\xA9\x03", "\x02\x02\x02\x03\xAB\x03\x02\x02\x02\x05\xB1\x03", "\x02\x02\x02\x07\xBA\x03\x02\x02\x02\t\xC7\x03", "\x02\x02\x02\x0B\xC9\x03\x02\x02\x02\r\xCB\x03", "\x02\x02\x02\x0F\xCD\x03\x02\x02\x02\x11\xCF\x03", "\x02\x02\x02\x13\xD1\x03\x02\x02\x02\x15\xD5\x03", "\x02\x02\x02\x17\xDE\x03\x02\x02\x02\x19\xE1\x03", "\x02\x02\x02\x1B\xE6\x03\x02\x02\x02\x1D\xEC\x03", "\x02\x02\x02\x1F\xF1\x03\x02\x02\x02!\xF3\x03", "\x02\x02\x02#\xF5\x03\x02\x02\x02%\xF7\x03\x02", "\x02\x02'\xF9\x03\x02\x02\x02)\xFB\x03\x02\x02", "\x02+\xFD\x03\x02\x02\x02-\u0104\x03\x02\x02\x02", "/\u010B\x03\x02\x02\x021\u0112\x03\x02\x02\x023\u0117", "\x03\x02\x02\x025\u0122\x03\x02\x02\x027\u0124\x03", "\x02\x02\x029\u012E\x03\x02\x02\x02;\u0134\x03\x02", "\x02\x02=\u0136\x03\x02\x02\x02?\u013B\x03\x02\x02", "\x02A\u0141\x03\x02\x02\x02C\u014B\x03\x02\x02\x02", "E\u0156\x03\x02\x02\x02G\u015C\x03\x02\x02\x02I\u0165", "\x03\x02\x02\x02K\u0172\x03\x02\x02\x02M\u0178\x03", "\x02\x02\x02O\u018C\x03\x02\x02\x02Q\u019C\x03\x02", "\x02\x02S\u01AC\x03\x02\x02\x02U\u01C0\x03\x02\x02", "\x02W\u01C7\x03\x02\x02\x02Y\u01CE\x03\x02\x02\x02", "[\u01D5\x03\x02\x02\x02]\u01E6\x03\x02\x02\x02_\u01FA", "\x03\x02\x02\x02a\u0204\x03\x02\x02\x02c\u020A\x03", "\x02\x02\x02e\u020F\x03\x02\x02\x02g\u021A\x03\x02", "\x02\x02i\u0227\x03\x02\x02\x02k\u023E\x03\x02\x02", "\x02m\u0244\x03\x02\x02\x02o\u0249\x03\x02\x02\x02", "q\u0253\x03\x02\x02\x02s\u025A\x03\x02\x02\x02u\u0265", "\x03\x02\x02\x02w\u026E\x03\x02\x02\x02y\u0277\x03", "\x02\x02\x02{\u0279\x03\x02\x02\x02}\u0282\x03\x02", "\x02\x02\x7F\u0290\x03\x02\x02\x02\x81\u0292\x03\x02", "\x02\x02\x83\u0297\x03\x02\x02\x02\x85\u029D\x03\x02", "\x02\x02\x87\u029F\x03\x02\x02\x02\x89\u02A1\x03\x02", "\x02\x02\x8B\u02A3\x03\x02\x02\x02\x8D\u02A9\x03\x02", "\x02\x02\x8F\u02B2\x03\x02\x02\x02\x91\u02B4\x03\x02", "\x02\x02\x93\u02B6\x03\x02\x02\x02\x95\u02C2\x03\x02", "\x02\x02\x97\u02D2\x03\x02\x02\x02\x99\u02D9\x03\x02", "\x02\x02\x9B\u02DB\x03\x02\x02\x02\x9D\u02E2\x03\x02", "\x02\x02\x9F\u02E8\x03\x02\x02\x02\xA1\u02EC\x03\x02", "\x02\x02\xA3\u02F8\x03\x02\x02\x02\xA5\u02FC\x03\x02", "\x02\x02\xA7\u0300\x03\x02\x02\x02\xA9\u0302\x03\x02", "\x02\x02\xAB\xAC\x07s\x02\x02\xAC\xAD\x07w\x02", "\x02\xAD\xAE\x07g\x02\x02\xAE\xAF\x07t\x02\x02", "\xAF\xB0\x07{\x02\x02\xB0\x04\x03\x02\x02\x02", "\xB1\xB2\x07o\x02\x02\xB2\xB3\x07w\x02\x02\xB3", "\xB4\x07v\x02\x02\xB4\xB5\x07c\x02\x02\xB5\xB6", "\x07v\x02\x02\xB6\xB7\x07k\x02\x02\xB7\xB8\x07", "q\x02\x02\xB8\xB9\x07p\x02\x02\xB9\x06\x03\x02", "\x02\x02\xBA\xBB\x07u\x02\x02\xBB\xBC\x07w\x02", "\x02\xBC\xBD\x07d\x02\x02\xBD\xBE\x07u\x02\x02", "\xBE\xBF\x07e\x02\x02\xBF\xC0\x07t\x02\x02\xC0", "\xC1\x07k\x02\x02\xC1\xC2\x07r\x02\x02\xC2\xC3", "\x07v\x02\x02\xC3\xC4\x07k\x02\x02\xC4\xC5\x07", "q\x02\x02\xC5\xC6\x07p\x02\x02\xC6\b\x03\x02\x02", "\x02\xC7\xC8\x07}\x02\x02\xC8\n\x03\x02\x02\x02", "\xC9\xCA\x07\x7F\x02\x02\xCA\f\x03\x02\x02\x02", "\xCB\xCC\x07*\x02\x02\xCC\x0E\x03\x02\x02\x02", "\xCD\xCE\x07+\x02\x02\xCE\x10\x03\x02\x02\x02", "\xCF\xD0\x07<\x02\x02\xD0\x12\x03\x02\x02\x02", "\xD1\xD2\x070\x02\x02\xD2\xD3\x070\x02\x02\xD3", "\xD4\x070\x02\x02\xD4\x14\x03\x02\x02\x02\xD5", "\xD6\x07h\x02\x02\xD6\xD7\x07t\x02\x02\xD7\xD8", "\x07c\x02\x02\xD8\xD9\x07i\x02\x02\xD9\xDA\x07", "o\x02\x02\xDA\xDB\x07g\x02\x02\xDB\xDC\x07p\x02", "\x02\xDC\xDD\x07v\x02\x02\xDD\x16\x03\x02\x02", "\x02\xDE\xDF\x07q\x02\x02\xDF\xE0\x07p\x02\x02", "\xE0\x18\x03\x02\x02\x02\xE1\xE2\x07v\x02\x02", "\xE2\xE3\x07t\x02\x02\xE3\xE4\x07w\x02\x02\xE4", "\xE5\x07g\x02\x02\xE5\x1A\x03\x02\x02\x02\xE6", "\xE7\x07h\x02\x02\xE7\xE8\x07c\x02\x02\xE8\xE9", "\x07n\x02\x02\xE9\xEA\x07u\x02\x02\xEA\xEB\x07", "g\x02\x02\xEB\x1C\x03\x02\x02\x02\xEC\xED\x07", "p\x02\x02\xED\xEE\x07w\x02\x02\xEE\xEF\x07n\x02", "\x02\xEF\xF0\x07n\x02\x02\xF0\x1E\x03\x02\x02", "\x02\xF1\xF2\x07]\x02\x02\xF2 \x03\x02\x02\x02", "\xF3\xF4\x07_\x02\x02\xF4\"\x03\x02\x02\x02\xF5", "\xF6\x07&\x02\x02\xF6$\x03\x02\x02\x02\xF7\xF8", "\x07?\x02\x02\xF8&\x03\x02\x02\x02\xF9\xFA\x07", "#\x02\x02\xFA(\x03\x02\x02\x02\xFB\xFC\x07B\x02", "\x02\xFC*\x03\x02\x02\x02\xFD\xFE\x07u\x02\x02", "\xFE\xFF\x07e\x02\x02\xFF\u0100\x07j\x02\x02\u0100", "\u0101\x07g\x02\x02\u0101\u0102\x07o\x02\x02\u0102\u0103", "\x07c\x02\x02\u0103,\x03\x02\x02\x02\u0104\u0105\x07", "g\x02\x02\u0105\u0106\x07z\x02\x02\u0106\u0107\x07v\x02", "\x02\u0107\u0108\x07g\x02\x02\u0108\u0109\x07p\x02\x02", "\u0109\u010A\x07f\x02\x02\u010A.\x03\x02\x02\x02\u010B", "\u010C\x07u\x02\x02\u010C\u010D\x07e\x02\x02\u010D\u010E", "\x07c\x02\x02\u010E\u010F\x07n\x02\x02\u010F\u0110\x07", "c\x02\x02\u0110\u0111\x07t\x02\x02\u01110\x03\x02\x02", "\x02\u0112\u0113\x07v\x02\x02\u0113\u0114\x07{\x02\x02", "\u0114\u0115\x07r\x02\x02\u0115\u0116\x07g\x02\x02\u0116", "2\x03\x02\x02\x02\u0117\u0118\x07k\x02\x02\u0118\u0119", "\x07o\x02\x02\u0119\u011A\x07r\x02\x02\u011A\u011B\x07", "n\x02\x02\u011B\u011C\x07g\x02\x02\u011C\u011D\x07o\x02", "\x02\u011D\u011E\x07g\x02\x02\u011E\u011F\x07p\x02\x02", "\u011F\u0120\x07v\x02\x02\u0120\u0121\x07u\x02\x02\u0121", "4\x03\x02\x02\x02\u0122\u0123\x07(\x02\x02\u01236\x03", "\x02\x02\x02\u0124\u0125\x07k\x02\x02\u0125\u0126\x07", "p\x02\x02\u0126\u0127\x07v\x02\x02\u0127\u0128\x07g\x02", "\x02\u0128\u0129\x07t\x02\x02\u0129\u012A\x07h\x02\x02", "\u012A\u012B\x07c\x02\x02\u012B\u012C\x07e\x02\x02\u012C", "\u012D\x07g\x02\x02\u012D8\x03\x02\x02\x02\u012E\u012F", "\x07w\x02\x02\u012F\u0130\x07p\x02\x02\u0130\u0131\x07", "k\x02\x02\u0131\u0132\x07q\x02\x02\u0132\u0133\x07p\x02", "\x02\u0133:\x03\x02\x02\x02\u0134\u0135\x07~\x02\x02", "\u0135<\x03\x02\x02\x02\u0136\u0137\x07g\x02\x02\u0137", "\u0138\x07p\x02\x02\u0138\u0139\x07w\x02\x02\u0139\u013A", "\x07o\x02\x02\u013A>\x03\x02\x02\x02\u013B\u013C\x07", "k\x02\x02\u013C\u013D\x07p\x02\x02\u013D\u013E\x07r\x02", "\x02\u013E\u013F\x07w\x02\x02\u013F\u0140\x07v\x02\x02", "\u0140@\x03\x02\x02\x02\u0141\u0142\x07f\x02\x02\u0142", "\u0143\x07k\x02\x02\u0143\u0144\x07t\x02\x02\u0144\u0145", "\x07g\x02\x02\u0145\u0146\x07e\x02\x02\u0146\u0147\x07", "v\x02\x02\u0147\u0148\x07k\x02\x02\u0148\u0149\x07x\x02", "\x02\u0149\u014A\x07g\x02\x02\u014AB\x03\x02\x02\x02", "\u014B\u014C\x07t\x02\x02\u014C\u014D\x07g\x02\x02\u014D", "\u014E\x07r\x02\x02\u014E\u014F\x07g\x02\x02\u014F\u0150", "\x07c\x02\x02\u0150\u0151\x07v\x02\x02\u0151\u0152\x07", "c\x02\x02\u0152\u0153\x07d\x02\x02\u0153\u0154\x07n\x02", "\x02\u0154\u0155\x07g\x02\x02\u0155D\x03\x02\x02\x02", "\u0156\u0157\x07S\x02\x02\u0157\u0158\x07W\x02\x02\u0158", "\u0159\x07G\x02\x02\u0159\u015A\x07T\x02\x02\u015A\u015B", "\x07[\x02\x02\u015BF\x03\x02\x02\x02\u015C\u015D\x07", "O\x02\x02\u015D\u015E\x07W\x02\x02\u015E\u015F\x07V\x02", "\x02\u015F\u0160\x07C\x02\x02\u0160\u0161\x07V\x02\x02", "\u0161\u0162\x07K\x02\x02\u0162\u0163\x07Q\x02\x02\u0163", "\u0164\x07P\x02\x02\u0164H\x03\x02\x02\x02\u0165\u0166", "\x07U\x02\x02\u0166\u0167\x07W\x02\x02\u0167\u0168\x07", "D\x02\x02\u0168\u0169\x07U\x02\x02\u0169\u016A\x07E\x02", "\x02\u016A\u016B\x07T\x02\x02\u016B\u016C\x07K\x02\x02", "\u016C\u016D\x07R\x02\x02\u016D\u016E\x07V\x02\x02\u016E", "\u016F\x07K\x02\x02\u016F\u0170\x07Q\x02\x02\u0170\u0171", "\x07P\x02\x02\u0171J\x03\x02\x02\x02\u0172\u0173\x07", "H\x02\x02\u0173\u0174\x07K\x02\x02\u0174\u0175\x07G\x02", "\x02\u0175\u0176\x07N\x02\x02\u0176\u0177\x07F\x02\x02", "\u0177L\x03\x02\x02\x02\u0178\u0179\x07H\x02\x02\u0179", "\u017A\x07T\x02\x02\u017A\u017B\x07C\x02\x02\u017B\u017C", "\x07I\x02\x02\u017C\u017D\x07O\x02\x02\u017D\u017E\x07", "G\x02\x02\u017E\u017F\x07P\x02\x02\u017F\u0180\x07V\x02", "\x02\u0180\u0181\x07a\x02\x02\u0181\u0182\x07F\x02\x02", "\u0182\u0183\x07G\x02\x02\u0183\u0184\x07H\x02\x02\u0184", "\u0185\x07K\x02\x02\u0185\u0186\x07P\x02\x02\u0186\u0187", "\x07K\x02\x02\u0187\u0188\x07V\x02\x02\u0188\u0189\x07", "K\x02\x02\u0189\u018A\x07Q\x02\x02\u018A\u018B\x07P\x02", "\x02\u018BN\x03\x02\x02\x02\u018C\u018D\x07H\x02\x02", "\u018D\u018E\x07T\x02\x02\u018E\u018F\x07C\x02\x02\u018F", "\u0190\x07I\x02\x02\u0190\u0191\x07O\x02\x02\u0191\u0192", "\x07G\x02\x02\u0192\u0193\x07P\x02\x02\u0193\u0194\x07", "V\x02\x02\u0194\u0195\x07a\x02\x02\u0195\u0196\x07U\x02", "\x02\u0196\u0197\x07R\x02\x02\u0197\u0198\x07T\x02\x02", "\u0198\u0199\x07G\x02\x02\u0199\u019A\x07C\x02\x02\u019A", "\u019B\x07F\x02\x02\u019BP\x03\x02\x02\x02\u019C\u019D", "\x07K\x02\x02\u019D\u019E\x07P\x02\x02\u019E\u019F\x07", "N\x02\x02\u019F\u01A0\x07K\x02\x02\u01A0\u01A1\x07P\x02", "\x02\u01A1\u01A2\x07G\x02\x02\u01A2\u01A3\x07a\x02\x02", "\u01A3\u01A4\x07H\x02\x02\u01A4\u01A5\x07T\x02\x02\u01A5", "\u01A6\x07C\x02\x02\u01A6\u01A7\x07I\x02\x02\u01A7\u01A8", "\x07O\x02\x02\u01A8\u01A9\x07G\x02\x02\u01A9\u01AA\x07", "P\x02\x02\u01AA\u01AB\x07V\x02\x02\u01ABR\x03\x02\x02", "\x02\u01AC\u01AD\x07X\x02\x02\u01AD\u01AE\x07C\x02\x02", "\u01AE\u01AF\x07T\x02\x02\u01AF\u01B0\x07K\x02\x02\u01B0", "\u01B1\x07C\x02\x02\u01B1\u01B2\x07D\x02\x02\u01B2\u01B3", "\x07N\x02\x02\u01B3\u01B4\x07G\x02\x02\u01B4\u01B5\x07", "a\x02\x02\u01B5\u01B6\x07F\x02\x02\u01B6\u01B7\x07G\x02", "\x02\u01B7\u01B8\x07H\x02\x02\u01B8\u01B9\x07K\x02\x02", "\u01B9\u01BA\x07P\x02\x02\u01BA\u01BB\x07K\x02\x02\u01BB", "\u01BC\x07V\x02\x02\u01BC\u01BD\x07K\x02\x02\u01BD\u01BE", "\x07Q\x02\x02\u01BE\u01BF\x07P\x02\x02\u01BFT\x03\x02", "\x02\x02\u01C0\u01C1\x07U\x02\x02\u01C1\u01C2\x07E\x02", "\x02\u01C2\u01C3\x07J\x02\x02\u01C3\u01C4\x07G\x02\x02", "\u01C4\u01C5\x07O\x02\x02\u01C5\u01C6\x07C\x02\x02\u01C6", "V\x03\x02\x02\x02\u01C7\u01C8\x07U\x02\x02\u01C8\u01C9", "\x07E\x02\x02\u01C9\u01CA\x07C\x02\x02\u01CA\u01CB\x07", "N\x02\x02\u01CB\u01CC\x07C\x02\x02\u01CC\u01CD\x07T\x02", "\x02\u01CDX\x03\x02\x02\x02\u01CE\u01CF\x07Q\x02\x02", "\u01CF\u01D0\x07D\x02\x02\u01D0\u01D1\x07L\x02\x02\u01D1", "\u01D2\x07G\x02\x02\u01D2\u01D3\x07E\x02\x02\u01D3\u01D4", "\x07V\x02\x02\u01D4Z\x03\x02\x02\x02\u01D5\u01D6\x07", "H\x02\x02\u01D6\u01D7\x07K\x02\x02\u01D7\u01D8\x07G\x02", "\x02\u01D8\u01D9\x07N\x02\x02\u01D9\u01DA\x07F\x02\x02", "\u01DA\u01DB\x07a\x02\x02\u01DB\u01DC\x07F\x02\x02\u01DC", "\u01DD\x07G\x02\x02\u01DD\u01DE\x07H\x02\x02\u01DE\u01DF", "\x07K\x02\x02\u01DF\u01E0\x07P\x02\x02\u01E0\u01E1\x07", "K\x02\x02\u01E1\u01E2\x07V\x02\x02\u01E2\u01E3\x07K\x02", "\x02\u01E3\u01E4\x07Q\x02\x02\u01E4\u01E5\x07P\x02\x02", "\u01E5\\\x03\x02\x02\x02\u01E6\u01E7\x07C\x02\x02\u01E7", "\u01E8\x07T\x02\x02\u01E8\u01E9\x07I\x02\x02\u01E9\u01EA", "\x07W\x02\x02\u01EA\u01EB\x07O\x02\x02\u01EB\u01EC\x07", "G\x02\x02\u01EC\u01ED\x07P\x02\x02\u01ED\u01EE\x07V\x02", "\x02\u01EE\u01EF\x07a\x02\x02\u01EF\u01F0\x07F\x02\x02", "\u01F0\u01F1\x07G\x02\x02\u01F1\u01F2\x07H\x02\x02\u01F2", "\u01F3\x07K\x02\x02\u01F3\u01F4\x07P\x02\x02\u01F4\u01F5", "\x07K\x02\x02\u01F5\u01F6\x07V\x02\x02\u01F6\u01F7\x07", "K\x02\x02\u01F7\u01F8\x07Q\x02\x02\u01F8\u01F9\x07P\x02", "\x02\u01F9^\x03\x02\x02\x02\u01FA\u01FB\x07K\x02\x02", "\u01FB\u01FC\x07P\x02\x02\u01FC\u01FD\x07V\x02\x02\u01FD", "\u01FE\x07G\x02\x02\u01FE\u01FF\x07T\x02\x02\u01FF\u0200", "\x07H\x02\x02\u0200\u0201\x07C\x02\x02\u0201\u0202\x07", "E\x02\x02\u0202\u0203\x07G\x02\x02\u0203`\x03\x02\x02", "\x02\u0204\u0205\x07W\x02\x02\u0205\u0206\x07P\x02\x02", "\u0206\u0207\x07K\x02\x02\u0207\u0208\x07Q\x02\x02\u0208", "\u0209\x07P\x02\x02\u0209b\x03\x02\x02\x02\u020A\u020B", "\x07G\x02\x02\u020B\u020C\x07P\x02\x02\u020C\u020D\x07", "W\x02\x02\u020D\u020E\x07O\x02\x02\u020Ed\x03\x02\x02", "\x02\u020F\u0210\x07G\x02\x02\u0210\u0211\x07P\x02\x02", "\u0211\u0212\x07W\x02\x02\u0212\u0213\x07O\x02\x02\u0213", "\u0214\x07a\x02\x02\u0214\u0215\x07X\x02\x02\u0215\u0216", "\x07C\x02\x02\u0216\u0217\x07N\x02\x02\u0217\u0218\x07", "W\x02\x02\u0218\u0219\x07G\x02\x02\u0219f\x03\x02\x02", "\x02\u021A\u021B\x07K\x02\x02\u021B\u021C\x07P\x02\x02", "\u021C\u021D\x07R\x02\x02\u021D\u021E\x07W\x02\x02\u021E", "\u021F\x07V\x02\x02\u021F\u0220\x07a\x02\x02\u0220\u0221", "\x07Q\x02\x02\u0221\u0222\x07D\x02\x02\u0222\u0223\x07", "L\x02\x02\u0223\u0224\x07G\x02\x02\u0224\u0225\x07E\x02", "\x02\u0225\u0226\x07V\x02\x02\u0226h\x03\x02\x02\x02", "\u0227\u0228\x07K\x02\x02\u0228\u0229\x07P\x02\x02\u0229", "\u022A\x07R\x02\x02\u022A\u022B\x07W\x02\x02\u022B\u022C", "\x07V\x02\x02\u022C\u022D\x07a\x02\x02\u022D\u022E\x07", "H\x02\x02\u022E\u022F\x07K\x02\x02\u022F\u0230\x07G\x02", "\x02\u0230\u0231\x07N\x02\x02\u0231\u0232\x07F\x02\x02", "\u0232\u0233\x07a\x02\x02\u0233\u0234\x07F\x02\x02\u0234", "\u0235\x07G\x02\x02\u0235\u0236\x07H\x02\x02\u0236\u0237", "\x07K\x02\x02\u0237\u0238\x07P\x02\x02\u0238\u0239\x07", "K\x02\x02\u0239\u023A\x07V\x02\x02\u023A\u023B\x07K\x02", "\x02\u023B\u023C\x07Q\x02\x02\u023C\u023D\x07P\x02\x02", "\u023Dj\x03\x02\x02\x02\u023E\u023F\x07K\x02\x02\u023F", "\u0240\x07P\x02\x02\u0240\u0241\x07R\x02\x02\u0241\u0242", "\x07W\x02\x02\u0242\u0243\x07V\x02\x02\u0243l\x03\x02", "\x02\x02\u0244\u0245\x07V\x02\x02\u0245\u0246\x07[\x02", "\x02\u0246\u0247\x07R\x02\x02\u0247\u0248\x07G\x02\x02", "\u0248n\x03\x02\x02\x02\u0249\u024A\x07F\x02\x02\u024A", "\u024B\x07K\x02\x02\u024B\u024C\x07T\x02\x02\u024C\u024D", "\x07G\x02\x02\u024D\u024E\x07E\x02\x02\u024E\u024F\x07", "V\x02\x02\u024F\u0250\x07K\x02\x02\u0250\u0251\x07X\x02", "\x02\u0251\u0252\x07G\x02\x02\u0252p\x03\x02\x02\x02", "\u0253\u0254\x07G\x02\x02\u0254\u0255\x07Z\x02\x02\u0255", "\u0256\x07V\x02\x02\u0256\u0257\x07G\x02\x02\u0257\u0258", "\x07P\x02\x02\u0258\u0259\x07F\x02\x02\u0259r\x03\x02", "\x02\x02\u025A\u025B\x07K\x02\x02\u025B\u025C\x07O\x02", "\x02\u025C\u025D\x07R\x02\x02\u025D\u025E\x07N\x02\x02", "\u025E\u025F\x07G\x02\x02\u025F\u0260\x07O\x02\x02\u0260", "\u0261\x07G\x02\x02\u0261\u0262\x07P\x02\x02\u0262\u0263", "\x07V\x02\x02\u0263\u0264\x07U\x02\x02\u0264t\x03\x02", "\x02\x02\u0265\u0266\x07H\x02\x02\u0266\u0267\x07T\x02", "\x02\u0267\u0268\x07C\x02\x02\u0268\u0269\x07I\x02\x02", "\u0269\u026A\x07O\x02\x02\u026A\u026B\x07G\x02\x02\u026B", "\u026C\x07P\x02\x02\u026C\u026D\x07V\x02\x02\u026Dv\x03", "\x02\x02\x02\u026E\u0272\t\x02\x02\x02\u026F\u0271\t\x03", "\x02\x02\u0270\u026F\x03\x02\x02\x02\u0271\u0274\x03\x02", "\x02\x02\u0272\u0270\x03\x02\x02\x02\u0272\u0273\x03\x02", "\x02\x02\u0273x\x03\x02\x02\x02\u0274\u0272\x03\x02", "\x02\x02\u0275\u0278\x05\x81A\x02\u0276\u0278\n\x04\x02", "\x02\u0277\u0275\x03\x02\x02\x02\u0277\u0276\x03\x02\x02", "\x02\u0278z\x03\x02\x02\x02\u0279\u027D\x07$\x02\x02", "\u027A\u027C\x05y=\x02\u027B\u027A\x03\x02\x02\x02\u027C", "\u027F\x03\x02\x02\x02\u027D\u027B\x03\x02\x02\x02\u027D", "\u027E\x03\x02\x02\x02\u027E\u0280\x03\x02\x02\x02\u027F", "\u027D\x03\x02\x02\x02\u0280\u0281\x07$\x02\x02\u0281", "|\x03\x02\x02\x02\u0282\u0283\x07$\x02\x02\u0283\u0284", "\x07$\x02\x02\u0284\u0285\x07$\x02\x02\u0285\u0289\x03", "\x02\x02\x02\u0286\u0288\x0B\x02\x02\x02\u0287\u0286\x03", "\x02\x02\x02\u0288\u028B\x03\x02\x02\x02\u0289\u028A\x03", "\x02\x02\x02\u0289\u0287\x03\x02\x02\x02\u028A\u028C\x03", "\x02\x02\x02\u028B\u0289\x03\x02\x02\x02\u028C\u028D\x07", "$\x02\x02\u028D\u028E\x07$\x02\x02\u028E\u028F\x07$\x02", "\x02\u028F~\x03\x02\x02\x02\u0290\u0291\x05{>\x02\u0291", "\x80\x03\x02\x02\x02\u0292\u0295\x07^\x02\x02\u0293", "\u0296\t\x05\x02\x02\u0294\u0296\x05\x83B\x02\u0295\u0293", "\x03\x02\x02\x02\u0295\u0294\x03\x02\x02\x02\u0296\x82", "\x03\x02\x02\x02\u0297\u0298\x07w\x02\x02\u0298\u0299", "\x05\x85C\x02\u0299\u029A\x05\x85C\x02\u029A\u029B\x05", "\x85C\x02\u029B\u029C\x05\x85C\x02\u029C\x84\x03\x02", "\x02\x02\u029D\u029E\t\x06\x02\x02\u029E\x86\x03\x02", "\x02\x02\u029F\u02A0\t\x07\x02\x02\u02A0\x88\x03\x02", "\x02\x02\u02A1\u02A2\t\b\x02\x02\u02A2\x8A\x03\x02\x02", "\x02\u02A3\u02A5\x070\x02\x02\u02A4\u02A6\x05\x89E\x02", "\u02A5\u02A4\x03\x02\x02\x02\u02A6\u02A7\x03\x02\x02\x02", "\u02A7\u02A5\x03\x02\x02\x02\u02A7\u02A8\x03\x02\x02\x02", "\u02A8\x8C\x03\x02\x02\x02\u02A9\u02AB\x05\x8FH\x02", "\u02AA\u02AC\x05\x91I\x02\u02AB\u02AA\x03\x02\x02\x02", "\u02AB\u02AC\x03\x02\x02\x02\u02AC\u02AE\x03\x02\x02\x02", "\u02AD\u02AF\x05\x89E\x02\u02AE\u02AD\x03\x02\x02\x02", "\u02AF\u02B0\x03\x02\x02\x02\u02B0\u02AE\x03\x02\x02\x02", "\u02B0\u02B1\x03\x02\x02\x02\u02B1\x8E\x03\x02\x02\x02", "\u02B2\u02B3\t\t\x02\x02\u02B3\x90\x03\x02\x02\x02\u02B4", "\u02B5\t\n\x02\x02\u02B5\x92\x03\x02\x02\x02\u02B6\u02B7", "\x07/\x02\x02\u02B7\x94\x03\x02\x02\x02\u02B8\u02B9", "\x05\x97L\x02\u02B9\u02BA\x05\x8BF\x02\u02BA\u02C3\x03", "\x02\x02\x02\u02BB\u02BC\x05\x97L\x02\u02BC\u02BD\x05", "\x8DG\x02\u02BD\u02C3\x03\x02\x02\x02\u02BE\u02BF\x05", "\x97L\x02\u02BF\u02C0\x05\x8BF\x02\u02C0\u02C1\x05\x8D", "G\x02\u02C1\u02C3\x03\x02\x02\x02\u02C2\u02B8\x03\x02", "\x02\x02\u02C2\u02BB\x03\x02\x02\x02\u02C2\u02BE\x03\x02", "\x02\x02\u02C3\x96\x03\x02\x02\x02\u02C4\u02C6\x05\x93", "J\x02\u02C5\u02C4\x03\x02\x02\x02\u02C5\u02C6\x03\x02", "\x02\x02\u02C6\u02C7\x03\x02\x02\x02\u02C7\u02D3\x072", "\x02\x02\u02C8\u02CA\x05\x93J\x02\u02C9\u02C8\x03\x02", "\x02\x02\u02C9\u02CA\x03\x02\x02\x02\u02CA\u02CB\x03\x02", "\x02\x02\u02CB\u02CF\x05\x87D\x02\u02CC\u02CE\x05\x89", "E\x02\u02CD\u02CC\x03\x02\x02\x02\u02CE\u02D1\x03\x02", "\x02\x02\u02CF\u02CD\x03\x02\x02\x02\u02CF\u02D0\x03\x02", "\x02\x02\u02D0\u02D3\x03\x02\x02\x02\u02D1\u02CF\x03\x02", "\x02\x02\u02D2\u02C5\x03\x02\x02\x02\u02D2\u02C9\x03\x02", "\x02\x02\u02D3\x98\x03\x02\x02\x02\u02D4\u02DA\t\x0B", "\x02\x02\u02D5\u02D6\x070\x02\x02\u02D6\u02D7\x070\x02", "\x02\u02D7\u02DA\x070\x02\x02\u02D8\u02DA\t\f\x02\x02\u02D9", "\u02D4\x03\x02\x02\x02\u02D9\u02D5\x03\x02\x02\x02\u02D9", "\u02D8\x03\x02\x02\x02\u02DA\x9A\x03\x02\x02\x02\u02DB", "\u02DD\t\t\x02\x02\u02DC\u02DE\t\n\x02\x02\u02DD\u02DC\x03", "\x02\x02\x02\u02DD\u02DE\x03\x02\x02\x02\u02DE\u02DF\x03", "\x02\x02\x02\u02DF\u02E0\x05\x97L\x02\u02E0\x9C\x03", "\x02\x02\x02\u02E1\u02E3\t\r\x02\x02\u02E2\u02E1\x03\x02", "\x02\x02\u02E3\u02E4\x03\x02\x02\x02\u02E4\u02E2\x03\x02", "\x02\x02\u02E4\u02E5\x03\x02\x02\x02\u02E5\u02E6\x03\x02", "\x02\x02\u02E6\u02E7\bO\x02\x02\u02E7\x9E\x03\x02\x02", "\x02\u02E8\u02E9\x07.\x02\x02\u02E9\u02EA\x03\x02\x02", "\x02\u02EA\u02EB\bP\x02\x02\u02EB\xA0\x03\x02\x02\x02", "\u02EC\u02F0\x07%\x02\x02\u02ED\u02EF\n\x0E\x02\x02\u02EE", "\u02ED\x03\x02\x02\x02\u02EF\u02F2\x03\x02\x02\x02\u02F0", "\u02EE\x03\x02\x02\x02\u02F0\u02F1\x03\x02\x02\x02\u02F1", "\u02F3\x03\x02\x02\x02\u02F2\u02F0\x03\x02\x02\x02\u02F3", "\u02F4\bQ\x02\x02\u02F4\xA2\x03\x02\x02\x02\u02F5\u02F9", "\x05\xA5S\x02\u02F6\u02F9\x05\xA7T\x02\u02F7\u02F9\x05", "\xA9U\x02\u02F8\u02F5\x03\x02\x02\x02\u02F8\u02F6\x03", "\x02\x02\x02\u02F8\u02F7\x03\x02\x02\x02\u02F9\u02FA\x03", "\x02\x02\x02\u02FA\u02FB\bR\x02\x02\u02FB\xA4\x03\x02", "\x02\x02\u02FC\u02FD\x07\uEFBD\x02\x02\u02FD\u02FE\x07D", "\x02\x02\u02FE\u02FF\x07H\x02\x02\u02FF\xA6\x03\x02", "\x02\x02\u0300\u0301\x07\uFF01\x02\x02\u0301\xA8\x03\x02", "\x02\x02\u0302\u0303\x07\x02\x02\x02\u0303\u0304\x07H", "\x02\x02\u0304\u0305\x07G\x02\x02\u0305\u0306\x07H\x02", "\x02\u0306\u0307\x07H\x02\x02\u0307\xAA\x03\x02\x02", "\x02\x15\x02\u0272\u0277\u027D\u0289\u0295\u02A7\u02AB\u02B0\u02C2", "\u02C5\u02C9\u02CF\u02D2\u02D9\u02DD\u02E4\u02F0\u02F8\x03\b\x02", "\x02"].join("");
	var atn = new _antlr["default"].atn.ATNDeserializer().deserialize(serializedATN);
	var decisionsToDFA = atn.decisionToState.map(function (ds, index) {
	  return new _antlr["default"].dfa.DFA(ds, index);
	});

	var GraphQLLexer = /*#__PURE__*/function (_antlr4$Lexer) {
	  _inherits(GraphQLLexer, _antlr4$Lexer);

	  var _super = _createSuper(GraphQLLexer);

	  function GraphQLLexer(input) {
	    var _this;

	    _classCallCheck(this, GraphQLLexer);

	    _this = _super.call(this, input);
	    _this._interp = new _antlr["default"].atn.LexerATNSimulator(_assertThisInitialized(_this), atn, decisionsToDFA, new _antlr["default"].PredictionContextCache());
	    return _this;
	  }

	  _createClass(GraphQLLexer, [{
	    key: "atn",
	    get: function get() {
	      return atn;
	    }
	  }]);

	  return GraphQLLexer;
	}(_antlr["default"].Lexer);

	exports["default"] = GraphQLLexer;

	_defineProperty(GraphQLLexer, "grammarFileName", "GraphQL.g4");

	_defineProperty(GraphQLLexer, "channelNames", ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"]);

	_defineProperty(GraphQLLexer, "modeNames", ["DEFAULT_MODE"]);

	_defineProperty(GraphQLLexer, "literalNames", [null, "'query'", "'mutation'", "'subscription'", "'{'", "'}'", "'('", "')'", "':'", "'...'", "'fragment'", "'on'", "'true'", "'false'", "'null'", "'['", "']'", "'$'", "'='", "'!'", "'@'", "'schema'", "'extend'", "'scalar'", "'type'", "'implements'", "'&'", "'interface'", "'union'", "'|'", "'enum'", "'input'", "'directive'", "'repeatable'", "'QUERY'", "'MUTATION'", "'SUBSCRIPTION'", "'FIELD'", "'FRAGMENT_DEFINITION'", "'FRAGMENT_SPREAD'", "'INLINE_FRAGMENT'", "'VARIABLE_DEFINITION'", "'SCHEMA'", "'SCALAR'", "'OBJECT'", "'FIELD_DEFINITION'", "'ARGUMENT_DEFINITION'", "'INTERFACE'", "'UNION'", "'ENUM'", "'ENUM_VALUE'", "'INPUT_OBJECT'", "'INPUT_FIELD_DEFINITION'", "'INPUT'", "'TYPE'", "'DIRECTIVE'", "'EXTEND'", "'IMPLEMENTS'", "'FRAGMENT'", null, null, null, null, null, null, null, null, "','", null, null, "'\uEFBBBF'", "'\uFEFF'", "'\0FEFF'"]);

	_defineProperty(GraphQLLexer, "symbolicNames", [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "NAME", "STRING", "BLOCK_STRING", "ID", "FLOAT", "INT", "PUNCTUATOR", "WS", "COMMA", "LineComment", "UNICODE_BOM", "UTF8_BOM", "UTF16_BOM", "UTF32_BOM"]);

	_defineProperty(GraphQLLexer, "ruleNames", ["T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", "T__7", "T__8", "T__9", "T__10", "T__11", "T__12", "T__13", "T__14", "T__15", "T__16", "T__17", "T__18", "T__19", "T__20", "T__21", "T__22", "T__23", "T__24", "T__25", "T__26", "T__27", "T__28", "T__29", "T__30", "T__31", "T__32", "T__33", "T__34", "T__35", "T__36", "T__37", "T__38", "T__39", "T__40", "T__41", "T__42", "T__43", "T__44", "T__45", "T__46", "T__47", "T__48", "T__49", "T__50", "T__51", "T__52", "T__53", "T__54", "T__55", "T__56", "T__57", "NAME", "CHARACTER", "STRING", "BLOCK_STRING", "ID", "ESC", "UNICODE", "HEX", "NONZERO_DIGIT", "DIGIT", "FRACTIONAL_PART", "EXPONENTIAL_PART", "EXPONENT_INDICATOR", "SIGN", "NEGATIVE_SIGN", "FLOAT", "INT", "PUNCTUATOR", "EXP", "WS", "COMMA", "LineComment", "UNICODE_BOM", "UTF8_BOM", "UTF16_BOM", "UTF32_BOM"]);

	GraphQLLexer.EOF = _antlr["default"].Token.EOF;
	GraphQLLexer.T__0 = 1;
	GraphQLLexer.T__1 = 2;
	GraphQLLexer.T__2 = 3;
	GraphQLLexer.T__3 = 4;
	GraphQLLexer.T__4 = 5;
	GraphQLLexer.T__5 = 6;
	GraphQLLexer.T__6 = 7;
	GraphQLLexer.T__7 = 8;
	GraphQLLexer.T__8 = 9;
	GraphQLLexer.T__9 = 10;
	GraphQLLexer.T__10 = 11;
	GraphQLLexer.T__11 = 12;
	GraphQLLexer.T__12 = 13;
	GraphQLLexer.T__13 = 14;
	GraphQLLexer.T__14 = 15;
	GraphQLLexer.T__15 = 16;
	GraphQLLexer.T__16 = 17;
	GraphQLLexer.T__17 = 18;
	GraphQLLexer.T__18 = 19;
	GraphQLLexer.T__19 = 20;
	GraphQLLexer.T__20 = 21;
	GraphQLLexer.T__21 = 22;
	GraphQLLexer.T__22 = 23;
	GraphQLLexer.T__23 = 24;
	GraphQLLexer.T__24 = 25;
	GraphQLLexer.T__25 = 26;
	GraphQLLexer.T__26 = 27;
	GraphQLLexer.T__27 = 28;
	GraphQLLexer.T__28 = 29;
	GraphQLLexer.T__29 = 30;
	GraphQLLexer.T__30 = 31;
	GraphQLLexer.T__31 = 32;
	GraphQLLexer.T__32 = 33;
	GraphQLLexer.T__33 = 34;
	GraphQLLexer.T__34 = 35;
	GraphQLLexer.T__35 = 36;
	GraphQLLexer.T__36 = 37;
	GraphQLLexer.T__37 = 38;
	GraphQLLexer.T__38 = 39;
	GraphQLLexer.T__39 = 40;
	GraphQLLexer.T__40 = 41;
	GraphQLLexer.T__41 = 42;
	GraphQLLexer.T__42 = 43;
	GraphQLLexer.T__43 = 44;
	GraphQLLexer.T__44 = 45;
	GraphQLLexer.T__45 = 46;
	GraphQLLexer.T__46 = 47;
	GraphQLLexer.T__47 = 48;
	GraphQLLexer.T__48 = 49;
	GraphQLLexer.T__49 = 50;
	GraphQLLexer.T__50 = 51;
	GraphQLLexer.T__51 = 52;
	GraphQLLexer.T__52 = 53;
	GraphQLLexer.T__53 = 54;
	GraphQLLexer.T__54 = 55;
	GraphQLLexer.T__55 = 56;
	GraphQLLexer.T__56 = 57;
	GraphQLLexer.T__57 = 58;
	GraphQLLexer.NAME = 59;
	GraphQLLexer.STRING = 60;
	GraphQLLexer.BLOCK_STRING = 61;
	GraphQLLexer.ID = 62;
	GraphQLLexer.FLOAT = 63;
	GraphQLLexer.INT = 64;
	GraphQLLexer.PUNCTUATOR = 65;
	GraphQLLexer.WS = 66;
	GraphQLLexer.COMMA = 67;
	GraphQLLexer.LineComment = 68;
	GraphQLLexer.UNICODE_BOM = 69;
	GraphQLLexer.UTF8_BOM = 70;
	GraphQLLexer.UTF16_BOM = 71;
	GraphQLLexer.UTF32_BOM = 72;
} (GraphQLLexer));

var GraphqlLexer = /*@__PURE__*/getDefaultExportFromCjs(GraphQLLexer);

var GraphQLParser = {};

var GraphQLListener = {};

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// This class defines a complete listener for a parse tree produced by GraphQLParser.
	var GraphQLListener = /*#__PURE__*/function (_antlr4$tree$ParseTre) {
	  _inherits(GraphQLListener, _antlr4$tree$ParseTre);

	  var _super = _createSuper(GraphQLListener);

	  function GraphQLListener() {
	    _classCallCheck(this, GraphQLListener);

	    return _super.apply(this, arguments);
	  }

	  _createClass(GraphQLListener, [{
	    key: "enterDocument",
	    value: // Enter a parse tree produced by GraphQLParser#document.
	    function enterDocument(ctx) {} // Exit a parse tree produced by GraphQLParser#document.

	  }, {
	    key: "exitDocument",
	    value: function exitDocument(ctx) {} // Enter a parse tree produced by GraphQLParser#definition.

	  }, {
	    key: "enterDefinition",
	    value: function enterDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#definition.

	  }, {
	    key: "exitDefinition",
	    value: function exitDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#executableDefinition.

	  }, {
	    key: "enterExecutableDefinition",
	    value: function enterExecutableDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#executableDefinition.

	  }, {
	    key: "exitExecutableDefinition",
	    value: function exitExecutableDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#operationDefinition.

	  }, {
	    key: "enterOperationDefinition",
	    value: function enterOperationDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#operationDefinition.

	  }, {
	    key: "exitOperationDefinition",
	    value: function exitOperationDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#operationType.

	  }, {
	    key: "enterOperationType",
	    value: function enterOperationType(ctx) {} // Exit a parse tree produced by GraphQLParser#operationType.

	  }, {
	    key: "exitOperationType",
	    value: function exitOperationType(ctx) {} // Enter a parse tree produced by GraphQLParser#selectionSet.

	  }, {
	    key: "enterSelectionSet",
	    value: function enterSelectionSet(ctx) {} // Exit a parse tree produced by GraphQLParser#selectionSet.

	  }, {
	    key: "exitSelectionSet",
	    value: function exitSelectionSet(ctx) {} // Enter a parse tree produced by GraphQLParser#selection.

	  }, {
	    key: "enterSelection",
	    value: function enterSelection(ctx) {} // Exit a parse tree produced by GraphQLParser#selection.

	  }, {
	    key: "exitSelection",
	    value: function exitSelection(ctx) {} // Enter a parse tree produced by GraphQLParser#field.

	  }, {
	    key: "enterField",
	    value: function enterField(ctx) {} // Exit a parse tree produced by GraphQLParser#field.

	  }, {
	    key: "exitField",
	    value: function exitField(ctx) {} // Enter a parse tree produced by GraphQLParser#arguments.

	  }, {
	    key: "enterArguments",
	    value: function enterArguments(ctx) {} // Exit a parse tree produced by GraphQLParser#arguments.

	  }, {
	    key: "exitArguments",
	    value: function exitArguments(ctx) {} // Enter a parse tree produced by GraphQLParser#argument.

	  }, {
	    key: "enterArgument",
	    value: function enterArgument(ctx) {} // Exit a parse tree produced by GraphQLParser#argument.

	  }, {
	    key: "exitArgument",
	    value: function exitArgument(ctx) {} // Enter a parse tree produced by GraphQLParser#alias.

	  }, {
	    key: "enterAlias",
	    value: function enterAlias(ctx) {} // Exit a parse tree produced by GraphQLParser#alias.

	  }, {
	    key: "exitAlias",
	    value: function exitAlias(ctx) {} // Enter a parse tree produced by GraphQLParser#fragmentSpread.

	  }, {
	    key: "enterFragmentSpread",
	    value: function enterFragmentSpread(ctx) {} // Exit a parse tree produced by GraphQLParser#fragmentSpread.

	  }, {
	    key: "exitFragmentSpread",
	    value: function exitFragmentSpread(ctx) {} // Enter a parse tree produced by GraphQLParser#fragmentDefinition.

	  }, {
	    key: "enterFragmentDefinition",
	    value: function enterFragmentDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#fragmentDefinition.

	  }, {
	    key: "exitFragmentDefinition",
	    value: function exitFragmentDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#fragmentName.

	  }, {
	    key: "enterFragmentName",
	    value: function enterFragmentName(ctx) {} // Exit a parse tree produced by GraphQLParser#fragmentName.

	  }, {
	    key: "exitFragmentName",
	    value: function exitFragmentName(ctx) {} // Enter a parse tree produced by GraphQLParser#typeCondition.

	  }, {
	    key: "enterTypeCondition",
	    value: function enterTypeCondition(ctx) {} // Exit a parse tree produced by GraphQLParser#typeCondition.

	  }, {
	    key: "exitTypeCondition",
	    value: function exitTypeCondition(ctx) {} // Enter a parse tree produced by GraphQLParser#inlineFragment.

	  }, {
	    key: "enterInlineFragment",
	    value: function enterInlineFragment(ctx) {} // Exit a parse tree produced by GraphQLParser#inlineFragment.

	  }, {
	    key: "exitInlineFragment",
	    value: function exitInlineFragment(ctx) {} // Enter a parse tree produced by GraphQLParser#value.

	  }, {
	    key: "enterValue",
	    value: function enterValue(ctx) {} // Exit a parse tree produced by GraphQLParser#value.

	  }, {
	    key: "exitValue",
	    value: function exitValue(ctx) {} // Enter a parse tree produced by GraphQLParser#intValue.

	  }, {
	    key: "enterIntValue",
	    value: function enterIntValue(ctx) {} // Exit a parse tree produced by GraphQLParser#intValue.

	  }, {
	    key: "exitIntValue",
	    value: function exitIntValue(ctx) {} // Enter a parse tree produced by GraphQLParser#floatValue.

	  }, {
	    key: "enterFloatValue",
	    value: function enterFloatValue(ctx) {} // Exit a parse tree produced by GraphQLParser#floatValue.

	  }, {
	    key: "exitFloatValue",
	    value: function exitFloatValue(ctx) {} // Enter a parse tree produced by GraphQLParser#booleanValue.

	  }, {
	    key: "enterBooleanValue",
	    value: function enterBooleanValue(ctx) {} // Exit a parse tree produced by GraphQLParser#booleanValue.

	  }, {
	    key: "exitBooleanValue",
	    value: function exitBooleanValue(ctx) {} // Enter a parse tree produced by GraphQLParser#stringValue.

	  }, {
	    key: "enterStringValue",
	    value: function enterStringValue(ctx) {} // Exit a parse tree produced by GraphQLParser#stringValue.

	  }, {
	    key: "exitStringValue",
	    value: function exitStringValue(ctx) {} // Enter a parse tree produced by GraphQLParser#nullValue.

	  }, {
	    key: "enterNullValue",
	    value: function enterNullValue(ctx) {} // Exit a parse tree produced by GraphQLParser#nullValue.

	  }, {
	    key: "exitNullValue",
	    value: function exitNullValue(ctx) {} // Enter a parse tree produced by GraphQLParser#enumValue.

	  }, {
	    key: "enterEnumValue",
	    value: function enterEnumValue(ctx) {} // Exit a parse tree produced by GraphQLParser#enumValue.

	  }, {
	    key: "exitEnumValue",
	    value: function exitEnumValue(ctx) {} // Enter a parse tree produced by GraphQLParser#listValue.

	  }, {
	    key: "enterListValue",
	    value: function enterListValue(ctx) {} // Exit a parse tree produced by GraphQLParser#listValue.

	  }, {
	    key: "exitListValue",
	    value: function exitListValue(ctx) {} // Enter a parse tree produced by GraphQLParser#objectValue.

	  }, {
	    key: "enterObjectValue",
	    value: function enterObjectValue(ctx) {} // Exit a parse tree produced by GraphQLParser#objectValue.

	  }, {
	    key: "exitObjectValue",
	    value: function exitObjectValue(ctx) {} // Enter a parse tree produced by GraphQLParser#objectField.

	  }, {
	    key: "enterObjectField",
	    value: function enterObjectField(ctx) {} // Exit a parse tree produced by GraphQLParser#objectField.

	  }, {
	    key: "exitObjectField",
	    value: function exitObjectField(ctx) {} // Enter a parse tree produced by GraphQLParser#variable.

	  }, {
	    key: "enterVariable",
	    value: function enterVariable(ctx) {} // Exit a parse tree produced by GraphQLParser#variable.

	  }, {
	    key: "exitVariable",
	    value: function exitVariable(ctx) {} // Enter a parse tree produced by GraphQLParser#variableDefinitions.

	  }, {
	    key: "enterVariableDefinitions",
	    value: function enterVariableDefinitions(ctx) {} // Exit a parse tree produced by GraphQLParser#variableDefinitions.

	  }, {
	    key: "exitVariableDefinitions",
	    value: function exitVariableDefinitions(ctx) {} // Enter a parse tree produced by GraphQLParser#variableDefinition.

	  }, {
	    key: "enterVariableDefinition",
	    value: function enterVariableDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#variableDefinition.

	  }, {
	    key: "exitVariableDefinition",
	    value: function exitVariableDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#defaultValue.

	  }, {
	    key: "enterDefaultValue",
	    value: function enterDefaultValue(ctx) {} // Exit a parse tree produced by GraphQLParser#defaultValue.

	  }, {
	    key: "exitDefaultValue",
	    value: function exitDefaultValue(ctx) {} // Enter a parse tree produced by GraphQLParser#type_.

	  }, {
	    key: "enterType_",
	    value: function enterType_(ctx) {} // Exit a parse tree produced by GraphQLParser#type_.

	  }, {
	    key: "exitType_",
	    value: function exitType_(ctx) {} // Enter a parse tree produced by GraphQLParser#namedType.

	  }, {
	    key: "enterNamedType",
	    value: function enterNamedType(ctx) {} // Exit a parse tree produced by GraphQLParser#namedType.

	  }, {
	    key: "exitNamedType",
	    value: function exitNamedType(ctx) {} // Enter a parse tree produced by GraphQLParser#listType.

	  }, {
	    key: "enterListType",
	    value: function enterListType(ctx) {} // Exit a parse tree produced by GraphQLParser#listType.

	  }, {
	    key: "exitListType",
	    value: function exitListType(ctx) {} // Enter a parse tree produced by GraphQLParser#directives.

	  }, {
	    key: "enterDirectives",
	    value: function enterDirectives(ctx) {} // Exit a parse tree produced by GraphQLParser#directives.

	  }, {
	    key: "exitDirectives",
	    value: function exitDirectives(ctx) {} // Enter a parse tree produced by GraphQLParser#directive.

	  }, {
	    key: "enterDirective",
	    value: function enterDirective(ctx) {} // Exit a parse tree produced by GraphQLParser#directive.

	  }, {
	    key: "exitDirective",
	    value: function exitDirective(ctx) {} // Enter a parse tree produced by GraphQLParser#typeSystemDefinition.

	  }, {
	    key: "enterTypeSystemDefinition",
	    value: function enterTypeSystemDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#typeSystemDefinition.

	  }, {
	    key: "exitTypeSystemDefinition",
	    value: function exitTypeSystemDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#typeSystemExtension.

	  }, {
	    key: "enterTypeSystemExtension",
	    value: function enterTypeSystemExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#typeSystemExtension.

	  }, {
	    key: "exitTypeSystemExtension",
	    value: function exitTypeSystemExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#schemaDefinition.

	  }, {
	    key: "enterSchemaDefinition",
	    value: function enterSchemaDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#schemaDefinition.

	  }, {
	    key: "exitSchemaDefinition",
	    value: function exitSchemaDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#rootOperationTypeDefinition.

	  }, {
	    key: "enterRootOperationTypeDefinition",
	    value: function enterRootOperationTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#rootOperationTypeDefinition.

	  }, {
	    key: "exitRootOperationTypeDefinition",
	    value: function exitRootOperationTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#schemaExtension.

	  }, {
	    key: "enterSchemaExtension",
	    value: function enterSchemaExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#schemaExtension.

	  }, {
	    key: "exitSchemaExtension",
	    value: function exitSchemaExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#operationTypeDefinition.

	  }, {
	    key: "enterOperationTypeDefinition",
	    value: function enterOperationTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#operationTypeDefinition.

	  }, {
	    key: "exitOperationTypeDefinition",
	    value: function exitOperationTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#description.

	  }, {
	    key: "enterDescription",
	    value: function enterDescription(ctx) {} // Exit a parse tree produced by GraphQLParser#description.

	  }, {
	    key: "exitDescription",
	    value: function exitDescription(ctx) {} // Enter a parse tree produced by GraphQLParser#typeDefinition.

	  }, {
	    key: "enterTypeDefinition",
	    value: function enterTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#typeDefinition.

	  }, {
	    key: "exitTypeDefinition",
	    value: function exitTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#typeExtension.

	  }, {
	    key: "enterTypeExtension",
	    value: function enterTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#typeExtension.

	  }, {
	    key: "exitTypeExtension",
	    value: function exitTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#scalarTypeDefinition.

	  }, {
	    key: "enterScalarTypeDefinition",
	    value: function enterScalarTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#scalarTypeDefinition.

	  }, {
	    key: "exitScalarTypeDefinition",
	    value: function exitScalarTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#scalarTypeExtension.

	  }, {
	    key: "enterScalarTypeExtension",
	    value: function enterScalarTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#scalarTypeExtension.

	  }, {
	    key: "exitScalarTypeExtension",
	    value: function exitScalarTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#objectTypeDefinition.

	  }, {
	    key: "enterObjectTypeDefinition",
	    value: function enterObjectTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#objectTypeDefinition.

	  }, {
	    key: "exitObjectTypeDefinition",
	    value: function exitObjectTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#implementsInterfaces.

	  }, {
	    key: "enterImplementsInterfaces",
	    value: function enterImplementsInterfaces(ctx) {} // Exit a parse tree produced by GraphQLParser#implementsInterfaces.

	  }, {
	    key: "exitImplementsInterfaces",
	    value: function exitImplementsInterfaces(ctx) {} // Enter a parse tree produced by GraphQLParser#fieldsDefinition.

	  }, {
	    key: "enterFieldsDefinition",
	    value: function enterFieldsDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#fieldsDefinition.

	  }, {
	    key: "exitFieldsDefinition",
	    value: function exitFieldsDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#fieldDefinition.

	  }, {
	    key: "enterFieldDefinition",
	    value: function enterFieldDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#fieldDefinition.

	  }, {
	    key: "exitFieldDefinition",
	    value: function exitFieldDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#argumentsDefinition.

	  }, {
	    key: "enterArgumentsDefinition",
	    value: function enterArgumentsDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#argumentsDefinition.

	  }, {
	    key: "exitArgumentsDefinition",
	    value: function exitArgumentsDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#inputValueDefinition.

	  }, {
	    key: "enterInputValueDefinition",
	    value: function enterInputValueDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#inputValueDefinition.

	  }, {
	    key: "exitInputValueDefinition",
	    value: function exitInputValueDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#objectTypeExtension.

	  }, {
	    key: "enterObjectTypeExtension",
	    value: function enterObjectTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#objectTypeExtension.

	  }, {
	    key: "exitObjectTypeExtension",
	    value: function exitObjectTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#interfaceTypeDefinition.

	  }, {
	    key: "enterInterfaceTypeDefinition",
	    value: function enterInterfaceTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#interfaceTypeDefinition.

	  }, {
	    key: "exitInterfaceTypeDefinition",
	    value: function exitInterfaceTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#interfaceTypeExtension.

	  }, {
	    key: "enterInterfaceTypeExtension",
	    value: function enterInterfaceTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#interfaceTypeExtension.

	  }, {
	    key: "exitInterfaceTypeExtension",
	    value: function exitInterfaceTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#unionTypeDefinition.

	  }, {
	    key: "enterUnionTypeDefinition",
	    value: function enterUnionTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#unionTypeDefinition.

	  }, {
	    key: "exitUnionTypeDefinition",
	    value: function exitUnionTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#unionMemberTypes.

	  }, {
	    key: "enterUnionMemberTypes",
	    value: function enterUnionMemberTypes(ctx) {} // Exit a parse tree produced by GraphQLParser#unionMemberTypes.

	  }, {
	    key: "exitUnionMemberTypes",
	    value: function exitUnionMemberTypes(ctx) {} // Enter a parse tree produced by GraphQLParser#unionTypeExtension.

	  }, {
	    key: "enterUnionTypeExtension",
	    value: function enterUnionTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#unionTypeExtension.

	  }, {
	    key: "exitUnionTypeExtension",
	    value: function exitUnionTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#enumTypeDefinition.

	  }, {
	    key: "enterEnumTypeDefinition",
	    value: function enterEnumTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#enumTypeDefinition.

	  }, {
	    key: "exitEnumTypeDefinition",
	    value: function exitEnumTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#enumValuesDefinition.

	  }, {
	    key: "enterEnumValuesDefinition",
	    value: function enterEnumValuesDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#enumValuesDefinition.

	  }, {
	    key: "exitEnumValuesDefinition",
	    value: function exitEnumValuesDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#enumValueDefinition.

	  }, {
	    key: "enterEnumValueDefinition",
	    value: function enterEnumValueDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#enumValueDefinition.

	  }, {
	    key: "exitEnumValueDefinition",
	    value: function exitEnumValueDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#enumTypeExtension.

	  }, {
	    key: "enterEnumTypeExtension",
	    value: function enterEnumTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#enumTypeExtension.

	  }, {
	    key: "exitEnumTypeExtension",
	    value: function exitEnumTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#inputObjectTypeDefinition.

	  }, {
	    key: "enterInputObjectTypeDefinition",
	    value: function enterInputObjectTypeDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#inputObjectTypeDefinition.

	  }, {
	    key: "exitInputObjectTypeDefinition",
	    value: function exitInputObjectTypeDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#inputFieldsDefinition.

	  }, {
	    key: "enterInputFieldsDefinition",
	    value: function enterInputFieldsDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#inputFieldsDefinition.

	  }, {
	    key: "exitInputFieldsDefinition",
	    value: function exitInputFieldsDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#inputObjectTypeExtension.

	  }, {
	    key: "enterInputObjectTypeExtension",
	    value: function enterInputObjectTypeExtension(ctx) {} // Exit a parse tree produced by GraphQLParser#inputObjectTypeExtension.

	  }, {
	    key: "exitInputObjectTypeExtension",
	    value: function exitInputObjectTypeExtension(ctx) {} // Enter a parse tree produced by GraphQLParser#directiveDefinition.

	  }, {
	    key: "enterDirectiveDefinition",
	    value: function enterDirectiveDefinition(ctx) {} // Exit a parse tree produced by GraphQLParser#directiveDefinition.

	  }, {
	    key: "exitDirectiveDefinition",
	    value: function exitDirectiveDefinition(ctx) {} // Enter a parse tree produced by GraphQLParser#directiveLocations.

	  }, {
	    key: "enterDirectiveLocations",
	    value: function enterDirectiveLocations(ctx) {} // Exit a parse tree produced by GraphQLParser#directiveLocations.

	  }, {
	    key: "exitDirectiveLocations",
	    value: function exitDirectiveLocations(ctx) {} // Enter a parse tree produced by GraphQLParser#directiveLocation.

	  }, {
	    key: "enterDirectiveLocation",
	    value: function enterDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLParser#directiveLocation.

	  }, {
	    key: "exitDirectiveLocation",
	    value: function exitDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLParser#executableDirectiveLocation.

	  }, {
	    key: "enterExecutableDirectiveLocation",
	    value: function enterExecutableDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLParser#executableDirectiveLocation.

	  }, {
	    key: "exitExecutableDirectiveLocation",
	    value: function exitExecutableDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLParser#typeSystemDirectiveLocation.

	  }, {
	    key: "enterTypeSystemDirectiveLocation",
	    value: function enterTypeSystemDirectiveLocation(ctx) {} // Exit a parse tree produced by GraphQLParser#typeSystemDirectiveLocation.

	  }, {
	    key: "exitTypeSystemDirectiveLocation",
	    value: function exitTypeSystemDirectiveLocation(ctx) {} // Enter a parse tree produced by GraphQLParser#name.

	  }, {
	    key: "enterName",
	    value: function enterName(ctx) {} // Exit a parse tree produced by GraphQLParser#name.

	  }, {
	    key: "exitName",
	    value: function exitName(ctx) {} // Enter a parse tree produced by GraphQLParser#keyword.

	  }, {
	    key: "enterKeyword",
	    value: function enterKeyword(ctx) {} // Exit a parse tree produced by GraphQLParser#keyword.

	  }, {
	    key: "exitKeyword",
	    value: function exitKeyword(ctx) {}
	  }]);

	  return GraphQLListener;
	}(_antlr["default"].tree.ParseTreeListener);

	exports["default"] = GraphQLListener;
} (GraphQLListener));

var GraphqlListener = /*@__PURE__*/getDefaultExportFromCjs(GraphQLListener);

(function (exports) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	var _antlr = _interopRequireDefault(require$$0$1);

	var _GraphQLListener = _interopRequireDefault(GraphQLListener);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var serializedATN = ["\x03\u608B\uA72A\u8133\uB9ED\u417C\u3BE7\u7786", "\u5964\x03J\u02CD\x04\x02\t\x02\x04\x03\t\x03\x04\x04", "\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07\t\x07", "\x04\b\t\b\x04\t\t\t\x04\n\t\n\x04\x0B\t\x0B\x04\f\t\f", "\x04\r\t\r\x04\x0E\t\x0E\x04\x0F\t\x0F\x04\x10\t\x10", "\x04\x11\t\x11\x04\x12\t\x12\x04\x13\t\x13\x04\x14", "\t\x14\x04\x15\t\x15\x04\x16\t\x16\x04\x17\t\x17", "\x04\x18\t\x18\x04\x19\t\x19\x04\x1A\t\x1A\x04\x1B", "\t\x1B\x04\x1C\t\x1C\x04\x1D\t\x1D\x04\x1E\t\x1E", "\x04\x1F\t\x1F\x04 \t \x04!\t!\x04\"\t\"\x04#\t#\x04", "$\t$\x04%\t%\x04&\t&\x04'\t'\x04(\t(\x04)\t)\x04*\t*\x04", "+\t+\x04,\t,\x04-\t-\x04.\t.\x04/\t/\x040\t0\x041\t1\x04", "2\t2\x043\t3\x044\t4\x045\t5\x046\t6\x047\t7\x048\t8\x04", "9\t9\x04:\t:\x04;\t;\x04<\t<\x04=\t=\x04>\t>\x04?\t?\x04", "@\t@\x04A\tA\x04B\tB\x04C\tC\x04D\tD\x04E\tE\x04F\tF\x04", "G\tG\x04H\tH\x04I\tI\x03\x02\x06\x02\x94\n\x02\r\x02", "\x0E\x02\x95\x03\x02\x03\x02\x03\x03\x03\x03\x03", "\x03\x05\x03\x9D\n\x03\x03\x04\x03\x04\x05\x04", "\xA1\n\x04\x03\x05\x03\x05\x05\x05\xA5\n\x05\x03", "\x05\x05\x05\xA8\n\x05\x03\x05\x05\x05\xAB\n\x05", "\x03\x05\x03\x05\x03\x05\x05\x05\xB0\n\x05\x03", "\x06\x03\x06\x03\x07\x03\x07\x06\x07\xB6\n\x07", "\r\x07\x0E\x07\xB7\x03\x07\x03\x07\x03\b\x03\b\x03", "\b\x05\b\xBF\n\b\x03\t\x05\t\xC2\n\t\x03\t\x03\t\x05", "\t\xC6\n\t\x03\t\x05\t\xC9\n\t\x03\t\x05\t\xCC\n\t\x03", "\n\x03\n\x06\n\xD0\n\n\r\n\x0E\n\xD1\x03\n\x03\n\x03", "\x0B\x03\x0B\x03\x0B\x03\x0B\x03\f\x03\f\x03\f\x03", "\r\x03\r\x03\r\x05\r\xE0\n\r\x03\x0E\x03\x0E\x03\x0E", "\x03\x0E\x05\x0E\xE6\n\x0E\x03\x0E\x03\x0E\x03", "\x0F\x03\x0F\x03\x10\x03\x10\x03\x10\x03\x11\x03", "\x11\x05\x11\xF1\n\x11\x03\x11\x05\x11\xF4\n\x11", "\x03\x11\x03\x11\x03\x12\x03\x12\x03\x12\x03\x12", "\x03\x12\x03\x12\x03\x12\x03\x12\x03\x12\x05\x12", "\u0101\n\x12\x03\x13\x03\x13\x03\x14\x03\x14\x03", "\x15\x03\x15\x03\x16\x03\x16\x03\x17\x03\x17\x03", "\x18\x03\x18\x03\x19\x03\x19\x03\x19\x03\x19\x06", "\x19\u0113\n\x19\r\x19\x0E\x19\u0114\x03\x19\x03\x19", "\x05\x19\u0119\n\x19\x03\x1A\x03\x1A\x07\x1A\u011D", "\n\x1A\f\x1A\x0E\x1A\u0120\x0B\x1A\x03\x1A\x03\x1A", "\x03\x1B\x03\x1B\x03\x1B\x03\x1B\x03\x1C\x03\x1C", "\x03\x1C\x03\x1D\x03\x1D\x06\x1D\u012D\n\x1D\r\x1D", "\x0E\x1D\u012E\x03\x1D\x03\x1D\x03\x1E\x03\x1E\x03", "\x1E\x03\x1E\x05\x1E\u0137\n\x1E\x03\x1F\x03\x1F", "\x03\x1F\x03 \x03 \x05 \u013E\n \x03 \x03 \x05 \u0142", "\n \x05 \u0144\n \x03!\x03!\x03\"\x03\"\x03\"\x03\"\x03", "#\x06#\u014D\n#\r#\x0E#\u014E\x03$\x03$\x03$\x05$\u0154", "\n$\x03%\x03%\x03%\x05%\u0159\n%\x03&\x03&\x05&\u015D", "\n&\x03'\x05'\u0160\n'\x03'\x03'\x05'\u0164\n'\x03", "'\x03'\x06'\u0168\n'\r'\x0E'\u0169\x03'\x03'\x03", "(\x03(\x03(\x03(\x03)\x03)\x03)\x05)\u0175\n)\x03)\x03", ")\x06)\u0179\n)\r)\x0E)\u017A\x03)\x03)\x03)\x03)\x03", ")\x05)\u0182\n)\x03*\x03*\x03*\x03*\x03+\x03+\x03,\x03", ",\x03,\x03,\x03,\x03,\x05,\u0190\n,\x03-\x03-\x03-\x03", "-\x03-\x03-\x05-\u0198\n-\x03.\x05.\u019B\n.\x03.\x03", ".\x03.\x05.\u01A0\n.\x03/\x03/\x03/\x03/\x03/\x030\x05", "0\u01A8\n0\x030\x030\x030\x050\u01AD\n0\x030\x050\u01B0", "\n0\x030\x050\u01B3\n0\x031\x031\x051\u01B7\n1\x031\x03", "1\x031\x071\u01BC\n1\f1\x0E1\u01BF\x0B1\x032\x032\x06", "2\u01C3\n2\r2\x0E2\u01C4\x032\x032\x033\x053\u01CA\n3\x03", "3\x033\x053\u01CE\n3\x033\x033\x033\x053\u01D3\n3\x03", "3\x053\u01D6\n3\x033\x033\x053\u01DA\n3\x033\x033\x03", "3\x053\u01DF\n3\x034\x034\x064\u01E3\n4\r4\x0E4\u01E4\x03", "4\x034\x035\x055\u01EA\n5\x035\x035\x035\x035\x055\u01F0", "\n5\x035\x055\u01F3\n5\x036\x036\x036\x036\x056\u01F9", "\n6\x036\x056\u01FC\n6\x036\x036\x036\x036\x036\x03", "6\x056\u0204\n6\x036\x036\x036\x036\x036\x036\x036\x05", "6\u020D\n6\x037\x057\u0210\n7\x037\x037\x037\x057\u0215", "\n7\x037\x057\u0218\n7\x037\x057\u021B\n7\x038\x038\x03", "8\x038\x058\u0221\n8\x038\x058\u0224\n8\x038\x038\x03", "8\x038\x038\x038\x058\u022C\n8\x038\x038\x038\x038\x03", "8\x038\x038\x058\u0235\n8\x039\x059\u0238\n9\x039\x03", "9\x039\x059\u023D\n9\x039\x059\u0240\n9\x03:\x03:\x05", ":\u0244\n:\x03:\x03:\x03:\x07:\u0249\n:\f:\x0E:\u024C\x0B", ":\x03;\x03;\x03;\x03;\x05;\u0252\n;\x03;\x03;\x03;\x03", ";\x03;\x03;\x03;\x05;\u025B\n;\x03<\x05<\u025E\n<\x03", "<\x03<\x03<\x05<\u0263\n<\x03<\x05<\u0266\n<\x03=\x03", "=\x06=\u026A\n=\r=\x0E=\u026B\x03=\x03=\x03>\x05>\u0271", "\n>\x03>\x03>\x05>\u0275\n>\x03?\x03?\x03?\x03?\x05", "?\u027B\n?\x03?\x03?\x03?\x03?\x03?\x03?\x03?\x05?\u0284", "\n?\x03@\x05@\u0287\n@\x03@\x03@\x03@\x05@\u028C\n@\x03", "@\x05@\u028F\n@\x03A\x03A\x06A\u0293\nA\rA\x0EA\u0294\x03", "A\x03A\x03B\x03B\x03B\x03B\x05B\u029D\nB\x03B\x03B\x03", "B\x03B\x03B\x03B\x03B\x05B\u02A6\nB\x03C\x05C\u02A9\n", "C\x03C\x03C\x03C\x03C\x05C\u02AF\nC\x03C\x05C\u02B2\n", "C\x03C\x03C\x03C\x03D\x03D\x03D\x07D\u02BA\nD\fD\x0E", "D\u02BD\x0BD\x03E\x03E\x05E\u02C1\nE\x03F\x03F\x03G\x03", "G\x03H\x03H\x05H\u02C9\nH\x03I\x03I\x03I\x02\x02J\x02", "\x04\x06\b\n\f\x0E\x10\x12\x14\x16\x18\x1A\x1C\x1E", " \"$&(*,.02468:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\x80\x82\x84", "\x86\x88\x8A\x8C\x8E\x90\x02\b\x03\x02\x03\x05", "\x03\x02\x0E\x0F\x03\x02>?\x03\x02$+\x03\x02,6\x07", "\x02\x03\x05\f\f\x17\x1B\x1D\x1E <\x02\u02F9\x02\x93", "\x03\x02\x02\x02\x04\x9C\x03\x02\x02\x02\x06\xA0", "\x03\x02\x02\x02\b\xAF\x03\x02\x02\x02\n\xB1\x03", "\x02\x02\x02\f\xB3\x03\x02\x02\x02\x0E\xBE\x03", "\x02\x02\x02\x10\xC1\x03\x02\x02\x02\x12\xCD\x03", "\x02\x02\x02\x14\xD5\x03\x02\x02\x02\x16\xD9\x03", "\x02\x02\x02\x18\xDC\x03\x02\x02\x02\x1A\xE1\x03", "\x02\x02\x02\x1C\xE9\x03\x02\x02\x02\x1E\xEB\x03", "\x02\x02\x02 \xEE\x03\x02\x02\x02\"\u0100\x03\x02", "\x02\x02$\u0102\x03\x02\x02\x02&\u0104\x03\x02\x02", "\x02(\u0106\x03\x02\x02\x02*\u0108\x03\x02\x02\x02", ",\u010A\x03\x02\x02\x02.\u010C\x03\x02\x02\x020\u0118", "\x03\x02\x02\x022\u011A\x03\x02\x02\x024\u0123\x03", "\x02\x02\x026\u0127\x03\x02\x02\x028\u012A\x03\x02", "\x02\x02:\u0132\x03\x02\x02\x02<\u0138\x03\x02\x02", "\x02>\u0143\x03\x02\x02\x02@\u0145\x03\x02\x02\x02", "B\u0147\x03\x02\x02\x02D\u014C\x03\x02\x02\x02F\u0150", "\x03\x02\x02\x02H\u0158\x03\x02\x02\x02J\u015C\x03", "\x02\x02\x02L\u015F\x03\x02\x02\x02N\u016D\x03\x02", "\x02\x02P\u0181\x03\x02\x02\x02R\u0183\x03\x02\x02", "\x02T\u0187\x03\x02\x02\x02V\u018F\x03\x02\x02\x02", "X\u0197\x03\x02\x02\x02Z\u019A\x03\x02\x02\x02\\\u01A1", "\x03\x02\x02\x02^\u01A7\x03\x02\x02\x02`\u01B4\x03", "\x02\x02\x02b\u01C0\x03\x02\x02\x02d\u01DE\x03\x02", "\x02\x02f\u01E0\x03\x02\x02\x02h\u01E9\x03\x02\x02", "\x02j\u020C\x03\x02\x02\x02l\u020F\x03\x02\x02\x02", "n\u0234\x03\x02\x02\x02p\u0237\x03\x02\x02\x02r\u0241", "\x03\x02\x02\x02t\u025A\x03\x02\x02\x02v\u025D\x03", "\x02\x02\x02x\u0267\x03\x02\x02\x02z\u0270\x03\x02", "\x02\x02|\u0283\x03\x02\x02\x02~\u0286\x03\x02\x02", "\x02\x80\u0290\x03\x02\x02\x02\x82\u02A5\x03\x02\x02", "\x02\x84\u02A8\x03\x02\x02\x02\x86\u02B6\x03\x02\x02", "\x02\x88\u02C0\x03\x02\x02\x02\x8A\u02C2\x03\x02\x02", "\x02\x8C\u02C4\x03\x02\x02\x02\x8E\u02C8\x03\x02\x02", "\x02\x90\u02CA\x03\x02\x02\x02\x92\x94\x05\x04\x03", "\x02\x93\x92\x03\x02\x02\x02\x94\x95\x03\x02\x02", "\x02\x95\x93\x03\x02\x02\x02\x95\x96\x03\x02\x02", "\x02\x96\x97\x03\x02\x02\x02\x97\x98\x07\x02\x02", "\x03\x98\x03\x03\x02\x02\x02\x99\x9D\x05\x06\x04", "\x02\x9A\x9D\x05H%\x02\x9B\x9D\x05J&\x02\x9C\x99", "\x03\x02\x02\x02\x9C\x9A\x03\x02\x02\x02\x9C\x9B", "\x03\x02\x02\x02\x9D\x05\x03\x02\x02\x02\x9E\xA1", "\x05\b\x05\x02\x9F\xA1\x05\x1A\x0E\x02\xA0\x9E", "\x03\x02\x02\x02\xA0\x9F\x03\x02\x02\x02\xA1\x07", "\x03\x02\x02\x02\xA2\xA4\x05\n\x06\x02\xA3\xA5", "\x05\x8EH\x02\xA4\xA3\x03\x02\x02\x02\xA4\xA5", "\x03\x02\x02\x02\xA5\xA7\x03\x02\x02\x02\xA6\xA8", "\x058\x1D\x02\xA7\xA6\x03\x02\x02\x02\xA7\xA8", "\x03\x02\x02\x02\xA8\xAA\x03\x02\x02\x02\xA9\xAB", "\x05D#\x02\xAA\xA9\x03\x02\x02\x02\xAA\xAB\x03", "\x02\x02\x02\xAB\xAC\x03\x02\x02\x02\xAC\xAD\x05", "\f\x07\x02\xAD\xB0\x03\x02\x02\x02\xAE\xB0\x05", "\f\x07\x02\xAF\xA2\x03\x02\x02\x02\xAF\xAE\x03", "\x02\x02\x02\xB0\t\x03\x02\x02\x02\xB1\xB2\t\x02", "\x02\x02\xB2\x0B\x03\x02\x02\x02\xB3\xB5\x07\x06", "\x02\x02\xB4\xB6\x05\x0E\b\x02\xB5\xB4\x03\x02", "\x02\x02\xB6\xB7\x03\x02\x02\x02\xB7\xB5\x03\x02", "\x02\x02\xB7\xB8\x03\x02\x02\x02\xB8\xB9\x03\x02", "\x02\x02\xB9\xBA\x07\x07\x02\x02\xBA\r\x03\x02", "\x02\x02\xBB\xBF\x05\x10\t\x02\xBC\xBF\x05\x18", "\r\x02\xBD\xBF\x05 \x11\x02\xBE\xBB\x03\x02\x02", "\x02\xBE\xBC\x03\x02\x02\x02\xBE\xBD\x03\x02\x02", "\x02\xBF\x0F\x03\x02\x02\x02\xC0\xC2\x05\x16\f", "\x02\xC1\xC0\x03\x02\x02\x02\xC1\xC2\x03\x02\x02", "\x02\xC2\xC3\x03\x02\x02\x02\xC3\xC5\x05\x8EH", "\x02\xC4\xC6\x05\x12\n\x02\xC5\xC4\x03\x02\x02", "\x02\xC5\xC6\x03\x02\x02\x02\xC6\xC8\x03\x02\x02", "\x02\xC7\xC9\x05D#\x02\xC8\xC7\x03\x02\x02\x02", "\xC8\xC9\x03\x02\x02\x02\xC9\xCB\x03\x02\x02\x02", "\xCA\xCC\x05\f\x07\x02\xCB\xCA\x03\x02\x02\x02", "\xCB\xCC\x03\x02\x02\x02\xCC\x11\x03\x02\x02\x02", "\xCD\xCF\x07\b\x02\x02\xCE\xD0\x05\x14\x0B\x02", "\xCF\xCE\x03\x02\x02\x02\xD0\xD1\x03\x02\x02\x02", "\xD1\xCF\x03\x02\x02\x02\xD1\xD2\x03\x02\x02\x02", "\xD2\xD3\x03\x02\x02\x02\xD3\xD4\x07\t\x02\x02", "\xD4\x13\x03\x02\x02\x02\xD5\xD6\x05\x8EH\x02", "\xD6\xD7\x07\n\x02\x02\xD7\xD8\x05\"\x12\x02\xD8", "\x15\x03\x02\x02\x02\xD9\xDA\x05\x8EH\x02\xDA", "\xDB\x07\n\x02\x02\xDB\x17\x03\x02\x02\x02\xDC", "\xDD\x07\x0B\x02\x02\xDD\xDF\x05\x1C\x0F\x02\xDE", "\xE0\x05D#\x02\xDF\xDE\x03\x02\x02\x02\xDF\xE0", "\x03\x02\x02\x02\xE0\x19\x03\x02\x02\x02\xE1\xE2", "\x07\f\x02\x02\xE2\xE3\x05\x1C\x0F\x02\xE3\xE5", "\x05\x1E\x10\x02\xE4\xE6\x05D#\x02\xE5\xE4\x03", "\x02\x02\x02\xE5\xE6\x03\x02\x02\x02\xE6\xE7\x03", "\x02\x02\x02\xE7\xE8\x05\f\x07\x02\xE8\x1B\x03", "\x02\x02\x02\xE9\xEA\x05\x8EH\x02\xEA\x1D\x03", "\x02\x02\x02\xEB\xEC\x07\r\x02\x02\xEC\xED\x05", "@!\x02\xED\x1F\x03\x02\x02\x02\xEE\xF0\x07\x0B", "\x02\x02\xEF\xF1\x05\x1E\x10\x02\xF0\xEF\x03\x02", "\x02\x02\xF0\xF1\x03\x02\x02\x02\xF1\xF3\x03\x02", "\x02\x02\xF2\xF4\x05D#\x02\xF3\xF2\x03\x02\x02", "\x02\xF3\xF4\x03\x02\x02\x02\xF4\xF5\x03\x02\x02", "\x02\xF5\xF6\x05\f\x07\x02\xF6!\x03\x02\x02\x02", "\xF7\u0101\x056\x1C\x02\xF8\u0101\x05$\x13\x02\xF9", "\u0101\x05&\x14\x02\xFA\u0101\x05*\x16\x02\xFB\u0101", "\x05(\x15\x02\xFC\u0101\x05,\x17\x02\xFD\u0101\x05", ".\x18\x02\xFE\u0101\x050\x19\x02\xFF\u0101\x052\x1A", "\x02\u0100\xF7\x03\x02\x02\x02\u0100\xF8\x03\x02\x02", "\x02\u0100\xF9\x03\x02\x02\x02\u0100\xFA\x03\x02\x02", "\x02\u0100\xFB\x03\x02\x02\x02\u0100\xFC\x03\x02\x02", "\x02\u0100\xFD\x03\x02\x02\x02\u0100\xFE\x03\x02\x02", "\x02\u0100\xFF\x03\x02\x02\x02\u0101#\x03\x02\x02", "\x02\u0102\u0103\x07B\x02\x02\u0103%\x03\x02\x02\x02", "\u0104\u0105\x07A\x02\x02\u0105'\x03\x02\x02\x02\u0106", "\u0107\t\x03\x02\x02\u0107)\x03\x02\x02\x02\u0108\u0109", "\t\x04\x02\x02\u0109+\x03\x02\x02\x02\u010A\u010B\x07", "\x10\x02\x02\u010B-\x03\x02\x02\x02\u010C\u010D\x05", "\x8EH\x02\u010D/\x03\x02\x02\x02\u010E\u010F\x07\x11", "\x02\x02\u010F\u0119\x07\x12\x02\x02\u0110\u0112\x07\x11", "\x02\x02\u0111\u0113\x05\"\x12\x02\u0112\u0111\x03\x02", "\x02\x02\u0113\u0114\x03\x02\x02\x02\u0114\u0112\x03\x02", "\x02\x02\u0114\u0115\x03\x02\x02\x02\u0115\u0116\x03\x02", "\x02\x02\u0116\u0117\x07\x12\x02\x02\u0117\u0119\x03\x02", "\x02\x02\u0118\u010E\x03\x02\x02\x02\u0118\u0110\x03\x02", "\x02\x02\u01191\x03\x02\x02\x02\u011A\u011E\x07\x06", "\x02\x02\u011B\u011D\x054\x1B\x02\u011C\u011B\x03\x02", "\x02\x02\u011D\u0120\x03\x02\x02\x02\u011E\u011C\x03\x02", "\x02\x02\u011E\u011F\x03\x02\x02\x02\u011F\u0121\x03\x02", "\x02\x02\u0120\u011E\x03\x02\x02\x02\u0121\u0122\x07\x07", "\x02\x02\u01223\x03\x02\x02\x02\u0123\u0124\x05\x8E", "H\x02\u0124\u0125\x07\n\x02\x02\u0125\u0126\x05\"\x12\x02", "\u01265\x03\x02\x02\x02\u0127\u0128\x07\x13\x02\x02", "\u0128\u0129\x05\x8EH\x02\u01297\x03\x02\x02\x02\u012A", "\u012C\x07\b\x02\x02\u012B\u012D\x05:\x1E\x02\u012C\u012B", "\x03\x02\x02\x02\u012D\u012E\x03\x02\x02\x02\u012E\u012C", "\x03\x02\x02\x02\u012E\u012F\x03\x02\x02\x02\u012F\u0130", "\x03\x02\x02\x02\u0130\u0131\x07\t\x02\x02\u01319\x03", "\x02\x02\x02\u0132\u0133\x056\x1C\x02\u0133\u0134\x07", "\n\x02\x02\u0134\u0136\x05> \x02\u0135\u0137\x05<\x1F\x02", "\u0136\u0135\x03\x02\x02\x02\u0136\u0137\x03\x02\x02\x02", "\u0137;\x03\x02\x02\x02\u0138\u0139\x07\x14\x02\x02", "\u0139\u013A\x05\"\x12\x02\u013A=\x03\x02\x02\x02\u013B", "\u013D\x05@!\x02\u013C\u013E\x07\x15\x02\x02\u013D\u013C", "\x03\x02\x02\x02\u013D\u013E\x03\x02\x02\x02\u013E\u0144", "\x03\x02\x02\x02\u013F\u0141\x05B\"\x02\u0140\u0142\x07", "\x15\x02\x02\u0141\u0140\x03\x02\x02\x02\u0141\u0142\x03", "\x02\x02\x02\u0142\u0144\x03\x02\x02\x02\u0143\u013B\x03", "\x02\x02\x02\u0143\u013F\x03\x02\x02\x02\u0144?\x03", "\x02\x02\x02\u0145\u0146\x05\x8EH\x02\u0146A\x03\x02", "\x02\x02\u0147\u0148\x07\x11\x02\x02\u0148\u0149\x05>", " \x02\u0149\u014A\x07\x12\x02\x02\u014AC\x03\x02\x02", "\x02\u014B\u014D\x05F$\x02\u014C\u014B\x03\x02\x02\x02", "\u014D\u014E\x03\x02\x02\x02\u014E\u014C\x03\x02\x02\x02", "\u014E\u014F\x03\x02\x02\x02\u014FE\x03\x02\x02\x02", "\u0150\u0151\x07\x16\x02\x02\u0151\u0153\x05\x8EH\x02", "\u0152\u0154\x05\x12\n\x02\u0153\u0152\x03\x02\x02\x02", "\u0153\u0154\x03\x02\x02\x02\u0154G\x03\x02\x02\x02", "\u0155\u0159\x05L'\x02\u0156\u0159\x05V,\x02\u0157\u0159\x05", "\x84C\x02\u0158\u0155\x03\x02\x02\x02\u0158\u0156\x03", "\x02\x02\x02\u0158\u0157\x03\x02\x02\x02\u0159I\x03", "\x02\x02\x02\u015A\u015D\x05P)\x02\u015B\u015D\x05X-\x02", "\u015C\u015A\x03\x02\x02\x02\u015C\u015B\x03\x02\x02\x02", "\u015DK\x03\x02\x02\x02\u015E\u0160\x05T+\x02\u015F\u015E", "\x03\x02\x02\x02\u015F\u0160\x03\x02\x02\x02\u0160\u0161", "\x03\x02\x02\x02\u0161\u0163\x07\x17\x02\x02\u0162\u0164", "\x05D#\x02\u0163\u0162\x03\x02\x02\x02\u0163\u0164\x03", "\x02\x02\x02\u0164\u0165\x03\x02\x02\x02\u0165\u0167\x07", "\x06\x02\x02\u0166\u0168\x05N(\x02\u0167\u0166\x03\x02", "\x02\x02\u0168\u0169\x03\x02\x02\x02\u0169\u0167\x03\x02", "\x02\x02\u0169\u016A\x03\x02\x02\x02\u016A\u016B\x03\x02", "\x02\x02\u016B\u016C\x07\x07\x02\x02\u016CM\x03\x02", "\x02\x02\u016D\u016E\x05\n\x06\x02\u016E\u016F\x07\n\x02", "\x02\u016F\u0170\x05@!\x02\u0170O\x03\x02\x02\x02\u0171", "\u0172\x07\x18\x02\x02\u0172\u0174\x07\x17\x02\x02\u0173", "\u0175\x05D#\x02\u0174\u0173\x03\x02\x02\x02\u0174\u0175", "\x03\x02\x02\x02\u0175\u0176\x03\x02\x02\x02\u0176\u0178", "\x07\x06\x02\x02\u0177\u0179\x05R*\x02\u0178\u0177\x03", "\x02\x02\x02\u0179\u017A\x03\x02\x02\x02\u017A\u0178\x03", "\x02\x02\x02\u017A\u017B\x03\x02\x02\x02\u017B\u017C\x03", "\x02\x02\x02\u017C\u017D\x07\x07\x02\x02\u017D\u0182\x03", "\x02\x02\x02\u017E\u017F\x07\x18\x02\x02\u017F\u0180\x07", "\x17\x02\x02\u0180\u0182\x05D#\x02\u0181\u0171\x03\x02", "\x02\x02\u0181\u017E\x03\x02\x02\x02\u0182Q\x03\x02", "\x02\x02\u0183\u0184\x05\n\x06\x02\u0184\u0185\x07\n\x02", "\x02\u0185\u0186\x05@!\x02\u0186S\x03\x02\x02\x02\u0187", "\u0188\x05*\x16\x02\u0188U\x03\x02\x02\x02\u0189\u0190", "\x05Z.\x02\u018A\u0190\x05^0\x02\u018B\u0190\x05l7\x02\u018C", "\u0190\x05p9\x02\u018D\u0190\x05v<\x02\u018E\u0190\x05~@\x02", "\u018F\u0189\x03\x02\x02\x02\u018F\u018A\x03\x02\x02\x02", "\u018F\u018B\x03\x02\x02\x02\u018F\u018C\x03\x02\x02\x02", "\u018F\u018D\x03\x02\x02\x02\u018F\u018E\x03\x02\x02\x02", "\u0190W\x03\x02\x02\x02\u0191\u0198\x05\\/\x02\u0192\u0198", "\x05j6\x02\u0193\u0198\x05n8\x02\u0194\u0198\x05t;\x02\u0195", "\u0198\x05|?\x02\u0196\u0198\x05\x82B\x02\u0197\u0191\x03", "\x02\x02\x02\u0197\u0192\x03\x02\x02\x02\u0197\u0193\x03", "\x02\x02\x02\u0197\u0194\x03\x02\x02\x02\u0197\u0195\x03", "\x02\x02\x02\u0197\u0196\x03\x02\x02\x02\u0198Y\x03", "\x02\x02\x02\u0199\u019B\x05T+\x02\u019A\u0199\x03\x02", "\x02\x02\u019A\u019B\x03\x02\x02\x02\u019B\u019C\x03\x02", "\x02\x02\u019C\u019D\x07\x19\x02\x02\u019D\u019F\x05\x8E", "H\x02\u019E\u01A0\x05D#\x02\u019F\u019E\x03\x02\x02\x02", "\u019F\u01A0\x03\x02\x02\x02\u01A0[\x03\x02\x02\x02", "\u01A1\u01A2\x07\x18\x02\x02\u01A2\u01A3\x07\x19\x02\x02", "\u01A3\u01A4\x05\x8EH\x02\u01A4\u01A5\x05D#\x02\u01A5]\x03", "\x02\x02\x02\u01A6\u01A8\x05T+\x02\u01A7\u01A6\x03\x02", "\x02\x02\u01A7\u01A8\x03\x02\x02\x02\u01A8\u01A9\x03\x02", "\x02\x02\u01A9\u01AA\x07\x1A\x02\x02\u01AA\u01AC\x05\x8E", "H\x02\u01AB\u01AD\x05`1\x02\u01AC\u01AB\x03\x02\x02\x02", "\u01AC\u01AD\x03\x02\x02\x02\u01AD\u01AF\x03\x02\x02\x02", "\u01AE\u01B0\x05D#\x02\u01AF\u01AE\x03\x02\x02\x02\u01AF", "\u01B0\x03\x02\x02\x02\u01B0\u01B2\x03\x02\x02\x02\u01B1", "\u01B3\x05b2\x02\u01B2\u01B1\x03\x02\x02\x02\u01B2\u01B3", "\x03\x02\x02\x02\u01B3_\x03\x02\x02\x02\u01B4\u01B6", "\x07\x1B\x02\x02\u01B5\u01B7\x07\x1C\x02\x02\u01B6\u01B5", "\x03\x02\x02\x02\u01B6\u01B7\x03\x02\x02\x02\u01B7\u01B8", "\x03\x02\x02\x02\u01B8\u01BD\x05@!\x02\u01B9\u01BA\x07", "\x1C\x02\x02\u01BA\u01BC\x05@!\x02\u01BB\u01B9\x03\x02", "\x02\x02\u01BC\u01BF\x03\x02\x02\x02\u01BD\u01BB\x03\x02", "\x02\x02\u01BD\u01BE\x03\x02\x02\x02\u01BEa\x03\x02", "\x02\x02\u01BF\u01BD\x03\x02\x02\x02\u01C0\u01C2\x07\x06", "\x02\x02\u01C1\u01C3\x05d3\x02\u01C2\u01C1\x03\x02\x02", "\x02\u01C3\u01C4\x03\x02\x02\x02\u01C4\u01C2\x03\x02\x02", "\x02\u01C4\u01C5\x03\x02\x02\x02\u01C5\u01C6\x03\x02\x02", "\x02\u01C6\u01C7\x07\x07\x02\x02\u01C7c\x03\x02\x02", "\x02\u01C8\u01CA\x05T+\x02\u01C9\u01C8\x03\x02\x02\x02", "\u01C9\u01CA\x03\x02\x02\x02\u01CA\u01CB\x03\x02\x02\x02", "\u01CB\u01CD\x05\x8EH\x02\u01CC\u01CE\x05f4\x02\u01CD\u01CC", "\x03\x02\x02\x02\u01CD\u01CE\x03\x02\x02\x02\u01CE\u01CF", "\x03\x02\x02\x02\u01CF\u01D0\x07\n\x02\x02\u01D0\u01D2", "\x05> \x02\u01D1\u01D3\x05D#\x02\u01D2\u01D1\x03\x02\x02", "\x02\u01D2\u01D3\x03\x02\x02\x02\u01D3\u01DF\x03\x02\x02", "\x02\u01D4\u01D6\x05T+\x02\u01D5\u01D4\x03\x02\x02\x02", "\u01D5\u01D6\x03\x02\x02\x02\u01D6\u01D7\x03\x02\x02\x02", "\u01D7\u01D9\x05\x8EH\x02\u01D8\u01DA\x05f4\x02\u01D9\u01D8", "\x03\x02\x02\x02\u01D9\u01DA\x03\x02\x02\x02\u01DA\u01DB", "\x03\x02\x02\x02\u01DB\u01DC\x07\n\x02\x02\u01DC\u01DD", "\b3\x01\x02\u01DD\u01DF\x03\x02\x02\x02\u01DE\u01C9\x03", "\x02\x02\x02\u01DE\u01D5\x03\x02\x02\x02\u01DFe\x03", "\x02\x02\x02\u01E0\u01E2\x07\b\x02\x02\u01E1\u01E3\x05", "h5\x02\u01E2\u01E1\x03\x02\x02\x02\u01E3\u01E4\x03\x02", "\x02\x02\u01E4\u01E2\x03\x02\x02\x02\u01E4\u01E5\x03\x02", "\x02\x02\u01E5\u01E6\x03\x02\x02\x02\u01E6\u01E7\x07\t", "\x02\x02\u01E7g\x03\x02\x02\x02\u01E8\u01EA\x05T+\x02", "\u01E9\u01E8\x03\x02\x02\x02\u01E9\u01EA\x03\x02\x02\x02", "\u01EA\u01EB\x03\x02\x02\x02\u01EB\u01EC\x05\x8EH\x02", "\u01EC\u01ED\x07\n\x02\x02\u01ED\u01EF\x05> \x02\u01EE\u01F0", "\x05<\x1F\x02\u01EF\u01EE\x03\x02\x02\x02\u01EF\u01F0", "\x03\x02\x02\x02\u01F0\u01F2\x03\x02\x02\x02\u01F1\u01F3", "\x05D#\x02\u01F2\u01F1\x03\x02\x02\x02\u01F2\u01F3\x03", "\x02\x02\x02\u01F3i\x03\x02\x02\x02\u01F4\u01F5\x07", "\x18\x02\x02\u01F5\u01F6\x07\x1A\x02\x02\u01F6\u01F8\x05", "\x8EH\x02\u01F7\u01F9\x05`1\x02\u01F8\u01F7\x03\x02\x02", "\x02\u01F8\u01F9\x03\x02\x02\x02\u01F9\u01FB\x03\x02\x02", "\x02\u01FA\u01FC\x05D#\x02\u01FB\u01FA\x03\x02\x02\x02", "\u01FB\u01FC\x03\x02\x02\x02\u01FC\u01FD\x03\x02\x02\x02", "\u01FD\u01FE\x05b2\x02\u01FE\u020D\x03\x02\x02\x02\u01FF", "\u0200\x07\x18\x02\x02\u0200\u0201\x07\x1A\x02\x02\u0201", "\u0203\x05\x8EH\x02\u0202\u0204\x05`1\x02\u0203\u0202\x03", "\x02\x02\x02\u0203\u0204\x03\x02\x02\x02\u0204\u0205\x03", "\x02\x02\x02\u0205\u0206\x05D#\x02\u0206\u020D\x03\x02", "\x02\x02\u0207\u0208\x07\x18\x02\x02\u0208\u0209\x07\x1A", "\x02\x02\u0209\u020A\x05\x8EH\x02\u020A\u020B\x05`1\x02", "\u020B\u020D\x03\x02\x02\x02\u020C\u01F4\x03\x02\x02\x02", "\u020C\u01FF\x03\x02\x02\x02\u020C\u0207\x03\x02\x02\x02", "\u020Dk\x03\x02\x02\x02\u020E\u0210\x05T+\x02\u020F\u020E", "\x03\x02\x02\x02\u020F\u0210\x03\x02\x02\x02\u0210\u0211", "\x03\x02\x02\x02\u0211\u0212\x07\x1D\x02\x02\u0212\u0214", "\x05\x8EH\x02\u0213\u0215\x05`1\x02\u0214\u0213\x03\x02", "\x02\x02\u0214\u0215\x03\x02\x02\x02\u0215\u0217\x03\x02", "\x02\x02\u0216\u0218\x05D#\x02\u0217\u0216\x03\x02\x02", "\x02\u0217\u0218\x03\x02\x02\x02\u0218\u021A\x03\x02\x02", "\x02\u0219\u021B\x05b2\x02\u021A\u0219\x03\x02\x02\x02", "\u021A\u021B\x03\x02\x02\x02\u021Bm\x03\x02\x02\x02", "\u021C\u021D\x07\x18\x02\x02\u021D\u021E\x07\x1D\x02\x02", "\u021E\u0220\x05\x8EH\x02\u021F\u0221\x05`1\x02\u0220\u021F", "\x03\x02\x02\x02\u0220\u0221\x03\x02\x02\x02\u0221\u0223", "\x03\x02\x02\x02\u0222\u0224\x05D#\x02\u0223\u0222\x03", "\x02\x02\x02\u0223\u0224\x03\x02\x02\x02\u0224\u0225\x03", "\x02\x02\x02\u0225\u0226\x05b2\x02\u0226\u0235\x03\x02", "\x02\x02\u0227\u0228\x07\x18\x02\x02\u0228\u0229\x07\x1D", "\x02\x02\u0229\u022B\x05\x8EH\x02\u022A\u022C\x05`1\x02", "\u022B\u022A\x03\x02\x02\x02\u022B\u022C\x03\x02\x02\x02", "\u022C\u022D\x03\x02\x02\x02\u022D\u022E\x05D#\x02\u022E", "\u0235\x03\x02\x02\x02\u022F\u0230\x07\x18\x02\x02\u0230", "\u0231\x07\x1D\x02\x02\u0231\u0232\x05\x8EH\x02\u0232", "\u0233\x05`1\x02\u0233\u0235\x03\x02\x02\x02\u0234\u021C", "\x03\x02\x02\x02\u0234\u0227\x03\x02\x02\x02\u0234\u022F", "\x03\x02\x02\x02\u0235o\x03\x02\x02\x02\u0236\u0238", "\x05T+\x02\u0237\u0236\x03\x02\x02\x02\u0237\u0238\x03", "\x02\x02\x02\u0238\u0239\x03\x02\x02\x02\u0239\u023A\x07", "\x1E\x02\x02\u023A\u023C\x05\x8EH\x02\u023B\u023D\x05", "D#\x02\u023C\u023B\x03\x02\x02\x02\u023C\u023D\x03\x02", "\x02\x02\u023D\u023F\x03\x02\x02\x02\u023E\u0240\x05r", ":\x02\u023F\u023E\x03\x02\x02\x02\u023F\u0240\x03\x02", "\x02\x02\u0240q\x03\x02\x02\x02\u0241\u0243\x07\x14", "\x02\x02\u0242\u0244\x07\x1F\x02\x02\u0243\u0242\x03\x02", "\x02\x02\u0243\u0244\x03\x02\x02\x02\u0244\u0245\x03\x02", "\x02\x02\u0245\u024A\x05@!\x02\u0246\u0247\x07\x1F\x02", "\x02\u0247\u0249\x05@!\x02\u0248\u0246\x03\x02\x02\x02", "\u0249\u024C\x03\x02\x02\x02\u024A\u0248\x03\x02\x02\x02", "\u024A\u024B\x03\x02\x02\x02\u024Bs\x03\x02\x02\x02", "\u024C\u024A\x03\x02\x02\x02\u024D\u024E\x07\x18\x02\x02", "\u024E\u024F\x07\x1E\x02\x02\u024F\u0251\x05\x8EH\x02", "\u0250\u0252\x05D#\x02\u0251\u0250\x03\x02\x02\x02\u0251", "\u0252\x03\x02\x02\x02\u0252\u0253\x03\x02\x02\x02\u0253", "\u0254\x05r:\x02\u0254\u025B\x03\x02\x02\x02\u0255\u0256", "\x07\x18\x02\x02\u0256\u0257\x07\x1E\x02\x02\u0257\u0258", "\x05\x8EH\x02\u0258\u0259\x05D#\x02\u0259\u025B\x03\x02", "\x02\x02\u025A\u024D\x03\x02\x02\x02\u025A\u0255\x03\x02", "\x02\x02\u025Bu\x03\x02\x02\x02\u025C\u025E\x05T+\x02", "\u025D\u025C\x03\x02\x02\x02\u025D\u025E\x03\x02\x02\x02", "\u025E\u025F\x03\x02\x02\x02\u025F\u0260\x07 \x02\x02", "\u0260\u0262\x05\x8EH\x02\u0261\u0263\x05D#\x02\u0262\u0261", "\x03\x02\x02\x02\u0262\u0263\x03\x02\x02\x02\u0263\u0265", "\x03\x02\x02\x02\u0264\u0266\x05x=\x02\u0265\u0264\x03", "\x02\x02\x02\u0265\u0266\x03\x02\x02\x02\u0266w\x03", "\x02\x02\x02\u0267\u0269\x07\x06\x02\x02\u0268\u026A\x05", "z>\x02\u0269\u0268\x03\x02\x02\x02\u026A\u026B\x03\x02", "\x02\x02\u026B\u0269\x03\x02\x02\x02\u026B\u026C\x03\x02", "\x02\x02\u026C\u026D\x03\x02\x02\x02\u026D\u026E\x07\x07", "\x02\x02\u026Ey\x03\x02\x02\x02\u026F\u0271\x05T+\x02", "\u0270\u026F\x03\x02\x02\x02\u0270\u0271\x03\x02\x02\x02", "\u0271\u0272\x03\x02\x02\x02\u0272\u0274\x05.\x18\x02", "\u0273\u0275\x05D#\x02\u0274\u0273\x03\x02\x02\x02\u0274", "\u0275\x03\x02\x02\x02\u0275{\x03\x02\x02\x02\u0276", "\u0277\x07\x18\x02\x02\u0277\u0278\x07 \x02\x02\u0278", "\u027A\x05\x8EH\x02\u0279\u027B\x05D#\x02\u027A\u0279\x03", "\x02\x02\x02\u027A\u027B\x03\x02\x02\x02\u027B\u027C\x03", "\x02\x02\x02\u027C\u027D\x05x=\x02\u027D\u0284\x03\x02", "\x02\x02\u027E\u027F\x07\x18\x02\x02\u027F\u0280\x07 ", "\x02\x02\u0280\u0281\x05\x8EH\x02\u0281\u0282\x05D#\x02", "\u0282\u0284\x03\x02\x02\x02\u0283\u0276\x03\x02\x02\x02", "\u0283\u027E\x03\x02\x02\x02\u0284}\x03\x02\x02\x02", "\u0285\u0287\x05T+\x02\u0286\u0285\x03\x02\x02\x02\u0286", "\u0287\x03\x02\x02\x02\u0287\u0288\x03\x02\x02\x02\u0288", "\u0289\x07!\x02\x02\u0289\u028B\x05\x8EH\x02\u028A\u028C", "\x05D#\x02\u028B\u028A\x03\x02\x02\x02\u028B\u028C\x03", "\x02\x02\x02\u028C\u028E\x03\x02\x02\x02\u028D\u028F\x05", "\x80A\x02\u028E\u028D\x03\x02\x02\x02\u028E\u028F\x03", "\x02\x02\x02\u028F\x7F\x03\x02\x02\x02\u0290\u0292\x07", "\x06\x02\x02\u0291\u0293\x05h5\x02\u0292\u0291\x03\x02", "\x02\x02\u0293\u0294\x03\x02\x02\x02\u0294\u0292\x03\x02", "\x02\x02\u0294\u0295\x03\x02\x02\x02\u0295\u0296\x03\x02", "\x02\x02\u0296\u0297\x07\x07\x02\x02\u0297\x81\x03\x02", "\x02\x02\u0298\u0299\x07\x18\x02\x02\u0299\u029A\x07!", "\x02\x02\u029A\u029C\x05\x8EH\x02\u029B\u029D\x05D#\x02", "\u029C\u029B\x03\x02\x02\x02\u029C\u029D\x03\x02\x02\x02", "\u029D\u029E\x03\x02\x02\x02\u029E\u029F\x05\x80A\x02", "\u029F\u02A6\x03\x02\x02\x02\u02A0\u02A1\x07\x18\x02\x02", "\u02A1\u02A2\x07!\x02\x02\u02A2\u02A3\x05\x8EH\x02\u02A3", "\u02A4\x05D#\x02\u02A4\u02A6\x03\x02\x02\x02\u02A5\u0298", "\x03\x02\x02\x02\u02A5\u02A0\x03\x02\x02\x02\u02A6\x83", "\x03\x02\x02\x02\u02A7\u02A9\x05T+\x02\u02A8\u02A7\x03", "\x02\x02\x02\u02A8\u02A9\x03\x02\x02\x02\u02A9\u02AA\x03", "\x02\x02\x02\u02AA\u02AB\x07\"\x02\x02\u02AB\u02AC\x07", "\x16\x02\x02\u02AC\u02AE\x05\x8EH\x02\u02AD\u02AF\x05", "f4\x02\u02AE\u02AD\x03\x02\x02\x02\u02AE\u02AF\x03\x02", "\x02\x02\u02AF\u02B1\x03\x02\x02\x02\u02B0\u02B2\x07#", "\x02\x02\u02B1\u02B0\x03\x02\x02\x02\u02B1\u02B2\x03\x02", "\x02\x02\u02B2\u02B3\x03\x02\x02\x02\u02B3\u02B4\x07\r", "\x02\x02\u02B4\u02B5\x05\x86D\x02\u02B5\x85\x03\x02", "\x02\x02\u02B6\u02BB\x05\x88E\x02\u02B7\u02B8\x07\x1F", "\x02\x02\u02B8\u02BA\x05\x88E\x02\u02B9\u02B7\x03\x02", "\x02\x02\u02BA\u02BD\x03\x02\x02\x02\u02BB\u02B9\x03\x02", "\x02\x02\u02BB\u02BC\x03\x02\x02\x02\u02BC\x87\x03\x02", "\x02\x02\u02BD\u02BB\x03\x02\x02\x02\u02BE\u02C1\x05\x8A", "F\x02\u02BF\u02C1\x05\x8CG\x02\u02C0\u02BE\x03\x02\x02", "\x02\u02C0\u02BF\x03\x02\x02\x02\u02C1\x89\x03\x02\x02", "\x02\u02C2\u02C3\t\x05\x02\x02\u02C3\x8B\x03\x02\x02", "\x02\u02C4\u02C5\t\x06\x02\x02\u02C5\x8D\x03\x02\x02", "\x02\u02C6\u02C9\x05\x90I\x02\u02C7\u02C9\x07=\x02\x02", "\u02C8\u02C6\x03\x02\x02\x02\u02C8\u02C7\x03\x02\x02\x02", "\u02C9\x8F\x03\x02\x02\x02\u02CA\u02CB\t\x07\x02\x02", "\u02CB\x91\x03\x02\x02\x02c\x95\x9C\xA0\xA4\xA7", "\xAA\xAF\xB7\xBE\xC1\xC5\xC8\xCB\xD1\xDF\xE5\xF0", "\xF3\u0100\u0114\u0118\u011E\u012E\u0136\u013D\u0141\u0143\u014E\u0153", "\u0158\u015C\u015F\u0163\u0169\u0174\u017A\u0181\u018F\u0197\u019A\u019F", "\u01A7\u01AC\u01AF\u01B2\u01B6\u01BD\u01C4\u01C9\u01CD\u01D2\u01D5\u01D9", "\u01DE\u01E4\u01E9\u01EF\u01F2\u01F8\u01FB\u0203\u020C\u020F\u0214\u0217", "\u021A\u0220\u0223\u022B\u0234\u0237\u023C\u023F\u0243\u024A\u0251\u025A", "\u025D\u0262\u0265\u026B\u0270\u0274\u027A\u0283\u0286\u028B\u028E\u0294", "\u029C\u02A5\u02A8\u02AE\u02B1\u02BB\u02C0\u02C8"].join("");
	var atn = new _antlr["default"].atn.ATNDeserializer().deserialize(serializedATN);
	var decisionsToDFA = atn.decisionToState.map(function (ds, index) {
	  return new _antlr["default"].dfa.DFA(ds, index);
	});
	var sharedContextCache = new _antlr["default"].PredictionContextCache();

	var GraphQLParser = /*#__PURE__*/function (_antlr4$Parser) {
	  _inherits(GraphQLParser, _antlr4$Parser);

	  var _super = _createSuper(GraphQLParser);

	  function GraphQLParser(input) {
	    var _this;

	    _classCallCheck(this, GraphQLParser);

	    _this = _super.call(this, input);
	    _this._interp = new _antlr["default"].atn.ParserATNSimulator(_assertThisInitialized(_this), atn, decisionsToDFA, sharedContextCache);
	    _this.ruleNames = GraphQLParser.ruleNames;
	    _this.literalNames = GraphQLParser.literalNames;
	    _this.symbolicNames = GraphQLParser.symbolicNames;
	    return _this;
	  }

	  _createClass(GraphQLParser, [{
	    key: "atn",
	    get: function get() {
	      return atn;
	    }
	  }, {
	    key: "document",
	    value: function document() {
	      var localctx = new DocumentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 0, GraphQLParser.RULE_document);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 145;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 144;
	          this.definition();
	          this.state = 147;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__3 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.STRING - 32 | 1 << GraphQLParser.BLOCK_STRING - 32)) !== 0);

	        this.state = 149;
	        this.match(GraphQLParser.EOF);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "definition",
	    value: function definition() {
	      var localctx = new DefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 2, GraphQLParser.RULE_definition);

	      try {
	        this.state = 154;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLParser.T__0:
	          case GraphQLParser.T__1:
	          case GraphQLParser.T__2:
	          case GraphQLParser.T__3:
	          case GraphQLParser.T__9:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 151;
	            this.executableDefinition();
	            break;

	          case GraphQLParser.T__20:
	          case GraphQLParser.T__22:
	          case GraphQLParser.T__23:
	          case GraphQLParser.T__26:
	          case GraphQLParser.T__27:
	          case GraphQLParser.T__29:
	          case GraphQLParser.T__30:
	          case GraphQLParser.T__31:
	          case GraphQLParser.STRING:
	          case GraphQLParser.BLOCK_STRING:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 152;
	            this.typeSystemDefinition();
	            break;

	          case GraphQLParser.T__21:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 153;
	            this.typeSystemExtension();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "executableDefinition",
	    value: function executableDefinition() {
	      var localctx = new ExecutableDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 4, GraphQLParser.RULE_executableDefinition);

	      try {
	        this.state = 158;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLParser.T__0:
	          case GraphQLParser.T__1:
	          case GraphQLParser.T__2:
	          case GraphQLParser.T__3:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 156;
	            this.operationDefinition();
	            break;

	          case GraphQLParser.T__9:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 157;
	            this.fragmentDefinition();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "operationDefinition",
	    value: function operationDefinition() {
	      var localctx = new OperationDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 6, GraphQLParser.RULE_operationDefinition);
	      var _la = 0; // Token type

	      try {
	        this.state = 173;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLParser.T__0:
	          case GraphQLParser.T__1:
	          case GraphQLParser.T__2:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 160;
	            this.operationType();
	            this.state = 162;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32 | 1 << GraphQLParser.NAME - 32)) !== 0) {
	              this.state = 161;
	              this.name();
	            }

	            this.state = 165;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__5) {
	              this.state = 164;
	              this.variableDefinitions();
	            }

	            this.state = 168;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__19) {
	              this.state = 167;
	              this.directives();
	            }

	            this.state = 170;
	            this.selectionSet();
	            break;

	          case GraphQLParser.T__3:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 172;
	            this.selectionSet();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "operationType",
	    value: function operationType() {
	      var localctx = new OperationTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 8, GraphQLParser.RULE_operationType);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 175;
	        _la = this._input.LA(1);

	        if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      var localctx = new SelectionSetContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 10, GraphQLParser.RULE_selectionSet);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 177;
	        this.match(GraphQLParser.T__3);
	        this.state = 179;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 178;
	          this.selection();
	          this.state = 181;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__8 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32 | 1 << GraphQLParser.NAME - 32)) !== 0);

	        this.state = 183;
	        this.match(GraphQLParser.T__4);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "selection",
	    value: function selection() {
	      var localctx = new SelectionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 12, GraphQLParser.RULE_selection);

	      try {
	        this.state = 188;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 8, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 185;
	            this.field();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 186;
	            this.fragmentSpread();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 187;
	            this.inlineFragment();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "field",
	    value: function field() {
	      var localctx = new FieldContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 14, GraphQLParser.RULE_field);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 191;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 9, this._ctx);

	        if (la_ === 1) {
	          this.state = 190;
	          this.alias();
	        }

	        this.state = 193;
	        this.name();
	        this.state = 195;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__5) {
	          this.state = 194;
	          this.arguments();
	        }

	        this.state = 198;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 197;
	          this.directives();
	        }

	        this.state = 201;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__3) {
	          this.state = 200;
	          this.selectionSet();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "arguments",
	    value: function _arguments() {
	      var localctx = new ArgumentsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 16, GraphQLParser.RULE_arguments);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 203;
	        this.match(GraphQLParser.T__5);
	        this.state = 205;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 204;
	          this.argument();
	          this.state = 207;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32 | 1 << GraphQLParser.NAME - 32)) !== 0);

	        this.state = 209;
	        this.match(GraphQLParser.T__6);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "argument",
	    value: function argument() {
	      var localctx = new ArgumentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 18, GraphQLParser.RULE_argument);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 211;
	        this.name();
	        this.state = 212;
	        this.match(GraphQLParser.T__7);
	        this.state = 213;
	        this.value();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "alias",
	    value: function alias() {
	      var localctx = new AliasContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 20, GraphQLParser.RULE_alias);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 215;
	        this.name();
	        this.state = 216;
	        this.match(GraphQLParser.T__7);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fragmentSpread",
	    value: function fragmentSpread() {
	      var localctx = new FragmentSpreadContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 22, GraphQLParser.RULE_fragmentSpread);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 218;
	        this.match(GraphQLParser.T__8);
	        this.state = 219;
	        this.fragmentName();
	        this.state = 221;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 220;
	          this.directives();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fragmentDefinition",
	    value: function fragmentDefinition() {
	      var localctx = new FragmentDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 24, GraphQLParser.RULE_fragmentDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 223;
	        this.match(GraphQLParser.T__9);
	        this.state = 224;
	        this.fragmentName();
	        this.state = 225;
	        this.typeCondition();
	        this.state = 227;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 226;
	          this.directives();
	        }

	        this.state = 229;
	        this.selectionSet();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fragmentName",
	    value: function fragmentName() {
	      var localctx = new FragmentNameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 26, GraphQLParser.RULE_fragmentName);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 231;
	        this.name();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeCondition",
	    value: function typeCondition() {
	      var localctx = new TypeConditionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 28, GraphQLParser.RULE_typeCondition);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 233;
	        this.match(GraphQLParser.T__10);
	        this.state = 234;
	        this.namedType();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inlineFragment",
	    value: function inlineFragment() {
	      var localctx = new InlineFragmentContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 30, GraphQLParser.RULE_inlineFragment);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 236;
	        this.match(GraphQLParser.T__8);
	        this.state = 238;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__10) {
	          this.state = 237;
	          this.typeCondition();
	        }

	        this.state = 241;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 240;
	          this.directives();
	        }

	        this.state = 243;
	        this.selectionSet();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "value",
	    value: function value() {
	      var localctx = new ValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 32, GraphQLParser.RULE_value);

	      try {
	        this.state = 254;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLParser.T__16:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 245;
	            this.variable();
	            break;

	          case GraphQLParser.INT:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 246;
	            this.intValue();
	            break;

	          case GraphQLParser.FLOAT:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 247;
	            this.floatValue();
	            break;

	          case GraphQLParser.STRING:
	          case GraphQLParser.BLOCK_STRING:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 248;
	            this.stringValue();
	            break;

	          case GraphQLParser.T__11:
	          case GraphQLParser.T__12:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 249;
	            this.booleanValue();
	            break;

	          case GraphQLParser.T__13:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 250;
	            this.nullValue();
	            break;

	          case GraphQLParser.T__0:
	          case GraphQLParser.T__1:
	          case GraphQLParser.T__2:
	          case GraphQLParser.T__9:
	          case GraphQLParser.T__20:
	          case GraphQLParser.T__21:
	          case GraphQLParser.T__22:
	          case GraphQLParser.T__23:
	          case GraphQLParser.T__24:
	          case GraphQLParser.T__26:
	          case GraphQLParser.T__27:
	          case GraphQLParser.T__29:
	          case GraphQLParser.T__30:
	          case GraphQLParser.T__31:
	          case GraphQLParser.T__32:
	          case GraphQLParser.T__33:
	          case GraphQLParser.T__34:
	          case GraphQLParser.T__35:
	          case GraphQLParser.T__36:
	          case GraphQLParser.T__37:
	          case GraphQLParser.T__38:
	          case GraphQLParser.T__39:
	          case GraphQLParser.T__40:
	          case GraphQLParser.T__41:
	          case GraphQLParser.T__42:
	          case GraphQLParser.T__43:
	          case GraphQLParser.T__44:
	          case GraphQLParser.T__45:
	          case GraphQLParser.T__46:
	          case GraphQLParser.T__47:
	          case GraphQLParser.T__48:
	          case GraphQLParser.T__49:
	          case GraphQLParser.T__50:
	          case GraphQLParser.T__51:
	          case GraphQLParser.T__52:
	          case GraphQLParser.T__53:
	          case GraphQLParser.T__54:
	          case GraphQLParser.T__55:
	          case GraphQLParser.T__56:
	          case GraphQLParser.T__57:
	          case GraphQLParser.NAME:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 251;
	            this.enumValue();
	            break;

	          case GraphQLParser.T__14:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 252;
	            this.listValue();
	            break;

	          case GraphQLParser.T__3:
	            this.enterOuterAlt(localctx, 9);
	            this.state = 253;
	            this.objectValue();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "intValue",
	    value: function intValue() {
	      var localctx = new IntValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 34, GraphQLParser.RULE_intValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 256;
	        this.match(GraphQLParser.INT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "floatValue",
	    value: function floatValue() {
	      var localctx = new FloatValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 36, GraphQLParser.RULE_floatValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 258;
	        this.match(GraphQLParser.FLOAT);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "booleanValue",
	    value: function booleanValue() {
	      var localctx = new BooleanValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 38, GraphQLParser.RULE_booleanValue);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 260;
	        _la = this._input.LA(1);

	        if (!(_la === GraphQLParser.T__11 || _la === GraphQLParser.T__12)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "stringValue",
	    value: function stringValue() {
	      var localctx = new StringValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 40, GraphQLParser.RULE_stringValue);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 262;
	        _la = this._input.LA(1);

	        if (!(_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "nullValue",
	    value: function nullValue() {
	      var localctx = new NullValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 42, GraphQLParser.RULE_nullValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 264;
	        this.match(GraphQLParser.T__13);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValue",
	    value: function enumValue() {
	      var localctx = new EnumValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 44, GraphQLParser.RULE_enumValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 266;
	        this.name();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "listValue",
	    value: function listValue() {
	      var localctx = new ListValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 46, GraphQLParser.RULE_listValue);
	      var _la = 0; // Token type

	      try {
	        this.state = 278;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 20, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 268;
	            this.match(GraphQLParser.T__14);
	            this.state = 269;
	            this.match(GraphQLParser.T__15);
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 270;
	            this.match(GraphQLParser.T__14);
	            this.state = 272;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 271;
	              this.value();
	              this.state = 274;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while ((_la - 1 & ~0x1f) == 0 && (1 << _la - 1 & (1 << GraphQLParser.T__0 - 1 | 1 << GraphQLParser.T__1 - 1 | 1 << GraphQLParser.T__2 - 1 | 1 << GraphQLParser.T__3 - 1 | 1 << GraphQLParser.T__9 - 1 | 1 << GraphQLParser.T__11 - 1 | 1 << GraphQLParser.T__12 - 1 | 1 << GraphQLParser.T__13 - 1 | 1 << GraphQLParser.T__14 - 1 | 1 << GraphQLParser.T__16 - 1 | 1 << GraphQLParser.T__20 - 1 | 1 << GraphQLParser.T__21 - 1 | 1 << GraphQLParser.T__22 - 1 | 1 << GraphQLParser.T__23 - 1 | 1 << GraphQLParser.T__24 - 1 | 1 << GraphQLParser.T__26 - 1 | 1 << GraphQLParser.T__27 - 1 | 1 << GraphQLParser.T__29 - 1 | 1 << GraphQLParser.T__30 - 1 | 1 << GraphQLParser.T__31 - 1)) !== 0 || (_la - 33 & ~0x1f) == 0 && (1 << _la - 33 & (1 << GraphQLParser.T__32 - 33 | 1 << GraphQLParser.T__33 - 33 | 1 << GraphQLParser.T__34 - 33 | 1 << GraphQLParser.T__35 - 33 | 1 << GraphQLParser.T__36 - 33 | 1 << GraphQLParser.T__37 - 33 | 1 << GraphQLParser.T__38 - 33 | 1 << GraphQLParser.T__39 - 33 | 1 << GraphQLParser.T__40 - 33 | 1 << GraphQLParser.T__41 - 33 | 1 << GraphQLParser.T__42 - 33 | 1 << GraphQLParser.T__43 - 33 | 1 << GraphQLParser.T__44 - 33 | 1 << GraphQLParser.T__45 - 33 | 1 << GraphQLParser.T__46 - 33 | 1 << GraphQLParser.T__47 - 33 | 1 << GraphQLParser.T__48 - 33 | 1 << GraphQLParser.T__49 - 33 | 1 << GraphQLParser.T__50 - 33 | 1 << GraphQLParser.T__51 - 33 | 1 << GraphQLParser.T__52 - 33 | 1 << GraphQLParser.T__53 - 33 | 1 << GraphQLParser.T__54 - 33 | 1 << GraphQLParser.T__55 - 33 | 1 << GraphQLParser.T__56 - 33 | 1 << GraphQLParser.T__57 - 33 | 1 << GraphQLParser.NAME - 33 | 1 << GraphQLParser.STRING - 33 | 1 << GraphQLParser.BLOCK_STRING - 33 | 1 << GraphQLParser.FLOAT - 33 | 1 << GraphQLParser.INT - 33)) !== 0);

	            this.state = 276;
	            this.match(GraphQLParser.T__15);
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectValue",
	    value: function objectValue() {
	      var localctx = new ObjectValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 48, GraphQLParser.RULE_objectValue);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 280;
	        this.match(GraphQLParser.T__3);
	        this.state = 284;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32 | 1 << GraphQLParser.NAME - 32)) !== 0) {
	          this.state = 281;
	          this.objectField();
	          this.state = 286;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }

	        this.state = 287;
	        this.match(GraphQLParser.T__4);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectField",
	    value: function objectField() {
	      var localctx = new ObjectFieldContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 50, GraphQLParser.RULE_objectField);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 289;
	        this.name();
	        this.state = 290;
	        this.match(GraphQLParser.T__7);
	        this.state = 291;
	        this.value();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "variable",
	    value: function variable() {
	      var localctx = new VariableContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 52, GraphQLParser.RULE_variable);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 293;
	        this.match(GraphQLParser.T__16);
	        this.state = 294;
	        this.name();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "variableDefinitions",
	    value: function variableDefinitions() {
	      var localctx = new VariableDefinitionsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 54, GraphQLParser.RULE_variableDefinitions);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 296;
	        this.match(GraphQLParser.T__5);
	        this.state = 298;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 297;
	          this.variableDefinition();
	          this.state = 300;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while (_la === GraphQLParser.T__16);

	        this.state = 302;
	        this.match(GraphQLParser.T__6);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "variableDefinition",
	    value: function variableDefinition() {
	      var localctx = new VariableDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 56, GraphQLParser.RULE_variableDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 304;
	        this.variable();
	        this.state = 305;
	        this.match(GraphQLParser.T__7);
	        this.state = 306;
	        this.type_();
	        this.state = 308;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__17) {
	          this.state = 307;
	          this.defaultValue();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "defaultValue",
	    value: function defaultValue() {
	      var localctx = new DefaultValueContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 58, GraphQLParser.RULE_defaultValue);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 310;
	        this.match(GraphQLParser.T__17);
	        this.state = 311;
	        this.value();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      var localctx = new Type_Context(this, this._ctx, this.state);
	      this.enterRule(localctx, 60, GraphQLParser.RULE_type_);
	      var _la = 0; // Token type

	      try {
	        this.state = 321;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLParser.T__0:
	          case GraphQLParser.T__1:
	          case GraphQLParser.T__2:
	          case GraphQLParser.T__9:
	          case GraphQLParser.T__20:
	          case GraphQLParser.T__21:
	          case GraphQLParser.T__22:
	          case GraphQLParser.T__23:
	          case GraphQLParser.T__24:
	          case GraphQLParser.T__26:
	          case GraphQLParser.T__27:
	          case GraphQLParser.T__29:
	          case GraphQLParser.T__30:
	          case GraphQLParser.T__31:
	          case GraphQLParser.T__32:
	          case GraphQLParser.T__33:
	          case GraphQLParser.T__34:
	          case GraphQLParser.T__35:
	          case GraphQLParser.T__36:
	          case GraphQLParser.T__37:
	          case GraphQLParser.T__38:
	          case GraphQLParser.T__39:
	          case GraphQLParser.T__40:
	          case GraphQLParser.T__41:
	          case GraphQLParser.T__42:
	          case GraphQLParser.T__43:
	          case GraphQLParser.T__44:
	          case GraphQLParser.T__45:
	          case GraphQLParser.T__46:
	          case GraphQLParser.T__47:
	          case GraphQLParser.T__48:
	          case GraphQLParser.T__49:
	          case GraphQLParser.T__50:
	          case GraphQLParser.T__51:
	          case GraphQLParser.T__52:
	          case GraphQLParser.T__53:
	          case GraphQLParser.T__54:
	          case GraphQLParser.T__55:
	          case GraphQLParser.T__56:
	          case GraphQLParser.T__57:
	          case GraphQLParser.NAME:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 313;
	            this.namedType();
	            this.state = 315;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__18) {
	              this.state = 314;
	              this.match(GraphQLParser.T__18);
	            }

	            break;

	          case GraphQLParser.T__14:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 317;
	            this.listType();
	            this.state = 319;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__18) {
	              this.state = 318;
	              this.match(GraphQLParser.T__18);
	            }

	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "namedType",
	    value: function namedType() {
	      var localctx = new NamedTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 62, GraphQLParser.RULE_namedType);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 323;
	        this.name();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "listType",
	    value: function listType() {
	      var localctx = new ListTypeContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 64, GraphQLParser.RULE_listType);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 325;
	        this.match(GraphQLParser.T__14);
	        this.state = 326;
	        this.type_();
	        this.state = 327;
	        this.match(GraphQLParser.T__15);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      var localctx = new DirectivesContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 66, GraphQLParser.RULE_directives);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 330;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 329;
	          this.directive();
	          this.state = 332;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while (_la === GraphQLParser.T__19);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directive",
	    value: function directive() {
	      var localctx = new DirectiveContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 68, GraphQLParser.RULE_directive);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 334;
	        this.match(GraphQLParser.T__19);
	        this.state = 335;
	        this.name();
	        this.state = 337;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__5) {
	          this.state = 336;
	          this.arguments();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeSystemDefinition",
	    value: function typeSystemDefinition() {
	      var localctx = new TypeSystemDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 70, GraphQLParser.RULE_typeSystemDefinition);

	      try {
	        this.state = 342;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 29, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 339;
	            this.schemaDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 340;
	            this.typeDefinition();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 341;
	            this.directiveDefinition();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeSystemExtension",
	    value: function typeSystemExtension() {
	      var localctx = new TypeSystemExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 72, GraphQLParser.RULE_typeSystemExtension);

	      try {
	        this.state = 346;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 30, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 344;
	            this.schemaExtension();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 345;
	            this.typeExtension();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "schemaDefinition",
	    value: function schemaDefinition() {
	      var localctx = new SchemaDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 74, GraphQLParser.RULE_schemaDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 349;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 348;
	          this.description();
	        }

	        this.state = 351;
	        this.match(GraphQLParser.T__20);
	        this.state = 353;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 352;
	          this.directives();
	        }

	        this.state = 355;
	        this.match(GraphQLParser.T__3);
	        this.state = 357;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 356;
	          this.rootOperationTypeDefinition();
	          this.state = 359;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2)) !== 0);

	        this.state = 361;
	        this.match(GraphQLParser.T__4);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "rootOperationTypeDefinition",
	    value: function rootOperationTypeDefinition() {
	      var localctx = new RootOperationTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 76, GraphQLParser.RULE_rootOperationTypeDefinition);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 363;
	        this.operationType();
	        this.state = 364;
	        this.match(GraphQLParser.T__7);
	        this.state = 365;
	        this.namedType();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "schemaExtension",
	    value: function schemaExtension() {
	      var localctx = new SchemaExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 78, GraphQLParser.RULE_schemaExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 383;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 36, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 367;
	            this.match(GraphQLParser.T__21);
	            this.state = 368;
	            this.match(GraphQLParser.T__20);
	            this.state = 370;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__19) {
	              this.state = 369;
	              this.directives();
	            }

	            this.state = 372;
	            this.match(GraphQLParser.T__3);
	            this.state = 374;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            do {
	              this.state = 373;
	              this.operationTypeDefinition();
	              this.state = 376;

	              this._errHandler.sync(this);

	              _la = this._input.LA(1);
	            } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2)) !== 0);

	            this.state = 378;
	            this.match(GraphQLParser.T__4);
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 380;
	            this.match(GraphQLParser.T__21);
	            this.state = 381;
	            this.match(GraphQLParser.T__20);
	            this.state = 382;
	            this.directives();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "operationTypeDefinition",
	    value: function operationTypeDefinition() {
	      var localctx = new OperationTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 80, GraphQLParser.RULE_operationTypeDefinition);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 385;
	        this.operationType();
	        this.state = 386;
	        this.match(GraphQLParser.T__7);
	        this.state = 387;
	        this.namedType();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      var localctx = new DescriptionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 82, GraphQLParser.RULE_description);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 389;
	        this.stringValue();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeDefinition",
	    value: function typeDefinition() {
	      var localctx = new TypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 84, GraphQLParser.RULE_typeDefinition);

	      try {
	        this.state = 397;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 37, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 391;
	            this.scalarTypeDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 392;
	            this.objectTypeDefinition();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 393;
	            this.interfaceTypeDefinition();
	            break;

	          case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 394;
	            this.unionTypeDefinition();
	            break;

	          case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 395;
	            this.enumTypeDefinition();
	            break;

	          case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 396;
	            this.inputObjectTypeDefinition();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeExtension",
	    value: function typeExtension() {
	      var localctx = new TypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 86, GraphQLParser.RULE_typeExtension);

	      try {
	        this.state = 405;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 38, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 399;
	            this.scalarTypeExtension();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 400;
	            this.objectTypeExtension();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 401;
	            this.interfaceTypeExtension();
	            break;

	          case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 402;
	            this.unionTypeExtension();
	            break;

	          case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 403;
	            this.enumTypeExtension();
	            break;

	          case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 404;
	            this.inputObjectTypeExtension();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "scalarTypeDefinition",
	    value: function scalarTypeDefinition() {
	      var localctx = new ScalarTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 88, GraphQLParser.RULE_scalarTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 408;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 407;
	          this.description();
	        }

	        this.state = 410;
	        this.match(GraphQLParser.T__22);
	        this.state = 411;
	        this.name();
	        this.state = 413;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 412;
	          this.directives();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "scalarTypeExtension",
	    value: function scalarTypeExtension() {
	      var localctx = new ScalarTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 90, GraphQLParser.RULE_scalarTypeExtension);

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 415;
	        this.match(GraphQLParser.T__21);
	        this.state = 416;
	        this.match(GraphQLParser.T__22);
	        this.state = 417;
	        this.name();
	        this.state = 418;
	        this.directives();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectTypeDefinition",
	    value: function objectTypeDefinition() {
	      var localctx = new ObjectTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 92, GraphQLParser.RULE_objectTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 421;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 420;
	          this.description();
	        }

	        this.state = 423;
	        this.match(GraphQLParser.T__23);
	        this.state = 424;
	        this.name();
	        this.state = 426;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__24) {
	          this.state = 425;
	          this.implementsInterfaces();
	        }

	        this.state = 429;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 428;
	          this.directives();
	        }

	        this.state = 432;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 44, this._ctx);

	        if (la_ === 1) {
	          this.state = 431;
	          this.fieldsDefinition();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      var localctx = new ImplementsInterfacesContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 94, GraphQLParser.RULE_implementsInterfaces);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 434;
	        this.match(GraphQLParser.T__24);
	        this.state = 436;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__25) {
	          this.state = 435;
	          this.match(GraphQLParser.T__25);
	        }

	        this.state = 438;
	        this.namedType();
	        this.state = 443;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLParser.T__25) {
	          this.state = 439;
	          this.match(GraphQLParser.T__25);
	          this.state = 440;
	          this.namedType();
	          this.state = 445;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      var localctx = new FieldsDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 96, GraphQLParser.RULE_fieldsDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 446;
	        this.match(GraphQLParser.T__3);
	        this.state = 448;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 447;
	          this.fieldDefinition();
	          this.state = 450;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32 | 1 << GraphQLParser.NAME - 32 | 1 << GraphQLParser.STRING - 32 | 1 << GraphQLParser.BLOCK_STRING - 32)) !== 0);

	        this.state = 452;
	        this.match(GraphQLParser.T__4);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "fieldDefinition",
	    value: function fieldDefinition() {
	      var localctx = new FieldDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 98, GraphQLParser.RULE_fieldDefinition);
	      var _la = 0; // Token type

	      try {
	        this.state = 476;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 53, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 455;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	              this.state = 454;
	              this.description();
	            }

	            this.state = 457;
	            this.name();
	            this.state = 459;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__5) {
	              this.state = 458;
	              this.argumentsDefinition();
	            }

	            this.state = 461;
	            this.match(GraphQLParser.T__7);
	            this.state = 462;
	            this.type_();
	            this.state = 464;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__19) {
	              this.state = 463;
	              this.directives();
	            }

	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 467;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	              this.state = 466;
	              this.description();
	            }

	            this.state = 469;
	            localctx._name = this.name();
	            this.state = 471;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__5) {
	              this.state = 470;
	              this.argumentsDefinition();
	            }

	            this.state = 473;
	            this.match(GraphQLParser.T__7);
	            this.notifyErrorListeners("[AMF]Field '" + (localctx._name === null ? null : this._input.getText(new _antlr["default"].Interval(localctx._name.start, localctx._name.stop))) + "' missing field type", localctx._name === null ? null : localctx._name.start, null);
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "argumentsDefinition",
	    value: function argumentsDefinition() {
	      var localctx = new ArgumentsDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 100, GraphQLParser.RULE_argumentsDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 478;
	        this.match(GraphQLParser.T__5);
	        this.state = 480;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 479;
	          this.inputValueDefinition();
	          this.state = 482;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32 | 1 << GraphQLParser.NAME - 32 | 1 << GraphQLParser.STRING - 32 | 1 << GraphQLParser.BLOCK_STRING - 32)) !== 0);

	        this.state = 484;
	        this.match(GraphQLParser.T__6);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputValueDefinition",
	    value: function inputValueDefinition() {
	      var localctx = new InputValueDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 102, GraphQLParser.RULE_inputValueDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 487;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 486;
	          this.description();
	        }

	        this.state = 489;
	        this.name();
	        this.state = 490;
	        this.match(GraphQLParser.T__7);
	        this.state = 491;
	        this.type_();
	        this.state = 493;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__17) {
	          this.state = 492;
	          this.defaultValue();
	        }

	        this.state = 496;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 495;
	          this.directives();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "objectTypeExtension",
	    value: function objectTypeExtension() {
	      var localctx = new ObjectTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 104, GraphQLParser.RULE_objectTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 522;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 61, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 498;
	            this.match(GraphQLParser.T__21);
	            this.state = 499;
	            this.match(GraphQLParser.T__23);
	            this.state = 500;
	            this.name();
	            this.state = 502;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__24) {
	              this.state = 501;
	              this.implementsInterfaces();
	            }

	            this.state = 505;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__19) {
	              this.state = 504;
	              this.directives();
	            }

	            this.state = 507;
	            this.fieldsDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 509;
	            this.match(GraphQLParser.T__21);
	            this.state = 510;
	            this.match(GraphQLParser.T__23);
	            this.state = 511;
	            this.name();
	            this.state = 513;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__24) {
	              this.state = 512;
	              this.implementsInterfaces();
	            }

	            this.state = 515;
	            this.directives();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 517;
	            this.match(GraphQLParser.T__21);
	            this.state = 518;
	            this.match(GraphQLParser.T__23);
	            this.state = 519;
	            this.name();
	            this.state = 520;
	            this.implementsInterfaces();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "interfaceTypeDefinition",
	    value: function interfaceTypeDefinition() {
	      var localctx = new InterfaceTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 106, GraphQLParser.RULE_interfaceTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 525;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 524;
	          this.description();
	        }

	        this.state = 527;
	        this.match(GraphQLParser.T__26);
	        this.state = 528;
	        this.name();
	        this.state = 530;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__24) {
	          this.state = 529;
	          this.implementsInterfaces();
	        }

	        this.state = 533;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 532;
	          this.directives();
	        }

	        this.state = 536;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 65, this._ctx);

	        if (la_ === 1) {
	          this.state = 535;
	          this.fieldsDefinition();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "interfaceTypeExtension",
	    value: function interfaceTypeExtension() {
	      var localctx = new InterfaceTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 108, GraphQLParser.RULE_interfaceTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 562;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 69, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 538;
	            this.match(GraphQLParser.T__21);
	            this.state = 539;
	            this.match(GraphQLParser.T__26);
	            this.state = 540;
	            this.name();
	            this.state = 542;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__24) {
	              this.state = 541;
	              this.implementsInterfaces();
	            }

	            this.state = 545;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__19) {
	              this.state = 544;
	              this.directives();
	            }

	            this.state = 547;
	            this.fieldsDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 549;
	            this.match(GraphQLParser.T__21);
	            this.state = 550;
	            this.match(GraphQLParser.T__26);
	            this.state = 551;
	            this.name();
	            this.state = 553;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__24) {
	              this.state = 552;
	              this.implementsInterfaces();
	            }

	            this.state = 555;
	            this.directives();
	            break;

	          case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 557;
	            this.match(GraphQLParser.T__21);
	            this.state = 558;
	            this.match(GraphQLParser.T__26);
	            this.state = 559;
	            this.name();
	            this.state = 560;
	            this.implementsInterfaces();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "unionTypeDefinition",
	    value: function unionTypeDefinition() {
	      var localctx = new UnionTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 110, GraphQLParser.RULE_unionTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 565;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 564;
	          this.description();
	        }

	        this.state = 567;
	        this.match(GraphQLParser.T__27);
	        this.state = 568;
	        this.name();
	        this.state = 570;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 569;
	          this.directives();
	        }

	        this.state = 573;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__17) {
	          this.state = 572;
	          this.unionMemberTypes();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "unionMemberTypes",
	    value: function unionMemberTypes() {
	      var localctx = new UnionMemberTypesContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 112, GraphQLParser.RULE_unionMemberTypes);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 575;
	        this.match(GraphQLParser.T__17);
	        this.state = 577;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__28) {
	          this.state = 576;
	          this.match(GraphQLParser.T__28);
	        }

	        this.state = 579;
	        this.namedType();
	        this.state = 584;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLParser.T__28) {
	          this.state = 580;
	          this.match(GraphQLParser.T__28);
	          this.state = 581;
	          this.namedType();
	          this.state = 586;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "unionTypeExtension",
	    value: function unionTypeExtension() {
	      var localctx = new UnionTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 114, GraphQLParser.RULE_unionTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 600;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 76, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 587;
	            this.match(GraphQLParser.T__21);
	            this.state = 588;
	            this.match(GraphQLParser.T__27);
	            this.state = 589;
	            this.name();
	            this.state = 591;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__19) {
	              this.state = 590;
	              this.directives();
	            }

	            this.state = 593;
	            this.unionMemberTypes();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 595;
	            this.match(GraphQLParser.T__21);
	            this.state = 596;
	            this.match(GraphQLParser.T__27);
	            this.state = 597;
	            this.name();
	            this.state = 598;
	            this.directives();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumTypeDefinition",
	    value: function enumTypeDefinition() {
	      var localctx = new EnumTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 116, GraphQLParser.RULE_enumTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 603;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 602;
	          this.description();
	        }

	        this.state = 605;
	        this.match(GraphQLParser.T__29);
	        this.state = 606;
	        this.name();
	        this.state = 608;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 607;
	          this.directives();
	        }

	        this.state = 611;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 79, this._ctx);

	        if (la_ === 1) {
	          this.state = 610;
	          this.enumValuesDefinition();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValuesDefinition",
	    value: function enumValuesDefinition() {
	      var localctx = new EnumValuesDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 118, GraphQLParser.RULE_enumValuesDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 613;
	        this.match(GraphQLParser.T__3);
	        this.state = 615;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 614;
	          this.enumValueDefinition();
	          this.state = 617;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32 | 1 << GraphQLParser.NAME - 32 | 1 << GraphQLParser.STRING - 32 | 1 << GraphQLParser.BLOCK_STRING - 32)) !== 0);

	        this.state = 619;
	        this.match(GraphQLParser.T__4);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumValueDefinition",
	    value: function enumValueDefinition() {
	      var localctx = new EnumValueDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 120, GraphQLParser.RULE_enumValueDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 622;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 621;
	          this.description();
	        }

	        this.state = 624;
	        this.enumValue();
	        this.state = 626;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 625;
	          this.directives();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "enumTypeExtension",
	    value: function enumTypeExtension() {
	      var localctx = new EnumTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 122, GraphQLParser.RULE_enumTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 641;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 84, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 628;
	            this.match(GraphQLParser.T__21);
	            this.state = 629;
	            this.match(GraphQLParser.T__29);
	            this.state = 630;
	            this.name();
	            this.state = 632;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__19) {
	              this.state = 631;
	              this.directives();
	            }

	            this.state = 634;
	            this.enumValuesDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 636;
	            this.match(GraphQLParser.T__21);
	            this.state = 637;
	            this.match(GraphQLParser.T__29);
	            this.state = 638;
	            this.name();
	            this.state = 639;
	            this.directives();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputObjectTypeDefinition",
	    value: function inputObjectTypeDefinition() {
	      var localctx = new InputObjectTypeDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 124, GraphQLParser.RULE_inputObjectTypeDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 644;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 643;
	          this.description();
	        }

	        this.state = 646;
	        this.match(GraphQLParser.T__30);
	        this.state = 647;
	        this.name();
	        this.state = 649;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__19) {
	          this.state = 648;
	          this.directives();
	        }

	        this.state = 652;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 87, this._ctx);

	        if (la_ === 1) {
	          this.state = 651;
	          this.inputFieldsDefinition();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputFieldsDefinition",
	    value: function inputFieldsDefinition() {
	      var localctx = new InputFieldsDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 126, GraphQLParser.RULE_inputFieldsDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 654;
	        this.match(GraphQLParser.T__3);
	        this.state = 656;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        do {
	          this.state = 655;
	          this.inputValueDefinition();
	          this.state = 658;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        } while ((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32 | 1 << GraphQLParser.NAME - 32 | 1 << GraphQLParser.STRING - 32 | 1 << GraphQLParser.BLOCK_STRING - 32)) !== 0);

	        this.state = 660;
	        this.match(GraphQLParser.T__4);
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "inputObjectTypeExtension",
	    value: function inputObjectTypeExtension() {
	      var localctx = new InputObjectTypeExtensionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 128, GraphQLParser.RULE_inputObjectTypeExtension);
	      var _la = 0; // Token type

	      try {
	        this.state = 675;

	        this._errHandler.sync(this);

	        var la_ = this._interp.adaptivePredict(this._input, 90, this._ctx);

	        switch (la_) {
	          case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 662;
	            this.match(GraphQLParser.T__21);
	            this.state = 663;
	            this.match(GraphQLParser.T__30);
	            this.state = 664;
	            this.name();
	            this.state = 666;

	            this._errHandler.sync(this);

	            _la = this._input.LA(1);

	            if (_la === GraphQLParser.T__19) {
	              this.state = 665;
	              this.directives();
	            }

	            this.state = 668;
	            this.inputFieldsDefinition();
	            break;

	          case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 670;
	            this.match(GraphQLParser.T__21);
	            this.state = 671;
	            this.match(GraphQLParser.T__30);
	            this.state = 672;
	            this.name();
	            this.state = 673;
	            this.directives();
	            break;
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directiveDefinition",
	    value: function directiveDefinition() {
	      var localctx = new DirectiveDefinitionContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 130, GraphQLParser.RULE_directiveDefinition);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 678;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.STRING || _la === GraphQLParser.BLOCK_STRING) {
	          this.state = 677;
	          this.description();
	        }

	        this.state = 680;
	        this.match(GraphQLParser.T__31);
	        this.state = 681;
	        this.match(GraphQLParser.T__19);
	        this.state = 682;
	        this.name();
	        this.state = 684;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__5) {
	          this.state = 683;
	          this.argumentsDefinition();
	        }

	        this.state = 687;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        if (_la === GraphQLParser.T__32) {
	          this.state = 686;
	          this.match(GraphQLParser.T__32);
	        }

	        this.state = 689;
	        this.match(GraphQLParser.T__10);
	        this.state = 690;
	        this.directiveLocations();
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directiveLocations",
	    value: function directiveLocations() {
	      var localctx = new DirectiveLocationsContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 132, GraphQLParser.RULE_directiveLocations);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 692;
	        this.directiveLocation();
	        this.state = 697;

	        this._errHandler.sync(this);

	        _la = this._input.LA(1);

	        while (_la === GraphQLParser.T__28) {
	          this.state = 693;
	          this.match(GraphQLParser.T__28);
	          this.state = 694;
	          this.directiveLocation();
	          this.state = 699;

	          this._errHandler.sync(this);

	          _la = this._input.LA(1);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "directiveLocation",
	    value: function directiveLocation() {
	      var localctx = new DirectiveLocationContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 134, GraphQLParser.RULE_directiveLocation);

	      try {
	        this.state = 702;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLParser.T__33:
	          case GraphQLParser.T__34:
	          case GraphQLParser.T__35:
	          case GraphQLParser.T__36:
	          case GraphQLParser.T__37:
	          case GraphQLParser.T__38:
	          case GraphQLParser.T__39:
	          case GraphQLParser.T__40:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 700;
	            this.executableDirectiveLocation();
	            break;

	          case GraphQLParser.T__41:
	          case GraphQLParser.T__42:
	          case GraphQLParser.T__43:
	          case GraphQLParser.T__44:
	          case GraphQLParser.T__45:
	          case GraphQLParser.T__46:
	          case GraphQLParser.T__47:
	          case GraphQLParser.T__48:
	          case GraphQLParser.T__49:
	          case GraphQLParser.T__50:
	          case GraphQLParser.T__51:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 701;
	            this.typeSystemDirectiveLocation();
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "executableDirectiveLocation",
	    value: function executableDirectiveLocation() {
	      var localctx = new ExecutableDirectiveLocationContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 136, GraphQLParser.RULE_executableDirectiveLocation);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 704;
	        _la = this._input.LA(1);

	        if (!((_la - 34 & ~0x1f) == 0 && (1 << _la - 34 & (1 << GraphQLParser.T__33 - 34 | 1 << GraphQLParser.T__34 - 34 | 1 << GraphQLParser.T__35 - 34 | 1 << GraphQLParser.T__36 - 34 | 1 << GraphQLParser.T__37 - 34 | 1 << GraphQLParser.T__38 - 34 | 1 << GraphQLParser.T__39 - 34 | 1 << GraphQLParser.T__40 - 34)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "typeSystemDirectiveLocation",
	    value: function typeSystemDirectiveLocation() {
	      var localctx = new TypeSystemDirectiveLocationContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 138, GraphQLParser.RULE_typeSystemDirectiveLocation);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 706;
	        _la = this._input.LA(1);

	        if (!((_la - 42 & ~0x1f) == 0 && (1 << _la - 42 & (1 << GraphQLParser.T__41 - 42 | 1 << GraphQLParser.T__42 - 42 | 1 << GraphQLParser.T__43 - 42 | 1 << GraphQLParser.T__44 - 42 | 1 << GraphQLParser.T__45 - 42 | 1 << GraphQLParser.T__46 - 42 | 1 << GraphQLParser.T__47 - 42 | 1 << GraphQLParser.T__48 - 42 | 1 << GraphQLParser.T__49 - 42 | 1 << GraphQLParser.T__50 - 42 | 1 << GraphQLParser.T__51 - 42)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      var localctx = new NameContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 140, GraphQLParser.RULE_name);

	      try {
	        this.state = 710;

	        this._errHandler.sync(this);

	        switch (this._input.LA(1)) {
	          case GraphQLParser.T__0:
	          case GraphQLParser.T__1:
	          case GraphQLParser.T__2:
	          case GraphQLParser.T__9:
	          case GraphQLParser.T__20:
	          case GraphQLParser.T__21:
	          case GraphQLParser.T__22:
	          case GraphQLParser.T__23:
	          case GraphQLParser.T__24:
	          case GraphQLParser.T__26:
	          case GraphQLParser.T__27:
	          case GraphQLParser.T__29:
	          case GraphQLParser.T__30:
	          case GraphQLParser.T__31:
	          case GraphQLParser.T__32:
	          case GraphQLParser.T__33:
	          case GraphQLParser.T__34:
	          case GraphQLParser.T__35:
	          case GraphQLParser.T__36:
	          case GraphQLParser.T__37:
	          case GraphQLParser.T__38:
	          case GraphQLParser.T__39:
	          case GraphQLParser.T__40:
	          case GraphQLParser.T__41:
	          case GraphQLParser.T__42:
	          case GraphQLParser.T__43:
	          case GraphQLParser.T__44:
	          case GraphQLParser.T__45:
	          case GraphQLParser.T__46:
	          case GraphQLParser.T__47:
	          case GraphQLParser.T__48:
	          case GraphQLParser.T__49:
	          case GraphQLParser.T__50:
	          case GraphQLParser.T__51:
	          case GraphQLParser.T__52:
	          case GraphQLParser.T__53:
	          case GraphQLParser.T__54:
	          case GraphQLParser.T__55:
	          case GraphQLParser.T__56:
	          case GraphQLParser.T__57:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 708;
	            this.keyword();
	            break;

	          case GraphQLParser.NAME:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 709;
	            this.match(GraphQLParser.NAME);
	            break;

	          default:
	            throw new _antlr["default"].error.NoViableAltException(this);
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }, {
	    key: "keyword",
	    value: function keyword() {
	      var localctx = new KeywordContext(this, this._ctx, this.state);
	      this.enterRule(localctx, 142, GraphQLParser.RULE_keyword);
	      var _la = 0; // Token type

	      try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 712;
	        _la = this._input.LA(1);

	        if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << GraphQLParser.T__0 | 1 << GraphQLParser.T__1 | 1 << GraphQLParser.T__2 | 1 << GraphQLParser.T__9 | 1 << GraphQLParser.T__20 | 1 << GraphQLParser.T__21 | 1 << GraphQLParser.T__22 | 1 << GraphQLParser.T__23 | 1 << GraphQLParser.T__24 | 1 << GraphQLParser.T__26 | 1 << GraphQLParser.T__27 | 1 << GraphQLParser.T__29 | 1 << GraphQLParser.T__30)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << GraphQLParser.T__31 - 32 | 1 << GraphQLParser.T__32 - 32 | 1 << GraphQLParser.T__33 - 32 | 1 << GraphQLParser.T__34 - 32 | 1 << GraphQLParser.T__35 - 32 | 1 << GraphQLParser.T__36 - 32 | 1 << GraphQLParser.T__37 - 32 | 1 << GraphQLParser.T__38 - 32 | 1 << GraphQLParser.T__39 - 32 | 1 << GraphQLParser.T__40 - 32 | 1 << GraphQLParser.T__41 - 32 | 1 << GraphQLParser.T__42 - 32 | 1 << GraphQLParser.T__43 - 32 | 1 << GraphQLParser.T__44 - 32 | 1 << GraphQLParser.T__45 - 32 | 1 << GraphQLParser.T__46 - 32 | 1 << GraphQLParser.T__47 - 32 | 1 << GraphQLParser.T__48 - 32 | 1 << GraphQLParser.T__49 - 32 | 1 << GraphQLParser.T__50 - 32 | 1 << GraphQLParser.T__51 - 32 | 1 << GraphQLParser.T__52 - 32 | 1 << GraphQLParser.T__53 - 32 | 1 << GraphQLParser.T__54 - 32 | 1 << GraphQLParser.T__55 - 32 | 1 << GraphQLParser.T__56 - 32 | 1 << GraphQLParser.T__57 - 32)) !== 0)) {
	          this._errHandler.recoverInline(this);
	        } else {
	          this._errHandler.reportMatch(this);

	          this.consume();
	        }
	      } catch (re) {
	        if (re instanceof _antlr["default"].error.RecognitionException) {
	          localctx.exception = re;

	          this._errHandler.reportError(this, re);

	          this._errHandler.recover(this, re);
	        } else {
	          throw re;
	        }
	      } finally {
	        this.exitRule();
	      }

	      return localctx;
	    }
	  }]);

	  return GraphQLParser;
	}(_antlr["default"].Parser);

	exports["default"] = GraphQLParser;

	_defineProperty(GraphQLParser, "grammarFileName", "GraphQL.g4");

	_defineProperty(GraphQLParser, "literalNames", [null, "'query'", "'mutation'", "'subscription'", "'{'", "'}'", "'('", "')'", "':'", "'...'", "'fragment'", "'on'", "'true'", "'false'", "'null'", "'['", "']'", "'$'", "'='", "'!'", "'@'", "'schema'", "'extend'", "'scalar'", "'type'", "'implements'", "'&'", "'interface'", "'union'", "'|'", "'enum'", "'input'", "'directive'", "'repeatable'", "'QUERY'", "'MUTATION'", "'SUBSCRIPTION'", "'FIELD'", "'FRAGMENT_DEFINITION'", "'FRAGMENT_SPREAD'", "'INLINE_FRAGMENT'", "'VARIABLE_DEFINITION'", "'SCHEMA'", "'SCALAR'", "'OBJECT'", "'FIELD_DEFINITION'", "'ARGUMENT_DEFINITION'", "'INTERFACE'", "'UNION'", "'ENUM'", "'ENUM_VALUE'", "'INPUT_OBJECT'", "'INPUT_FIELD_DEFINITION'", "'INPUT'", "'TYPE'", "'DIRECTIVE'", "'EXTEND'", "'IMPLEMENTS'", "'FRAGMENT'", null, null, null, null, null, null, null, null, "','", null, null, "'\uEFBBBF'", "'\uFEFF'", "'\0FEFF'"]);

	_defineProperty(GraphQLParser, "symbolicNames", [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "NAME", "STRING", "BLOCK_STRING", "ID", "FLOAT", "INT", "PUNCTUATOR", "WS", "COMMA", "LineComment", "UNICODE_BOM", "UTF8_BOM", "UTF16_BOM", "UTF32_BOM"]);

	_defineProperty(GraphQLParser, "ruleNames", ["document", "definition", "executableDefinition", "operationDefinition", "operationType", "selectionSet", "selection", "field", "arguments", "argument", "alias", "fragmentSpread", "fragmentDefinition", "fragmentName", "typeCondition", "inlineFragment", "value", "intValue", "floatValue", "booleanValue", "stringValue", "nullValue", "enumValue", "listValue", "objectValue", "objectField", "variable", "variableDefinitions", "variableDefinition", "defaultValue", "type_", "namedType", "listType", "directives", "directive", "typeSystemDefinition", "typeSystemExtension", "schemaDefinition", "rootOperationTypeDefinition", "schemaExtension", "operationTypeDefinition", "description", "typeDefinition", "typeExtension", "scalarTypeDefinition", "scalarTypeExtension", "objectTypeDefinition", "implementsInterfaces", "fieldsDefinition", "fieldDefinition", "argumentsDefinition", "inputValueDefinition", "objectTypeExtension", "interfaceTypeDefinition", "interfaceTypeExtension", "unionTypeDefinition", "unionMemberTypes", "unionTypeExtension", "enumTypeDefinition", "enumValuesDefinition", "enumValueDefinition", "enumTypeExtension", "inputObjectTypeDefinition", "inputFieldsDefinition", "inputObjectTypeExtension", "directiveDefinition", "directiveLocations", "directiveLocation", "executableDirectiveLocation", "typeSystemDirectiveLocation", "name", "keyword"]);

	GraphQLParser.EOF = _antlr["default"].Token.EOF;
	GraphQLParser.T__0 = 1;
	GraphQLParser.T__1 = 2;
	GraphQLParser.T__2 = 3;
	GraphQLParser.T__3 = 4;
	GraphQLParser.T__4 = 5;
	GraphQLParser.T__5 = 6;
	GraphQLParser.T__6 = 7;
	GraphQLParser.T__7 = 8;
	GraphQLParser.T__8 = 9;
	GraphQLParser.T__9 = 10;
	GraphQLParser.T__10 = 11;
	GraphQLParser.T__11 = 12;
	GraphQLParser.T__12 = 13;
	GraphQLParser.T__13 = 14;
	GraphQLParser.T__14 = 15;
	GraphQLParser.T__15 = 16;
	GraphQLParser.T__16 = 17;
	GraphQLParser.T__17 = 18;
	GraphQLParser.T__18 = 19;
	GraphQLParser.T__19 = 20;
	GraphQLParser.T__20 = 21;
	GraphQLParser.T__21 = 22;
	GraphQLParser.T__22 = 23;
	GraphQLParser.T__23 = 24;
	GraphQLParser.T__24 = 25;
	GraphQLParser.T__25 = 26;
	GraphQLParser.T__26 = 27;
	GraphQLParser.T__27 = 28;
	GraphQLParser.T__28 = 29;
	GraphQLParser.T__29 = 30;
	GraphQLParser.T__30 = 31;
	GraphQLParser.T__31 = 32;
	GraphQLParser.T__32 = 33;
	GraphQLParser.T__33 = 34;
	GraphQLParser.T__34 = 35;
	GraphQLParser.T__35 = 36;
	GraphQLParser.T__36 = 37;
	GraphQLParser.T__37 = 38;
	GraphQLParser.T__38 = 39;
	GraphQLParser.T__39 = 40;
	GraphQLParser.T__40 = 41;
	GraphQLParser.T__41 = 42;
	GraphQLParser.T__42 = 43;
	GraphQLParser.T__43 = 44;
	GraphQLParser.T__44 = 45;
	GraphQLParser.T__45 = 46;
	GraphQLParser.T__46 = 47;
	GraphQLParser.T__47 = 48;
	GraphQLParser.T__48 = 49;
	GraphQLParser.T__49 = 50;
	GraphQLParser.T__50 = 51;
	GraphQLParser.T__51 = 52;
	GraphQLParser.T__52 = 53;
	GraphQLParser.T__53 = 54;
	GraphQLParser.T__54 = 55;
	GraphQLParser.T__55 = 56;
	GraphQLParser.T__56 = 57;
	GraphQLParser.T__57 = 58;
	GraphQLParser.NAME = 59;
	GraphQLParser.STRING = 60;
	GraphQLParser.BLOCK_STRING = 61;
	GraphQLParser.ID = 62;
	GraphQLParser.FLOAT = 63;
	GraphQLParser.INT = 64;
	GraphQLParser.PUNCTUATOR = 65;
	GraphQLParser.WS = 66;
	GraphQLParser.COMMA = 67;
	GraphQLParser.LineComment = 68;
	GraphQLParser.UNICODE_BOM = 69;
	GraphQLParser.UTF8_BOM = 70;
	GraphQLParser.UTF16_BOM = 71;
	GraphQLParser.UTF32_BOM = 72;
	GraphQLParser.RULE_document = 0;
	GraphQLParser.RULE_definition = 1;
	GraphQLParser.RULE_executableDefinition = 2;
	GraphQLParser.RULE_operationDefinition = 3;
	GraphQLParser.RULE_operationType = 4;
	GraphQLParser.RULE_selectionSet = 5;
	GraphQLParser.RULE_selection = 6;
	GraphQLParser.RULE_field = 7;
	GraphQLParser.RULE_arguments = 8;
	GraphQLParser.RULE_argument = 9;
	GraphQLParser.RULE_alias = 10;
	GraphQLParser.RULE_fragmentSpread = 11;
	GraphQLParser.RULE_fragmentDefinition = 12;
	GraphQLParser.RULE_fragmentName = 13;
	GraphQLParser.RULE_typeCondition = 14;
	GraphQLParser.RULE_inlineFragment = 15;
	GraphQLParser.RULE_value = 16;
	GraphQLParser.RULE_intValue = 17;
	GraphQLParser.RULE_floatValue = 18;
	GraphQLParser.RULE_booleanValue = 19;
	GraphQLParser.RULE_stringValue = 20;
	GraphQLParser.RULE_nullValue = 21;
	GraphQLParser.RULE_enumValue = 22;
	GraphQLParser.RULE_listValue = 23;
	GraphQLParser.RULE_objectValue = 24;
	GraphQLParser.RULE_objectField = 25;
	GraphQLParser.RULE_variable = 26;
	GraphQLParser.RULE_variableDefinitions = 27;
	GraphQLParser.RULE_variableDefinition = 28;
	GraphQLParser.RULE_defaultValue = 29;
	GraphQLParser.RULE_type_ = 30;
	GraphQLParser.RULE_namedType = 31;
	GraphQLParser.RULE_listType = 32;
	GraphQLParser.RULE_directives = 33;
	GraphQLParser.RULE_directive = 34;
	GraphQLParser.RULE_typeSystemDefinition = 35;
	GraphQLParser.RULE_typeSystemExtension = 36;
	GraphQLParser.RULE_schemaDefinition = 37;
	GraphQLParser.RULE_rootOperationTypeDefinition = 38;
	GraphQLParser.RULE_schemaExtension = 39;
	GraphQLParser.RULE_operationTypeDefinition = 40;
	GraphQLParser.RULE_description = 41;
	GraphQLParser.RULE_typeDefinition = 42;
	GraphQLParser.RULE_typeExtension = 43;
	GraphQLParser.RULE_scalarTypeDefinition = 44;
	GraphQLParser.RULE_scalarTypeExtension = 45;
	GraphQLParser.RULE_objectTypeDefinition = 46;
	GraphQLParser.RULE_implementsInterfaces = 47;
	GraphQLParser.RULE_fieldsDefinition = 48;
	GraphQLParser.RULE_fieldDefinition = 49;
	GraphQLParser.RULE_argumentsDefinition = 50;
	GraphQLParser.RULE_inputValueDefinition = 51;
	GraphQLParser.RULE_objectTypeExtension = 52;
	GraphQLParser.RULE_interfaceTypeDefinition = 53;
	GraphQLParser.RULE_interfaceTypeExtension = 54;
	GraphQLParser.RULE_unionTypeDefinition = 55;
	GraphQLParser.RULE_unionMemberTypes = 56;
	GraphQLParser.RULE_unionTypeExtension = 57;
	GraphQLParser.RULE_enumTypeDefinition = 58;
	GraphQLParser.RULE_enumValuesDefinition = 59;
	GraphQLParser.RULE_enumValueDefinition = 60;
	GraphQLParser.RULE_enumTypeExtension = 61;
	GraphQLParser.RULE_inputObjectTypeDefinition = 62;
	GraphQLParser.RULE_inputFieldsDefinition = 63;
	GraphQLParser.RULE_inputObjectTypeExtension = 64;
	GraphQLParser.RULE_directiveDefinition = 65;
	GraphQLParser.RULE_directiveLocations = 66;
	GraphQLParser.RULE_directiveLocation = 67;
	GraphQLParser.RULE_executableDirectiveLocation = 68;
	GraphQLParser.RULE_typeSystemDirectiveLocation = 69;
	GraphQLParser.RULE_name = 70;
	GraphQLParser.RULE_keyword = 71;

	var DocumentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon) {
	  _inherits(DocumentContext, _antlr4$ParserRuleCon);

	  var _super2 = _createSuper(DocumentContext);

	  function DocumentContext(parser, parent, invokingState) {
	    var _this2;

	    _classCallCheck(this, DocumentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this2 = _super2.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this2), "definition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(DefinitionContext);
	      } else {
	        return this.getTypedRuleContext(DefinitionContext, i);
	      }
	    });

	    _this2.parser = parser;
	    _this2.ruleIndex = GraphQLParser.RULE_document;
	    return _this2;
	  }

	  _createClass(DocumentContext, [{
	    key: "EOF",
	    value: function EOF() {
	      return this.getToken(GraphQLParser.EOF, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDocument(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDocument(this);
	      }
	    }
	  }]);

	  return DocumentContext;
	}(_antlr["default"].ParserRuleContext);

	var DefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon2) {
	  _inherits(DefinitionContext, _antlr4$ParserRuleCon2);

	  var _super3 = _createSuper(DefinitionContext);

	  function DefinitionContext(parser, parent, invokingState) {
	    var _this3;

	    _classCallCheck(this, DefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this3 = _super3.call(this, parent, invokingState);
	    _this3.parser = parser;
	    _this3.ruleIndex = GraphQLParser.RULE_definition;
	    return _this3;
	  }

	  _createClass(DefinitionContext, [{
	    key: "executableDefinition",
	    value: function executableDefinition() {
	      return this.getTypedRuleContext(ExecutableDefinitionContext, 0);
	    }
	  }, {
	    key: "typeSystemDefinition",
	    value: function typeSystemDefinition() {
	      return this.getTypedRuleContext(TypeSystemDefinitionContext, 0);
	    }
	  }, {
	    key: "typeSystemExtension",
	    value: function typeSystemExtension() {
	      return this.getTypedRuleContext(TypeSystemExtensionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDefinition(this);
	      }
	    }
	  }]);

	  return DefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ExecutableDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon3) {
	  _inherits(ExecutableDefinitionContext, _antlr4$ParserRuleCon3);

	  var _super4 = _createSuper(ExecutableDefinitionContext);

	  function ExecutableDefinitionContext(parser, parent, invokingState) {
	    var _this4;

	    _classCallCheck(this, ExecutableDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this4 = _super4.call(this, parent, invokingState);
	    _this4.parser = parser;
	    _this4.ruleIndex = GraphQLParser.RULE_executableDefinition;
	    return _this4;
	  }

	  _createClass(ExecutableDefinitionContext, [{
	    key: "operationDefinition",
	    value: function operationDefinition() {
	      return this.getTypedRuleContext(OperationDefinitionContext, 0);
	    }
	  }, {
	    key: "fragmentDefinition",
	    value: function fragmentDefinition() {
	      return this.getTypedRuleContext(FragmentDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterExecutableDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitExecutableDefinition(this);
	      }
	    }
	  }]);

	  return ExecutableDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var OperationDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon4) {
	  _inherits(OperationDefinitionContext, _antlr4$ParserRuleCon4);

	  var _super5 = _createSuper(OperationDefinitionContext);

	  function OperationDefinitionContext(parser, parent, invokingState) {
	    var _this5;

	    _classCallCheck(this, OperationDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this5 = _super5.call(this, parent, invokingState);
	    _this5.parser = parser;
	    _this5.ruleIndex = GraphQLParser.RULE_operationDefinition;
	    return _this5;
	  }

	  _createClass(OperationDefinitionContext, [{
	    key: "operationType",
	    value: function operationType() {
	      return this.getTypedRuleContext(OperationTypeContext, 0);
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      return this.getTypedRuleContext(SelectionSetContext, 0);
	    }
	  }, {
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "variableDefinitions",
	    value: function variableDefinitions() {
	      return this.getTypedRuleContext(VariableDefinitionsContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterOperationDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitOperationDefinition(this);
	      }
	    }
	  }]);

	  return OperationDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var OperationTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon5) {
	  _inherits(OperationTypeContext, _antlr4$ParserRuleCon5);

	  var _super6 = _createSuper(OperationTypeContext);

	  function OperationTypeContext(parser, parent, invokingState) {
	    var _this6;

	    _classCallCheck(this, OperationTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this6 = _super6.call(this, parent, invokingState);
	    _this6.parser = parser;
	    _this6.ruleIndex = GraphQLParser.RULE_operationType;
	    return _this6;
	  }

	  _createClass(OperationTypeContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterOperationType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitOperationType(this);
	      }
	    }
	  }]);

	  return OperationTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var SelectionSetContext = /*#__PURE__*/function (_antlr4$ParserRuleCon6) {
	  _inherits(SelectionSetContext, _antlr4$ParserRuleCon6);

	  var _super7 = _createSuper(SelectionSetContext);

	  function SelectionSetContext(parser, parent, invokingState) {
	    var _this7;

	    _classCallCheck(this, SelectionSetContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this7 = _super7.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this7), "selection", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(SelectionContext);
	      } else {
	        return this.getTypedRuleContext(SelectionContext, i);
	      }
	    });

	    _this7.parser = parser;
	    _this7.ruleIndex = GraphQLParser.RULE_selectionSet;
	    return _this7;
	  }

	  _createClass(SelectionSetContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterSelectionSet(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitSelectionSet(this);
	      }
	    }
	  }]);

	  return SelectionSetContext;
	}(_antlr["default"].ParserRuleContext);

	var SelectionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon7) {
	  _inherits(SelectionContext, _antlr4$ParserRuleCon7);

	  var _super8 = _createSuper(SelectionContext);

	  function SelectionContext(parser, parent, invokingState) {
	    var _this8;

	    _classCallCheck(this, SelectionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this8 = _super8.call(this, parent, invokingState);
	    _this8.parser = parser;
	    _this8.ruleIndex = GraphQLParser.RULE_selection;
	    return _this8;
	  }

	  _createClass(SelectionContext, [{
	    key: "field",
	    value: function field() {
	      return this.getTypedRuleContext(FieldContext, 0);
	    }
	  }, {
	    key: "fragmentSpread",
	    value: function fragmentSpread() {
	      return this.getTypedRuleContext(FragmentSpreadContext, 0);
	    }
	  }, {
	    key: "inlineFragment",
	    value: function inlineFragment() {
	      return this.getTypedRuleContext(InlineFragmentContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterSelection(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitSelection(this);
	      }
	    }
	  }]);

	  return SelectionContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldContext = /*#__PURE__*/function (_antlr4$ParserRuleCon8) {
	  _inherits(FieldContext, _antlr4$ParserRuleCon8);

	  var _super9 = _createSuper(FieldContext);

	  function FieldContext(parser, parent, invokingState) {
	    var _this9;

	    _classCallCheck(this, FieldContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this9 = _super9.call(this, parent, invokingState);
	    _this9.parser = parser;
	    _this9.ruleIndex = GraphQLParser.RULE_field;
	    return _this9;
	  }

	  _createClass(FieldContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "alias",
	    value: function alias() {
	      return this.getTypedRuleContext(AliasContext, 0);
	    }
	  }, {
	    key: "arguments",
	    value: function _arguments() {
	      return this.getTypedRuleContext(ArgumentsContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      return this.getTypedRuleContext(SelectionSetContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterField(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitField(this);
	      }
	    }
	  }]);

	  return FieldContext;
	}(_antlr["default"].ParserRuleContext);

	var ArgumentsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon9) {
	  _inherits(ArgumentsContext, _antlr4$ParserRuleCon9);

	  var _super10 = _createSuper(ArgumentsContext);

	  function ArgumentsContext(parser, parent, invokingState) {
	    var _this10;

	    _classCallCheck(this, ArgumentsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this10 = _super10.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this10), "argument", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ArgumentContext);
	      } else {
	        return this.getTypedRuleContext(ArgumentContext, i);
	      }
	    });

	    _this10.parser = parser;
	    _this10.ruleIndex = GraphQLParser.RULE_arguments;
	    return _this10;
	  }

	  _createClass(ArgumentsContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterArguments(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitArguments(this);
	      }
	    }
	  }]);

	  return ArgumentsContext;
	}(_antlr["default"].ParserRuleContext);

	var ArgumentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon10) {
	  _inherits(ArgumentContext, _antlr4$ParserRuleCon10);

	  var _super11 = _createSuper(ArgumentContext);

	  function ArgumentContext(parser, parent, invokingState) {
	    var _this11;

	    _classCallCheck(this, ArgumentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this11 = _super11.call(this, parent, invokingState);
	    _this11.parser = parser;
	    _this11.ruleIndex = GraphQLParser.RULE_argument;
	    return _this11;
	  }

	  _createClass(ArgumentContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "value",
	    value: function value() {
	      return this.getTypedRuleContext(ValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterArgument(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitArgument(this);
	      }
	    }
	  }]);

	  return ArgumentContext;
	}(_antlr["default"].ParserRuleContext);

	var AliasContext = /*#__PURE__*/function (_antlr4$ParserRuleCon11) {
	  _inherits(AliasContext, _antlr4$ParserRuleCon11);

	  var _super12 = _createSuper(AliasContext);

	  function AliasContext(parser, parent, invokingState) {
	    var _this12;

	    _classCallCheck(this, AliasContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this12 = _super12.call(this, parent, invokingState);
	    _this12.parser = parser;
	    _this12.ruleIndex = GraphQLParser.RULE_alias;
	    return _this12;
	  }

	  _createClass(AliasContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterAlias(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitAlias(this);
	      }
	    }
	  }]);

	  return AliasContext;
	}(_antlr["default"].ParserRuleContext);

	var FragmentSpreadContext = /*#__PURE__*/function (_antlr4$ParserRuleCon12) {
	  _inherits(FragmentSpreadContext, _antlr4$ParserRuleCon12);

	  var _super13 = _createSuper(FragmentSpreadContext);

	  function FragmentSpreadContext(parser, parent, invokingState) {
	    var _this13;

	    _classCallCheck(this, FragmentSpreadContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this13 = _super13.call(this, parent, invokingState);
	    _this13.parser = parser;
	    _this13.ruleIndex = GraphQLParser.RULE_fragmentSpread;
	    return _this13;
	  }

	  _createClass(FragmentSpreadContext, [{
	    key: "fragmentName",
	    value: function fragmentName() {
	      return this.getTypedRuleContext(FragmentNameContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterFragmentSpread(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitFragmentSpread(this);
	      }
	    }
	  }]);

	  return FragmentSpreadContext;
	}(_antlr["default"].ParserRuleContext);

	var FragmentDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon13) {
	  _inherits(FragmentDefinitionContext, _antlr4$ParserRuleCon13);

	  var _super14 = _createSuper(FragmentDefinitionContext);

	  function FragmentDefinitionContext(parser, parent, invokingState) {
	    var _this14;

	    _classCallCheck(this, FragmentDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this14 = _super14.call(this, parent, invokingState);
	    _this14.parser = parser;
	    _this14.ruleIndex = GraphQLParser.RULE_fragmentDefinition;
	    return _this14;
	  }

	  _createClass(FragmentDefinitionContext, [{
	    key: "fragmentName",
	    value: function fragmentName() {
	      return this.getTypedRuleContext(FragmentNameContext, 0);
	    }
	  }, {
	    key: "typeCondition",
	    value: function typeCondition() {
	      return this.getTypedRuleContext(TypeConditionContext, 0);
	    }
	  }, {
	    key: "selectionSet",
	    value: function selectionSet() {
	      return this.getTypedRuleContext(SelectionSetContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterFragmentDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitFragmentDefinition(this);
	      }
	    }
	  }]);

	  return FragmentDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var FragmentNameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon14) {
	  _inherits(FragmentNameContext, _antlr4$ParserRuleCon14);

	  var _super15 = _createSuper(FragmentNameContext);

	  function FragmentNameContext(parser, parent, invokingState) {
	    var _this15;

	    _classCallCheck(this, FragmentNameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this15 = _super15.call(this, parent, invokingState);
	    _this15.parser = parser;
	    _this15.ruleIndex = GraphQLParser.RULE_fragmentName;
	    return _this15;
	  }

	  _createClass(FragmentNameContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterFragmentName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitFragmentName(this);
	      }
	    }
	  }]);

	  return FragmentNameContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeConditionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon15) {
	  _inherits(TypeConditionContext, _antlr4$ParserRuleCon15);

	  var _super16 = _createSuper(TypeConditionContext);

	  function TypeConditionContext(parser, parent, invokingState) {
	    var _this16;

	    _classCallCheck(this, TypeConditionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this16 = _super16.call(this, parent, invokingState);
	    _this16.parser = parser;
	    _this16.ruleIndex = GraphQLParser.RULE_typeCondition;
	    return _this16;
	  }

	  _createClass(TypeConditionContext, [{
	    key: "namedType",
	    value: function namedType() {
	      return this.getTypedRuleContext(NamedTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterTypeCondition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitTypeCondition(this);
	      }
	    }
	  }]);

	  return TypeConditionContext;
	}(_antlr["default"].ParserRuleContext);

	var InlineFragmentContext = /*#__PURE__*/function (_antlr4$ParserRuleCon16) {
	  _inherits(InlineFragmentContext, _antlr4$ParserRuleCon16);

	  var _super17 = _createSuper(InlineFragmentContext);

	  function InlineFragmentContext(parser, parent, invokingState) {
	    var _this17;

	    _classCallCheck(this, InlineFragmentContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this17 = _super17.call(this, parent, invokingState);
	    _this17.parser = parser;
	    _this17.ruleIndex = GraphQLParser.RULE_inlineFragment;
	    return _this17;
	  }

	  _createClass(InlineFragmentContext, [{
	    key: "selectionSet",
	    value: function selectionSet() {
	      return this.getTypedRuleContext(SelectionSetContext, 0);
	    }
	  }, {
	    key: "typeCondition",
	    value: function typeCondition() {
	      return this.getTypedRuleContext(TypeConditionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterInlineFragment(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitInlineFragment(this);
	      }
	    }
	  }]);

	  return InlineFragmentContext;
	}(_antlr["default"].ParserRuleContext);

	var ValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon17) {
	  _inherits(ValueContext, _antlr4$ParserRuleCon17);

	  var _super18 = _createSuper(ValueContext);

	  function ValueContext(parser, parent, invokingState) {
	    var _this18;

	    _classCallCheck(this, ValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this18 = _super18.call(this, parent, invokingState);
	    _this18.parser = parser;
	    _this18.ruleIndex = GraphQLParser.RULE_value;
	    return _this18;
	  }

	  _createClass(ValueContext, [{
	    key: "variable",
	    value: function variable() {
	      return this.getTypedRuleContext(VariableContext, 0);
	    }
	  }, {
	    key: "intValue",
	    value: function intValue() {
	      return this.getTypedRuleContext(IntValueContext, 0);
	    }
	  }, {
	    key: "floatValue",
	    value: function floatValue() {
	      return this.getTypedRuleContext(FloatValueContext, 0);
	    }
	  }, {
	    key: "stringValue",
	    value: function stringValue() {
	      return this.getTypedRuleContext(StringValueContext, 0);
	    }
	  }, {
	    key: "booleanValue",
	    value: function booleanValue() {
	      return this.getTypedRuleContext(BooleanValueContext, 0);
	    }
	  }, {
	    key: "nullValue",
	    value: function nullValue() {
	      return this.getTypedRuleContext(NullValueContext, 0);
	    }
	  }, {
	    key: "enumValue",
	    value: function enumValue() {
	      return this.getTypedRuleContext(EnumValueContext, 0);
	    }
	  }, {
	    key: "listValue",
	    value: function listValue() {
	      return this.getTypedRuleContext(ListValueContext, 0);
	    }
	  }, {
	    key: "objectValue",
	    value: function objectValue() {
	      return this.getTypedRuleContext(ObjectValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitValue(this);
	      }
	    }
	  }]);

	  return ValueContext;
	}(_antlr["default"].ParserRuleContext);

	var IntValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon18) {
	  _inherits(IntValueContext, _antlr4$ParserRuleCon18);

	  var _super19 = _createSuper(IntValueContext);

	  function IntValueContext(parser, parent, invokingState) {
	    var _this19;

	    _classCallCheck(this, IntValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this19 = _super19.call(this, parent, invokingState);
	    _this19.parser = parser;
	    _this19.ruleIndex = GraphQLParser.RULE_intValue;
	    return _this19;
	  }

	  _createClass(IntValueContext, [{
	    key: "INT",
	    value: function INT() {
	      return this.getToken(GraphQLParser.INT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterIntValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitIntValue(this);
	      }
	    }
	  }]);

	  return IntValueContext;
	}(_antlr["default"].ParserRuleContext);

	var FloatValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon19) {
	  _inherits(FloatValueContext, _antlr4$ParserRuleCon19);

	  var _super20 = _createSuper(FloatValueContext);

	  function FloatValueContext(parser, parent, invokingState) {
	    var _this20;

	    _classCallCheck(this, FloatValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this20 = _super20.call(this, parent, invokingState);
	    _this20.parser = parser;
	    _this20.ruleIndex = GraphQLParser.RULE_floatValue;
	    return _this20;
	  }

	  _createClass(FloatValueContext, [{
	    key: "FLOAT",
	    value: function FLOAT() {
	      return this.getToken(GraphQLParser.FLOAT, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterFloatValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitFloatValue(this);
	      }
	    }
	  }]);

	  return FloatValueContext;
	}(_antlr["default"].ParserRuleContext);

	var BooleanValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon20) {
	  _inherits(BooleanValueContext, _antlr4$ParserRuleCon20);

	  var _super21 = _createSuper(BooleanValueContext);

	  function BooleanValueContext(parser, parent, invokingState) {
	    var _this21;

	    _classCallCheck(this, BooleanValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this21 = _super21.call(this, parent, invokingState);
	    _this21.parser = parser;
	    _this21.ruleIndex = GraphQLParser.RULE_booleanValue;
	    return _this21;
	  }

	  _createClass(BooleanValueContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterBooleanValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitBooleanValue(this);
	      }
	    }
	  }]);

	  return BooleanValueContext;
	}(_antlr["default"].ParserRuleContext);

	var StringValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon21) {
	  _inherits(StringValueContext, _antlr4$ParserRuleCon21);

	  var _super22 = _createSuper(StringValueContext);

	  function StringValueContext(parser, parent, invokingState) {
	    var _this22;

	    _classCallCheck(this, StringValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this22 = _super22.call(this, parent, invokingState);
	    _this22.parser = parser;
	    _this22.ruleIndex = GraphQLParser.RULE_stringValue;
	    return _this22;
	  }

	  _createClass(StringValueContext, [{
	    key: "STRING",
	    value: function STRING() {
	      return this.getToken(GraphQLParser.STRING, 0);
	    }
	  }, {
	    key: "BLOCK_STRING",
	    value: function BLOCK_STRING() {
	      return this.getToken(GraphQLParser.BLOCK_STRING, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterStringValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitStringValue(this);
	      }
	    }
	  }]);

	  return StringValueContext;
	}(_antlr["default"].ParserRuleContext);

	var NullValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon22) {
	  _inherits(NullValueContext, _antlr4$ParserRuleCon22);

	  var _super23 = _createSuper(NullValueContext);

	  function NullValueContext(parser, parent, invokingState) {
	    var _this23;

	    _classCallCheck(this, NullValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this23 = _super23.call(this, parent, invokingState);
	    _this23.parser = parser;
	    _this23.ruleIndex = GraphQLParser.RULE_nullValue;
	    return _this23;
	  }

	  _createClass(NullValueContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterNullValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitNullValue(this);
	      }
	    }
	  }]);

	  return NullValueContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon23) {
	  _inherits(EnumValueContext, _antlr4$ParserRuleCon23);

	  var _super24 = _createSuper(EnumValueContext);

	  function EnumValueContext(parser, parent, invokingState) {
	    var _this24;

	    _classCallCheck(this, EnumValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this24 = _super24.call(this, parent, invokingState);
	    _this24.parser = parser;
	    _this24.ruleIndex = GraphQLParser.RULE_enumValue;
	    return _this24;
	  }

	  _createClass(EnumValueContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterEnumValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitEnumValue(this);
	      }
	    }
	  }]);

	  return EnumValueContext;
	}(_antlr["default"].ParserRuleContext);

	var ListValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon24) {
	  _inherits(ListValueContext, _antlr4$ParserRuleCon24);

	  var _super25 = _createSuper(ListValueContext);

	  function ListValueContext(parser, parent, invokingState) {
	    var _this25;

	    _classCallCheck(this, ListValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this25 = _super25.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this25), "value", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ValueContext);
	      } else {
	        return this.getTypedRuleContext(ValueContext, i);
	      }
	    });

	    _this25.parser = parser;
	    _this25.ruleIndex = GraphQLParser.RULE_listValue;
	    return _this25;
	  }

	  _createClass(ListValueContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterListValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitListValue(this);
	      }
	    }
	  }]);

	  return ListValueContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon25) {
	  _inherits(ObjectValueContext, _antlr4$ParserRuleCon25);

	  var _super26 = _createSuper(ObjectValueContext);

	  function ObjectValueContext(parser, parent, invokingState) {
	    var _this26;

	    _classCallCheck(this, ObjectValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this26 = _super26.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this26), "objectField", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(ObjectFieldContext);
	      } else {
	        return this.getTypedRuleContext(ObjectFieldContext, i);
	      }
	    });

	    _this26.parser = parser;
	    _this26.ruleIndex = GraphQLParser.RULE_objectValue;
	    return _this26;
	  }

	  _createClass(ObjectValueContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterObjectValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitObjectValue(this);
	      }
	    }
	  }]);

	  return ObjectValueContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectFieldContext = /*#__PURE__*/function (_antlr4$ParserRuleCon26) {
	  _inherits(ObjectFieldContext, _antlr4$ParserRuleCon26);

	  var _super27 = _createSuper(ObjectFieldContext);

	  function ObjectFieldContext(parser, parent, invokingState) {
	    var _this27;

	    _classCallCheck(this, ObjectFieldContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this27 = _super27.call(this, parent, invokingState);
	    _this27.parser = parser;
	    _this27.ruleIndex = GraphQLParser.RULE_objectField;
	    return _this27;
	  }

	  _createClass(ObjectFieldContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "value",
	    value: function value() {
	      return this.getTypedRuleContext(ValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterObjectField(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitObjectField(this);
	      }
	    }
	  }]);

	  return ObjectFieldContext;
	}(_antlr["default"].ParserRuleContext);

	var VariableContext = /*#__PURE__*/function (_antlr4$ParserRuleCon27) {
	  _inherits(VariableContext, _antlr4$ParserRuleCon27);

	  var _super28 = _createSuper(VariableContext);

	  function VariableContext(parser, parent, invokingState) {
	    var _this28;

	    _classCallCheck(this, VariableContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this28 = _super28.call(this, parent, invokingState);
	    _this28.parser = parser;
	    _this28.ruleIndex = GraphQLParser.RULE_variable;
	    return _this28;
	  }

	  _createClass(VariableContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterVariable(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitVariable(this);
	      }
	    }
	  }]);

	  return VariableContext;
	}(_antlr["default"].ParserRuleContext);

	var VariableDefinitionsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon28) {
	  _inherits(VariableDefinitionsContext, _antlr4$ParserRuleCon28);

	  var _super29 = _createSuper(VariableDefinitionsContext);

	  function VariableDefinitionsContext(parser, parent, invokingState) {
	    var _this29;

	    _classCallCheck(this, VariableDefinitionsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this29 = _super29.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this29), "variableDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(VariableDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(VariableDefinitionContext, i);
	      }
	    });

	    _this29.parser = parser;
	    _this29.ruleIndex = GraphQLParser.RULE_variableDefinitions;
	    return _this29;
	  }

	  _createClass(VariableDefinitionsContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterVariableDefinitions(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitVariableDefinitions(this);
	      }
	    }
	  }]);

	  return VariableDefinitionsContext;
	}(_antlr["default"].ParserRuleContext);

	var VariableDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon29) {
	  _inherits(VariableDefinitionContext, _antlr4$ParserRuleCon29);

	  var _super30 = _createSuper(VariableDefinitionContext);

	  function VariableDefinitionContext(parser, parent, invokingState) {
	    var _this30;

	    _classCallCheck(this, VariableDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this30 = _super30.call(this, parent, invokingState);
	    _this30.parser = parser;
	    _this30.ruleIndex = GraphQLParser.RULE_variableDefinition;
	    return _this30;
	  }

	  _createClass(VariableDefinitionContext, [{
	    key: "variable",
	    value: function variable() {
	      return this.getTypedRuleContext(VariableContext, 0);
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "defaultValue",
	    value: function defaultValue() {
	      return this.getTypedRuleContext(DefaultValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterVariableDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitVariableDefinition(this);
	      }
	    }
	  }]);

	  return VariableDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var DefaultValueContext = /*#__PURE__*/function (_antlr4$ParserRuleCon30) {
	  _inherits(DefaultValueContext, _antlr4$ParserRuleCon30);

	  var _super31 = _createSuper(DefaultValueContext);

	  function DefaultValueContext(parser, parent, invokingState) {
	    var _this31;

	    _classCallCheck(this, DefaultValueContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this31 = _super31.call(this, parent, invokingState);
	    _this31.parser = parser;
	    _this31.ruleIndex = GraphQLParser.RULE_defaultValue;
	    return _this31;
	  }

	  _createClass(DefaultValueContext, [{
	    key: "value",
	    value: function value() {
	      return this.getTypedRuleContext(ValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDefaultValue(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDefaultValue(this);
	      }
	    }
	  }]);

	  return DefaultValueContext;
	}(_antlr["default"].ParserRuleContext);

	var Type_Context = /*#__PURE__*/function (_antlr4$ParserRuleCon31) {
	  _inherits(Type_Context, _antlr4$ParserRuleCon31);

	  var _super32 = _createSuper(Type_Context);

	  function Type_Context(parser, parent, invokingState) {
	    var _this32;

	    _classCallCheck(this, Type_Context);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this32 = _super32.call(this, parent, invokingState);
	    _this32.parser = parser;
	    _this32.ruleIndex = GraphQLParser.RULE_type_;
	    return _this32;
	  }

	  _createClass(Type_Context, [{
	    key: "namedType",
	    value: function namedType() {
	      return this.getTypedRuleContext(NamedTypeContext, 0);
	    }
	  }, {
	    key: "listType",
	    value: function listType() {
	      return this.getTypedRuleContext(ListTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterType_(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitType_(this);
	      }
	    }
	  }]);

	  return Type_Context;
	}(_antlr["default"].ParserRuleContext);

	var NamedTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon32) {
	  _inherits(NamedTypeContext, _antlr4$ParserRuleCon32);

	  var _super33 = _createSuper(NamedTypeContext);

	  function NamedTypeContext(parser, parent, invokingState) {
	    var _this33;

	    _classCallCheck(this, NamedTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this33 = _super33.call(this, parent, invokingState);
	    _this33.parser = parser;
	    _this33.ruleIndex = GraphQLParser.RULE_namedType;
	    return _this33;
	  }

	  _createClass(NamedTypeContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterNamedType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitNamedType(this);
	      }
	    }
	  }]);

	  return NamedTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var ListTypeContext = /*#__PURE__*/function (_antlr4$ParserRuleCon33) {
	  _inherits(ListTypeContext, _antlr4$ParserRuleCon33);

	  var _super34 = _createSuper(ListTypeContext);

	  function ListTypeContext(parser, parent, invokingState) {
	    var _this34;

	    _classCallCheck(this, ListTypeContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this34 = _super34.call(this, parent, invokingState);
	    _this34.parser = parser;
	    _this34.ruleIndex = GraphQLParser.RULE_listType;
	    return _this34;
	  }

	  _createClass(ListTypeContext, [{
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterListType(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitListType(this);
	      }
	    }
	  }]);

	  return ListTypeContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectivesContext = /*#__PURE__*/function (_antlr4$ParserRuleCon34) {
	  _inherits(DirectivesContext, _antlr4$ParserRuleCon34);

	  var _super35 = _createSuper(DirectivesContext);

	  function DirectivesContext(parser, parent, invokingState) {
	    var _this35;

	    _classCallCheck(this, DirectivesContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this35 = _super35.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this35), "directive", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(DirectiveContext);
	      } else {
	        return this.getTypedRuleContext(DirectiveContext, i);
	      }
	    });

	    _this35.parser = parser;
	    _this35.ruleIndex = GraphQLParser.RULE_directives;
	    return _this35;
	  }

	  _createClass(DirectivesContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDirectives(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDirectives(this);
	      }
	    }
	  }]);

	  return DirectivesContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectiveContext = /*#__PURE__*/function (_antlr4$ParserRuleCon35) {
	  _inherits(DirectiveContext, _antlr4$ParserRuleCon35);

	  var _super36 = _createSuper(DirectiveContext);

	  function DirectiveContext(parser, parent, invokingState) {
	    var _this36;

	    _classCallCheck(this, DirectiveContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this36 = _super36.call(this, parent, invokingState);
	    _this36.parser = parser;
	    _this36.ruleIndex = GraphQLParser.RULE_directive;
	    return _this36;
	  }

	  _createClass(DirectiveContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "arguments",
	    value: function _arguments() {
	      return this.getTypedRuleContext(ArgumentsContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDirective(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDirective(this);
	      }
	    }
	  }]);

	  return DirectiveContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeSystemDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon36) {
	  _inherits(TypeSystemDefinitionContext, _antlr4$ParserRuleCon36);

	  var _super37 = _createSuper(TypeSystemDefinitionContext);

	  function TypeSystemDefinitionContext(parser, parent, invokingState) {
	    var _this37;

	    _classCallCheck(this, TypeSystemDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this37 = _super37.call(this, parent, invokingState);
	    _this37.parser = parser;
	    _this37.ruleIndex = GraphQLParser.RULE_typeSystemDefinition;
	    return _this37;
	  }

	  _createClass(TypeSystemDefinitionContext, [{
	    key: "schemaDefinition",
	    value: function schemaDefinition() {
	      return this.getTypedRuleContext(SchemaDefinitionContext, 0);
	    }
	  }, {
	    key: "typeDefinition",
	    value: function typeDefinition() {
	      return this.getTypedRuleContext(TypeDefinitionContext, 0);
	    }
	  }, {
	    key: "directiveDefinition",
	    value: function directiveDefinition() {
	      return this.getTypedRuleContext(DirectiveDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterTypeSystemDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitTypeSystemDefinition(this);
	      }
	    }
	  }]);

	  return TypeSystemDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeSystemExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon37) {
	  _inherits(TypeSystemExtensionContext, _antlr4$ParserRuleCon37);

	  var _super38 = _createSuper(TypeSystemExtensionContext);

	  function TypeSystemExtensionContext(parser, parent, invokingState) {
	    var _this38;

	    _classCallCheck(this, TypeSystemExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this38 = _super38.call(this, parent, invokingState);
	    _this38.parser = parser;
	    _this38.ruleIndex = GraphQLParser.RULE_typeSystemExtension;
	    return _this38;
	  }

	  _createClass(TypeSystemExtensionContext, [{
	    key: "schemaExtension",
	    value: function schemaExtension() {
	      return this.getTypedRuleContext(SchemaExtensionContext, 0);
	    }
	  }, {
	    key: "typeExtension",
	    value: function typeExtension() {
	      return this.getTypedRuleContext(TypeExtensionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterTypeSystemExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitTypeSystemExtension(this);
	      }
	    }
	  }]);

	  return TypeSystemExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var SchemaDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon38) {
	  _inherits(SchemaDefinitionContext, _antlr4$ParserRuleCon38);

	  var _super39 = _createSuper(SchemaDefinitionContext);

	  function SchemaDefinitionContext(parser, parent, invokingState) {
	    var _this39;

	    _classCallCheck(this, SchemaDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this39 = _super39.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this39), "rootOperationTypeDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(RootOperationTypeDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(RootOperationTypeDefinitionContext, i);
	      }
	    });

	    _this39.parser = parser;
	    _this39.ruleIndex = GraphQLParser.RULE_schemaDefinition;
	    return _this39;
	  }

	  _createClass(SchemaDefinitionContext, [{
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterSchemaDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitSchemaDefinition(this);
	      }
	    }
	  }]);

	  return SchemaDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var RootOperationTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon39) {
	  _inherits(RootOperationTypeDefinitionContext, _antlr4$ParserRuleCon39);

	  var _super40 = _createSuper(RootOperationTypeDefinitionContext);

	  function RootOperationTypeDefinitionContext(parser, parent, invokingState) {
	    var _this40;

	    _classCallCheck(this, RootOperationTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this40 = _super40.call(this, parent, invokingState);
	    _this40.parser = parser;
	    _this40.ruleIndex = GraphQLParser.RULE_rootOperationTypeDefinition;
	    return _this40;
	  }

	  _createClass(RootOperationTypeDefinitionContext, [{
	    key: "operationType",
	    value: function operationType() {
	      return this.getTypedRuleContext(OperationTypeContext, 0);
	    }
	  }, {
	    key: "namedType",
	    value: function namedType() {
	      return this.getTypedRuleContext(NamedTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterRootOperationTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitRootOperationTypeDefinition(this);
	      }
	    }
	  }]);

	  return RootOperationTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var SchemaExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon40) {
	  _inherits(SchemaExtensionContext, _antlr4$ParserRuleCon40);

	  var _super41 = _createSuper(SchemaExtensionContext);

	  function SchemaExtensionContext(parser, parent, invokingState) {
	    var _this41;

	    _classCallCheck(this, SchemaExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this41 = _super41.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this41), "operationTypeDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(OperationTypeDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(OperationTypeDefinitionContext, i);
	      }
	    });

	    _this41.parser = parser;
	    _this41.ruleIndex = GraphQLParser.RULE_schemaExtension;
	    return _this41;
	  }

	  _createClass(SchemaExtensionContext, [{
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterSchemaExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitSchemaExtension(this);
	      }
	    }
	  }]);

	  return SchemaExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var OperationTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon41) {
	  _inherits(OperationTypeDefinitionContext, _antlr4$ParserRuleCon41);

	  var _super42 = _createSuper(OperationTypeDefinitionContext);

	  function OperationTypeDefinitionContext(parser, parent, invokingState) {
	    var _this42;

	    _classCallCheck(this, OperationTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this42 = _super42.call(this, parent, invokingState);
	    _this42.parser = parser;
	    _this42.ruleIndex = GraphQLParser.RULE_operationTypeDefinition;
	    return _this42;
	  }

	  _createClass(OperationTypeDefinitionContext, [{
	    key: "operationType",
	    value: function operationType() {
	      return this.getTypedRuleContext(OperationTypeContext, 0);
	    }
	  }, {
	    key: "namedType",
	    value: function namedType() {
	      return this.getTypedRuleContext(NamedTypeContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterOperationTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitOperationTypeDefinition(this);
	      }
	    }
	  }]);

	  return OperationTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var DescriptionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon42) {
	  _inherits(DescriptionContext, _antlr4$ParserRuleCon42);

	  var _super43 = _createSuper(DescriptionContext);

	  function DescriptionContext(parser, parent, invokingState) {
	    var _this43;

	    _classCallCheck(this, DescriptionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this43 = _super43.call(this, parent, invokingState);
	    _this43.parser = parser;
	    _this43.ruleIndex = GraphQLParser.RULE_description;
	    return _this43;
	  }

	  _createClass(DescriptionContext, [{
	    key: "stringValue",
	    value: function stringValue() {
	      return this.getTypedRuleContext(StringValueContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDescription(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDescription(this);
	      }
	    }
	  }]);

	  return DescriptionContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon43) {
	  _inherits(TypeDefinitionContext, _antlr4$ParserRuleCon43);

	  var _super44 = _createSuper(TypeDefinitionContext);

	  function TypeDefinitionContext(parser, parent, invokingState) {
	    var _this44;

	    _classCallCheck(this, TypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this44 = _super44.call(this, parent, invokingState);
	    _this44.parser = parser;
	    _this44.ruleIndex = GraphQLParser.RULE_typeDefinition;
	    return _this44;
	  }

	  _createClass(TypeDefinitionContext, [{
	    key: "scalarTypeDefinition",
	    value: function scalarTypeDefinition() {
	      return this.getTypedRuleContext(ScalarTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "objectTypeDefinition",
	    value: function objectTypeDefinition() {
	      return this.getTypedRuleContext(ObjectTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "interfaceTypeDefinition",
	    value: function interfaceTypeDefinition() {
	      return this.getTypedRuleContext(InterfaceTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "unionTypeDefinition",
	    value: function unionTypeDefinition() {
	      return this.getTypedRuleContext(UnionTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "enumTypeDefinition",
	    value: function enumTypeDefinition() {
	      return this.getTypedRuleContext(EnumTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "inputObjectTypeDefinition",
	    value: function inputObjectTypeDefinition() {
	      return this.getTypedRuleContext(InputObjectTypeDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitTypeDefinition(this);
	      }
	    }
	  }]);

	  return TypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon44) {
	  _inherits(TypeExtensionContext, _antlr4$ParserRuleCon44);

	  var _super45 = _createSuper(TypeExtensionContext);

	  function TypeExtensionContext(parser, parent, invokingState) {
	    var _this45;

	    _classCallCheck(this, TypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this45 = _super45.call(this, parent, invokingState);
	    _this45.parser = parser;
	    _this45.ruleIndex = GraphQLParser.RULE_typeExtension;
	    return _this45;
	  }

	  _createClass(TypeExtensionContext, [{
	    key: "scalarTypeExtension",
	    value: function scalarTypeExtension() {
	      return this.getTypedRuleContext(ScalarTypeExtensionContext, 0);
	    }
	  }, {
	    key: "objectTypeExtension",
	    value: function objectTypeExtension() {
	      return this.getTypedRuleContext(ObjectTypeExtensionContext, 0);
	    }
	  }, {
	    key: "interfaceTypeExtension",
	    value: function interfaceTypeExtension() {
	      return this.getTypedRuleContext(InterfaceTypeExtensionContext, 0);
	    }
	  }, {
	    key: "unionTypeExtension",
	    value: function unionTypeExtension() {
	      return this.getTypedRuleContext(UnionTypeExtensionContext, 0);
	    }
	  }, {
	    key: "enumTypeExtension",
	    value: function enumTypeExtension() {
	      return this.getTypedRuleContext(EnumTypeExtensionContext, 0);
	    }
	  }, {
	    key: "inputObjectTypeExtension",
	    value: function inputObjectTypeExtension() {
	      return this.getTypedRuleContext(InputObjectTypeExtensionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitTypeExtension(this);
	      }
	    }
	  }]);

	  return TypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var ScalarTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon45) {
	  _inherits(ScalarTypeDefinitionContext, _antlr4$ParserRuleCon45);

	  var _super46 = _createSuper(ScalarTypeDefinitionContext);

	  function ScalarTypeDefinitionContext(parser, parent, invokingState) {
	    var _this46;

	    _classCallCheck(this, ScalarTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this46 = _super46.call(this, parent, invokingState);
	    _this46.parser = parser;
	    _this46.ruleIndex = GraphQLParser.RULE_scalarTypeDefinition;
	    return _this46;
	  }

	  _createClass(ScalarTypeDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterScalarTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitScalarTypeDefinition(this);
	      }
	    }
	  }]);

	  return ScalarTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ScalarTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon46) {
	  _inherits(ScalarTypeExtensionContext, _antlr4$ParserRuleCon46);

	  var _super47 = _createSuper(ScalarTypeExtensionContext);

	  function ScalarTypeExtensionContext(parser, parent, invokingState) {
	    var _this47;

	    _classCallCheck(this, ScalarTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this47 = _super47.call(this, parent, invokingState);
	    _this47.parser = parser;
	    _this47.ruleIndex = GraphQLParser.RULE_scalarTypeExtension;
	    return _this47;
	  }

	  _createClass(ScalarTypeExtensionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterScalarTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitScalarTypeExtension(this);
	      }
	    }
	  }]);

	  return ScalarTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon47) {
	  _inherits(ObjectTypeDefinitionContext, _antlr4$ParserRuleCon47);

	  var _super48 = _createSuper(ObjectTypeDefinitionContext);

	  function ObjectTypeDefinitionContext(parser, parent, invokingState) {
	    var _this48;

	    _classCallCheck(this, ObjectTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this48 = _super48.call(this, parent, invokingState);
	    _this48.parser = parser;
	    _this48.ruleIndex = GraphQLParser.RULE_objectTypeDefinition;
	    return _this48;
	  }

	  _createClass(ObjectTypeDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      return this.getTypedRuleContext(ImplementsInterfacesContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      return this.getTypedRuleContext(FieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterObjectTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitObjectTypeDefinition(this);
	      }
	    }
	  }]);

	  return ObjectTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ImplementsInterfacesContext = /*#__PURE__*/function (_antlr4$ParserRuleCon48) {
	  _inherits(ImplementsInterfacesContext, _antlr4$ParserRuleCon48);

	  var _super49 = _createSuper(ImplementsInterfacesContext);

	  function ImplementsInterfacesContext(parser, parent, invokingState) {
	    var _this49;

	    _classCallCheck(this, ImplementsInterfacesContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this49 = _super49.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this49), "namedType", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(NamedTypeContext);
	      } else {
	        return this.getTypedRuleContext(NamedTypeContext, i);
	      }
	    });

	    _this49.parser = parser;
	    _this49.ruleIndex = GraphQLParser.RULE_implementsInterfaces;
	    return _this49;
	  }

	  _createClass(ImplementsInterfacesContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterImplementsInterfaces(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitImplementsInterfaces(this);
	      }
	    }
	  }]);

	  return ImplementsInterfacesContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldsDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon49) {
	  _inherits(FieldsDefinitionContext, _antlr4$ParserRuleCon49);

	  var _super50 = _createSuper(FieldsDefinitionContext);

	  function FieldsDefinitionContext(parser, parent, invokingState) {
	    var _this50;

	    _classCallCheck(this, FieldsDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this50 = _super50.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this50), "fieldDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(FieldDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(FieldDefinitionContext, i);
	      }
	    });

	    _this50.parser = parser;
	    _this50.ruleIndex = GraphQLParser.RULE_fieldsDefinition;
	    return _this50;
	  }

	  _createClass(FieldsDefinitionContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterFieldsDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitFieldsDefinition(this);
	      }
	    }
	  }]);

	  return FieldsDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var FieldDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon50) {
	  _inherits(FieldDefinitionContext, _antlr4$ParserRuleCon50);

	  var _super51 = _createSuper(FieldDefinitionContext);

	  function FieldDefinitionContext(parser, parent, invokingState) {
	    var _this51;

	    _classCallCheck(this, FieldDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this51 = _super51.call(this, parent, invokingState);
	    _this51.parser = parser;
	    _this51.ruleIndex = GraphQLParser.RULE_fieldDefinition;
	    _this51._name = null; // NameContext

	    return _this51;
	  }

	  _createClass(FieldDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "argumentsDefinition",
	    value: function argumentsDefinition() {
	      return this.getTypedRuleContext(ArgumentsDefinitionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterFieldDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitFieldDefinition(this);
	      }
	    }
	  }]);

	  return FieldDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ArgumentsDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon51) {
	  _inherits(ArgumentsDefinitionContext, _antlr4$ParserRuleCon51);

	  var _super52 = _createSuper(ArgumentsDefinitionContext);

	  function ArgumentsDefinitionContext(parser, parent, invokingState) {
	    var _this52;

	    _classCallCheck(this, ArgumentsDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this52 = _super52.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this52), "inputValueDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InputValueDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(InputValueDefinitionContext, i);
	      }
	    });

	    _this52.parser = parser;
	    _this52.ruleIndex = GraphQLParser.RULE_argumentsDefinition;
	    return _this52;
	  }

	  _createClass(ArgumentsDefinitionContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterArgumentsDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitArgumentsDefinition(this);
	      }
	    }
	  }]);

	  return ArgumentsDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var InputValueDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon52) {
	  _inherits(InputValueDefinitionContext, _antlr4$ParserRuleCon52);

	  var _super53 = _createSuper(InputValueDefinitionContext);

	  function InputValueDefinitionContext(parser, parent, invokingState) {
	    var _this53;

	    _classCallCheck(this, InputValueDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this53 = _super53.call(this, parent, invokingState);
	    _this53.parser = parser;
	    _this53.ruleIndex = GraphQLParser.RULE_inputValueDefinition;
	    return _this53;
	  }

	  _createClass(InputValueDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "type_",
	    value: function type_() {
	      return this.getTypedRuleContext(Type_Context, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "defaultValue",
	    value: function defaultValue() {
	      return this.getTypedRuleContext(DefaultValueContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterInputValueDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitInputValueDefinition(this);
	      }
	    }
	  }]);

	  return InputValueDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var ObjectTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon53) {
	  _inherits(ObjectTypeExtensionContext, _antlr4$ParserRuleCon53);

	  var _super54 = _createSuper(ObjectTypeExtensionContext);

	  function ObjectTypeExtensionContext(parser, parent, invokingState) {
	    var _this54;

	    _classCallCheck(this, ObjectTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this54 = _super54.call(this, parent, invokingState);
	    _this54.parser = parser;
	    _this54.ruleIndex = GraphQLParser.RULE_objectTypeExtension;
	    return _this54;
	  }

	  _createClass(ObjectTypeExtensionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      return this.getTypedRuleContext(FieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      return this.getTypedRuleContext(ImplementsInterfacesContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterObjectTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitObjectTypeExtension(this);
	      }
	    }
	  }]);

	  return ObjectTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var InterfaceTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon54) {
	  _inherits(InterfaceTypeDefinitionContext, _antlr4$ParserRuleCon54);

	  var _super55 = _createSuper(InterfaceTypeDefinitionContext);

	  function InterfaceTypeDefinitionContext(parser, parent, invokingState) {
	    var _this55;

	    _classCallCheck(this, InterfaceTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this55 = _super55.call(this, parent, invokingState);
	    _this55.parser = parser;
	    _this55.ruleIndex = GraphQLParser.RULE_interfaceTypeDefinition;
	    return _this55;
	  }

	  _createClass(InterfaceTypeDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      return this.getTypedRuleContext(ImplementsInterfacesContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      return this.getTypedRuleContext(FieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterInterfaceTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitInterfaceTypeDefinition(this);
	      }
	    }
	  }]);

	  return InterfaceTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var InterfaceTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon55) {
	  _inherits(InterfaceTypeExtensionContext, _antlr4$ParserRuleCon55);

	  var _super56 = _createSuper(InterfaceTypeExtensionContext);

	  function InterfaceTypeExtensionContext(parser, parent, invokingState) {
	    var _this56;

	    _classCallCheck(this, InterfaceTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this56 = _super56.call(this, parent, invokingState);
	    _this56.parser = parser;
	    _this56.ruleIndex = GraphQLParser.RULE_interfaceTypeExtension;
	    return _this56;
	  }

	  _createClass(InterfaceTypeExtensionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "fieldsDefinition",
	    value: function fieldsDefinition() {
	      return this.getTypedRuleContext(FieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "implementsInterfaces",
	    value: function implementsInterfaces() {
	      return this.getTypedRuleContext(ImplementsInterfacesContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterInterfaceTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitInterfaceTypeExtension(this);
	      }
	    }
	  }]);

	  return InterfaceTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var UnionTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon56) {
	  _inherits(UnionTypeDefinitionContext, _antlr4$ParserRuleCon56);

	  var _super57 = _createSuper(UnionTypeDefinitionContext);

	  function UnionTypeDefinitionContext(parser, parent, invokingState) {
	    var _this57;

	    _classCallCheck(this, UnionTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this57 = _super57.call(this, parent, invokingState);
	    _this57.parser = parser;
	    _this57.ruleIndex = GraphQLParser.RULE_unionTypeDefinition;
	    return _this57;
	  }

	  _createClass(UnionTypeDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "unionMemberTypes",
	    value: function unionMemberTypes() {
	      return this.getTypedRuleContext(UnionMemberTypesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterUnionTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitUnionTypeDefinition(this);
	      }
	    }
	  }]);

	  return UnionTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var UnionMemberTypesContext = /*#__PURE__*/function (_antlr4$ParserRuleCon57) {
	  _inherits(UnionMemberTypesContext, _antlr4$ParserRuleCon57);

	  var _super58 = _createSuper(UnionMemberTypesContext);

	  function UnionMemberTypesContext(parser, parent, invokingState) {
	    var _this58;

	    _classCallCheck(this, UnionMemberTypesContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this58 = _super58.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this58), "namedType", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(NamedTypeContext);
	      } else {
	        return this.getTypedRuleContext(NamedTypeContext, i);
	      }
	    });

	    _this58.parser = parser;
	    _this58.ruleIndex = GraphQLParser.RULE_unionMemberTypes;
	    return _this58;
	  }

	  _createClass(UnionMemberTypesContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterUnionMemberTypes(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitUnionMemberTypes(this);
	      }
	    }
	  }]);

	  return UnionMemberTypesContext;
	}(_antlr["default"].ParserRuleContext);

	var UnionTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon58) {
	  _inherits(UnionTypeExtensionContext, _antlr4$ParserRuleCon58);

	  var _super59 = _createSuper(UnionTypeExtensionContext);

	  function UnionTypeExtensionContext(parser, parent, invokingState) {
	    var _this59;

	    _classCallCheck(this, UnionTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this59 = _super59.call(this, parent, invokingState);
	    _this59.parser = parser;
	    _this59.ruleIndex = GraphQLParser.RULE_unionTypeExtension;
	    return _this59;
	  }

	  _createClass(UnionTypeExtensionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "unionMemberTypes",
	    value: function unionMemberTypes() {
	      return this.getTypedRuleContext(UnionMemberTypesContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterUnionTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitUnionTypeExtension(this);
	      }
	    }
	  }]);

	  return UnionTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon59) {
	  _inherits(EnumTypeDefinitionContext, _antlr4$ParserRuleCon59);

	  var _super60 = _createSuper(EnumTypeDefinitionContext);

	  function EnumTypeDefinitionContext(parser, parent, invokingState) {
	    var _this60;

	    _classCallCheck(this, EnumTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this60 = _super60.call(this, parent, invokingState);
	    _this60.parser = parser;
	    _this60.ruleIndex = GraphQLParser.RULE_enumTypeDefinition;
	    return _this60;
	  }

	  _createClass(EnumTypeDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enumValuesDefinition",
	    value: function enumValuesDefinition() {
	      return this.getTypedRuleContext(EnumValuesDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterEnumTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitEnumTypeDefinition(this);
	      }
	    }
	  }]);

	  return EnumTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValuesDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon60) {
	  _inherits(EnumValuesDefinitionContext, _antlr4$ParserRuleCon60);

	  var _super61 = _createSuper(EnumValuesDefinitionContext);

	  function EnumValuesDefinitionContext(parser, parent, invokingState) {
	    var _this61;

	    _classCallCheck(this, EnumValuesDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this61 = _super61.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this61), "enumValueDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(EnumValueDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(EnumValueDefinitionContext, i);
	      }
	    });

	    _this61.parser = parser;
	    _this61.ruleIndex = GraphQLParser.RULE_enumValuesDefinition;
	    return _this61;
	  }

	  _createClass(EnumValuesDefinitionContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterEnumValuesDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitEnumValuesDefinition(this);
	      }
	    }
	  }]);

	  return EnumValuesDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumValueDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon61) {
	  _inherits(EnumValueDefinitionContext, _antlr4$ParserRuleCon61);

	  var _super62 = _createSuper(EnumValueDefinitionContext);

	  function EnumValueDefinitionContext(parser, parent, invokingState) {
	    var _this62;

	    _classCallCheck(this, EnumValueDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this62 = _super62.call(this, parent, invokingState);
	    _this62.parser = parser;
	    _this62.ruleIndex = GraphQLParser.RULE_enumValueDefinition;
	    return _this62;
	  }

	  _createClass(EnumValueDefinitionContext, [{
	    key: "enumValue",
	    value: function enumValue() {
	      return this.getTypedRuleContext(EnumValueContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterEnumValueDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitEnumValueDefinition(this);
	      }
	    }
	  }]);

	  return EnumValueDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var EnumTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon62) {
	  _inherits(EnumTypeExtensionContext, _antlr4$ParserRuleCon62);

	  var _super63 = _createSuper(EnumTypeExtensionContext);

	  function EnumTypeExtensionContext(parser, parent, invokingState) {
	    var _this63;

	    _classCallCheck(this, EnumTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this63 = _super63.call(this, parent, invokingState);
	    _this63.parser = parser;
	    _this63.ruleIndex = GraphQLParser.RULE_enumTypeExtension;
	    return _this63;
	  }

	  _createClass(EnumTypeExtensionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "enumValuesDefinition",
	    value: function enumValuesDefinition() {
	      return this.getTypedRuleContext(EnumValuesDefinitionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterEnumTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitEnumTypeExtension(this);
	      }
	    }
	  }]);

	  return EnumTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var InputObjectTypeDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon63) {
	  _inherits(InputObjectTypeDefinitionContext, _antlr4$ParserRuleCon63);

	  var _super64 = _createSuper(InputObjectTypeDefinitionContext);

	  function InputObjectTypeDefinitionContext(parser, parent, invokingState) {
	    var _this64;

	    _classCallCheck(this, InputObjectTypeDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this64 = _super64.call(this, parent, invokingState);
	    _this64.parser = parser;
	    _this64.ruleIndex = GraphQLParser.RULE_inputObjectTypeDefinition;
	    return _this64;
	  }

	  _createClass(InputObjectTypeDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "inputFieldsDefinition",
	    value: function inputFieldsDefinition() {
	      return this.getTypedRuleContext(InputFieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterInputObjectTypeDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitInputObjectTypeDefinition(this);
	      }
	    }
	  }]);

	  return InputObjectTypeDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var InputFieldsDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon64) {
	  _inherits(InputFieldsDefinitionContext, _antlr4$ParserRuleCon64);

	  var _super65 = _createSuper(InputFieldsDefinitionContext);

	  function InputFieldsDefinitionContext(parser, parent, invokingState) {
	    var _this65;

	    _classCallCheck(this, InputFieldsDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this65 = _super65.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this65), "inputValueDefinition", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(InputValueDefinitionContext);
	      } else {
	        return this.getTypedRuleContext(InputValueDefinitionContext, i);
	      }
	    });

	    _this65.parser = parser;
	    _this65.ruleIndex = GraphQLParser.RULE_inputFieldsDefinition;
	    return _this65;
	  }

	  _createClass(InputFieldsDefinitionContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterInputFieldsDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitInputFieldsDefinition(this);
	      }
	    }
	  }]);

	  return InputFieldsDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var InputObjectTypeExtensionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon65) {
	  _inherits(InputObjectTypeExtensionContext, _antlr4$ParserRuleCon65);

	  var _super66 = _createSuper(InputObjectTypeExtensionContext);

	  function InputObjectTypeExtensionContext(parser, parent, invokingState) {
	    var _this66;

	    _classCallCheck(this, InputObjectTypeExtensionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this66 = _super66.call(this, parent, invokingState);
	    _this66.parser = parser;
	    _this66.ruleIndex = GraphQLParser.RULE_inputObjectTypeExtension;
	    return _this66;
	  }

	  _createClass(InputObjectTypeExtensionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "inputFieldsDefinition",
	    value: function inputFieldsDefinition() {
	      return this.getTypedRuleContext(InputFieldsDefinitionContext, 0);
	    }
	  }, {
	    key: "directives",
	    value: function directives() {
	      return this.getTypedRuleContext(DirectivesContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterInputObjectTypeExtension(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitInputObjectTypeExtension(this);
	      }
	    }
	  }]);

	  return InputObjectTypeExtensionContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectiveDefinitionContext = /*#__PURE__*/function (_antlr4$ParserRuleCon66) {
	  _inherits(DirectiveDefinitionContext, _antlr4$ParserRuleCon66);

	  var _super67 = _createSuper(DirectiveDefinitionContext);

	  function DirectiveDefinitionContext(parser, parent, invokingState) {
	    var _this67;

	    _classCallCheck(this, DirectiveDefinitionContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this67 = _super67.call(this, parent, invokingState);
	    _this67.parser = parser;
	    _this67.ruleIndex = GraphQLParser.RULE_directiveDefinition;
	    return _this67;
	  }

	  _createClass(DirectiveDefinitionContext, [{
	    key: "name",
	    value: function name() {
	      return this.getTypedRuleContext(NameContext, 0);
	    }
	  }, {
	    key: "directiveLocations",
	    value: function directiveLocations() {
	      return this.getTypedRuleContext(DirectiveLocationsContext, 0);
	    }
	  }, {
	    key: "description",
	    value: function description() {
	      return this.getTypedRuleContext(DescriptionContext, 0);
	    }
	  }, {
	    key: "argumentsDefinition",
	    value: function argumentsDefinition() {
	      return this.getTypedRuleContext(ArgumentsDefinitionContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDirectiveDefinition(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDirectiveDefinition(this);
	      }
	    }
	  }]);

	  return DirectiveDefinitionContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectiveLocationsContext = /*#__PURE__*/function (_antlr4$ParserRuleCon67) {
	  _inherits(DirectiveLocationsContext, _antlr4$ParserRuleCon67);

	  var _super68 = _createSuper(DirectiveLocationsContext);

	  function DirectiveLocationsContext(parser, parent, invokingState) {
	    var _this68;

	    _classCallCheck(this, DirectiveLocationsContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this68 = _super68.call(this, parent, invokingState);

	    _defineProperty(_assertThisInitialized(_this68), "directiveLocation", function (i) {
	      if (i === undefined) {
	        i = null;
	      }

	      if (i === null) {
	        return this.getTypedRuleContexts(DirectiveLocationContext);
	      } else {
	        return this.getTypedRuleContext(DirectiveLocationContext, i);
	      }
	    });

	    _this68.parser = parser;
	    _this68.ruleIndex = GraphQLParser.RULE_directiveLocations;
	    return _this68;
	  }

	  _createClass(DirectiveLocationsContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDirectiveLocations(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDirectiveLocations(this);
	      }
	    }
	  }]);

	  return DirectiveLocationsContext;
	}(_antlr["default"].ParserRuleContext);

	var DirectiveLocationContext = /*#__PURE__*/function (_antlr4$ParserRuleCon68) {
	  _inherits(DirectiveLocationContext, _antlr4$ParserRuleCon68);

	  var _super69 = _createSuper(DirectiveLocationContext);

	  function DirectiveLocationContext(parser, parent, invokingState) {
	    var _this69;

	    _classCallCheck(this, DirectiveLocationContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this69 = _super69.call(this, parent, invokingState);
	    _this69.parser = parser;
	    _this69.ruleIndex = GraphQLParser.RULE_directiveLocation;
	    return _this69;
	  }

	  _createClass(DirectiveLocationContext, [{
	    key: "executableDirectiveLocation",
	    value: function executableDirectiveLocation() {
	      return this.getTypedRuleContext(ExecutableDirectiveLocationContext, 0);
	    }
	  }, {
	    key: "typeSystemDirectiveLocation",
	    value: function typeSystemDirectiveLocation() {
	      return this.getTypedRuleContext(TypeSystemDirectiveLocationContext, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterDirectiveLocation(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitDirectiveLocation(this);
	      }
	    }
	  }]);

	  return DirectiveLocationContext;
	}(_antlr["default"].ParserRuleContext);

	var ExecutableDirectiveLocationContext = /*#__PURE__*/function (_antlr4$ParserRuleCon69) {
	  _inherits(ExecutableDirectiveLocationContext, _antlr4$ParserRuleCon69);

	  var _super70 = _createSuper(ExecutableDirectiveLocationContext);

	  function ExecutableDirectiveLocationContext(parser, parent, invokingState) {
	    var _this70;

	    _classCallCheck(this, ExecutableDirectiveLocationContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this70 = _super70.call(this, parent, invokingState);
	    _this70.parser = parser;
	    _this70.ruleIndex = GraphQLParser.RULE_executableDirectiveLocation;
	    return _this70;
	  }

	  _createClass(ExecutableDirectiveLocationContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterExecutableDirectiveLocation(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitExecutableDirectiveLocation(this);
	      }
	    }
	  }]);

	  return ExecutableDirectiveLocationContext;
	}(_antlr["default"].ParserRuleContext);

	var TypeSystemDirectiveLocationContext = /*#__PURE__*/function (_antlr4$ParserRuleCon70) {
	  _inherits(TypeSystemDirectiveLocationContext, _antlr4$ParserRuleCon70);

	  var _super71 = _createSuper(TypeSystemDirectiveLocationContext);

	  function TypeSystemDirectiveLocationContext(parser, parent, invokingState) {
	    var _this71;

	    _classCallCheck(this, TypeSystemDirectiveLocationContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this71 = _super71.call(this, parent, invokingState);
	    _this71.parser = parser;
	    _this71.ruleIndex = GraphQLParser.RULE_typeSystemDirectiveLocation;
	    return _this71;
	  }

	  _createClass(TypeSystemDirectiveLocationContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterTypeSystemDirectiveLocation(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitTypeSystemDirectiveLocation(this);
	      }
	    }
	  }]);

	  return TypeSystemDirectiveLocationContext;
	}(_antlr["default"].ParserRuleContext);

	var NameContext = /*#__PURE__*/function (_antlr4$ParserRuleCon71) {
	  _inherits(NameContext, _antlr4$ParserRuleCon71);

	  var _super72 = _createSuper(NameContext);

	  function NameContext(parser, parent, invokingState) {
	    var _this72;

	    _classCallCheck(this, NameContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this72 = _super72.call(this, parent, invokingState);
	    _this72.parser = parser;
	    _this72.ruleIndex = GraphQLParser.RULE_name;
	    return _this72;
	  }

	  _createClass(NameContext, [{
	    key: "keyword",
	    value: function keyword() {
	      return this.getTypedRuleContext(KeywordContext, 0);
	    }
	  }, {
	    key: "NAME",
	    value: function NAME() {
	      return this.getToken(GraphQLParser.NAME, 0);
	    }
	  }, {
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterName(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitName(this);
	      }
	    }
	  }]);

	  return NameContext;
	}(_antlr["default"].ParserRuleContext);

	var KeywordContext = /*#__PURE__*/function (_antlr4$ParserRuleCon72) {
	  _inherits(KeywordContext, _antlr4$ParserRuleCon72);

	  var _super73 = _createSuper(KeywordContext);

	  function KeywordContext(parser, parent, invokingState) {
	    var _this73;

	    _classCallCheck(this, KeywordContext);

	    if (parent === undefined) {
	      parent = null;
	    }

	    if (invokingState === undefined || invokingState === null) {
	      invokingState = -1;
	    }

	    _this73 = _super73.call(this, parent, invokingState);
	    _this73.parser = parser;
	    _this73.ruleIndex = GraphQLParser.RULE_keyword;
	    return _this73;
	  }

	  _createClass(KeywordContext, [{
	    key: "enterRule",
	    value: function enterRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.enterKeyword(this);
	      }
	    }
	  }, {
	    key: "exitRule",
	    value: function exitRule(listener) {
	      if (listener instanceof _GraphQLListener["default"]) {
	        listener.exitKeyword(this);
	      }
	    }
	  }]);

	  return KeywordContext;
	}(_antlr["default"].ParserRuleContext);

	GraphQLParser.DocumentContext = DocumentContext;
	GraphQLParser.DefinitionContext = DefinitionContext;
	GraphQLParser.ExecutableDefinitionContext = ExecutableDefinitionContext;
	GraphQLParser.OperationDefinitionContext = OperationDefinitionContext;
	GraphQLParser.OperationTypeContext = OperationTypeContext;
	GraphQLParser.SelectionSetContext = SelectionSetContext;
	GraphQLParser.SelectionContext = SelectionContext;
	GraphQLParser.FieldContext = FieldContext;
	GraphQLParser.ArgumentsContext = ArgumentsContext;
	GraphQLParser.ArgumentContext = ArgumentContext;
	GraphQLParser.AliasContext = AliasContext;
	GraphQLParser.FragmentSpreadContext = FragmentSpreadContext;
	GraphQLParser.FragmentDefinitionContext = FragmentDefinitionContext;
	GraphQLParser.FragmentNameContext = FragmentNameContext;
	GraphQLParser.TypeConditionContext = TypeConditionContext;
	GraphQLParser.InlineFragmentContext = InlineFragmentContext;
	GraphQLParser.ValueContext = ValueContext;
	GraphQLParser.IntValueContext = IntValueContext;
	GraphQLParser.FloatValueContext = FloatValueContext;
	GraphQLParser.BooleanValueContext = BooleanValueContext;
	GraphQLParser.StringValueContext = StringValueContext;
	GraphQLParser.NullValueContext = NullValueContext;
	GraphQLParser.EnumValueContext = EnumValueContext;
	GraphQLParser.ListValueContext = ListValueContext;
	GraphQLParser.ObjectValueContext = ObjectValueContext;
	GraphQLParser.ObjectFieldContext = ObjectFieldContext;
	GraphQLParser.VariableContext = VariableContext;
	GraphQLParser.VariableDefinitionsContext = VariableDefinitionsContext;
	GraphQLParser.VariableDefinitionContext = VariableDefinitionContext;
	GraphQLParser.DefaultValueContext = DefaultValueContext;
	GraphQLParser.Type_Context = Type_Context;
	GraphQLParser.NamedTypeContext = NamedTypeContext;
	GraphQLParser.ListTypeContext = ListTypeContext;
	GraphQLParser.DirectivesContext = DirectivesContext;
	GraphQLParser.DirectiveContext = DirectiveContext;
	GraphQLParser.TypeSystemDefinitionContext = TypeSystemDefinitionContext;
	GraphQLParser.TypeSystemExtensionContext = TypeSystemExtensionContext;
	GraphQLParser.SchemaDefinitionContext = SchemaDefinitionContext;
	GraphQLParser.RootOperationTypeDefinitionContext = RootOperationTypeDefinitionContext;
	GraphQLParser.SchemaExtensionContext = SchemaExtensionContext;
	GraphQLParser.OperationTypeDefinitionContext = OperationTypeDefinitionContext;
	GraphQLParser.DescriptionContext = DescriptionContext;
	GraphQLParser.TypeDefinitionContext = TypeDefinitionContext;
	GraphQLParser.TypeExtensionContext = TypeExtensionContext;
	GraphQLParser.ScalarTypeDefinitionContext = ScalarTypeDefinitionContext;
	GraphQLParser.ScalarTypeExtensionContext = ScalarTypeExtensionContext;
	GraphQLParser.ObjectTypeDefinitionContext = ObjectTypeDefinitionContext;
	GraphQLParser.ImplementsInterfacesContext = ImplementsInterfacesContext;
	GraphQLParser.FieldsDefinitionContext = FieldsDefinitionContext;
	GraphQLParser.FieldDefinitionContext = FieldDefinitionContext;
	GraphQLParser.ArgumentsDefinitionContext = ArgumentsDefinitionContext;
	GraphQLParser.InputValueDefinitionContext = InputValueDefinitionContext;
	GraphQLParser.ObjectTypeExtensionContext = ObjectTypeExtensionContext;
	GraphQLParser.InterfaceTypeDefinitionContext = InterfaceTypeDefinitionContext;
	GraphQLParser.InterfaceTypeExtensionContext = InterfaceTypeExtensionContext;
	GraphQLParser.UnionTypeDefinitionContext = UnionTypeDefinitionContext;
	GraphQLParser.UnionMemberTypesContext = UnionMemberTypesContext;
	GraphQLParser.UnionTypeExtensionContext = UnionTypeExtensionContext;
	GraphQLParser.EnumTypeDefinitionContext = EnumTypeDefinitionContext;
	GraphQLParser.EnumValuesDefinitionContext = EnumValuesDefinitionContext;
	GraphQLParser.EnumValueDefinitionContext = EnumValueDefinitionContext;
	GraphQLParser.EnumTypeExtensionContext = EnumTypeExtensionContext;
	GraphQLParser.InputObjectTypeDefinitionContext = InputObjectTypeDefinitionContext;
	GraphQLParser.InputFieldsDefinitionContext = InputFieldsDefinitionContext;
	GraphQLParser.InputObjectTypeExtensionContext = InputObjectTypeExtensionContext;
	GraphQLParser.DirectiveDefinitionContext = DirectiveDefinitionContext;
	GraphQLParser.DirectiveLocationsContext = DirectiveLocationsContext;
	GraphQLParser.DirectiveLocationContext = DirectiveLocationContext;
	GraphQLParser.ExecutableDirectiveLocationContext = ExecutableDirectiveLocationContext;
	GraphQLParser.TypeSystemDirectiveLocationContext = TypeSystemDirectiveLocationContext;
	GraphQLParser.NameContext = NameContext;
	GraphQLParser.KeywordContext = KeywordContext;
} (GraphQLParser));

var GraphqlParser = /*@__PURE__*/getDefaultExportFromCjs(GraphQLParser);

class GraphqlASTBuilderCB$1 extends GraphqlListener {

    visitTerminal(node) {
        this.cb.visitTerminal(node, this.parser);
    }

    visitErrorNode(node) {
        this.cb.visitErrorNode(node, this.parser);
    }

    enterEveryRule(node) {
        this.cb.enterEveryRule(node, this.parser);
    }

    exitEveryRule(node) {
        this.cb.exitEveryRule();
    }

    run(input, cb, errorListener) {
        this.cb = cb;
        const chars = new antlr4.InputStream(input);
        const lexer = new GraphqlLexer(chars);
        lexer.removeErrorListeners();
        lexer.addErrorListener(errorListener);
        const tokens = new antlr4.CommonTokenStream(lexer);
        const parser = new GraphqlParser(tokens);
        parser.removeErrorListeners();
        parser.addErrorListener(errorListener);
        this.parser = parser;
        this.parser.buildParseTrees = true;
        const tree = this.parser.document();
        antlr4.tree.ParseTreeWalker.DEFAULT.walk(this, tree);
    }
}

var graphqlcb_m = /*#__PURE__*/Object.freeze({
	__proto__: null,
	GraphqlASTBuilderCB: GraphqlASTBuilderCB$1
});

var require$$2 = /*@__PURE__*/getAugmentedNamespace(graphqlcb_m);

const { Protobuf3ASTBuilderCB } = require$$0;
const { GraphqlFederationASTBuilderCB } = require$$1;
const { GraphqlASTBuilderCB } = require$$2;

var internal = {
    Protobuf3ASTBuilderCB: Protobuf3ASTBuilderCB,
    GraphqlFederationASTBuilderCB: GraphqlFederationASTBuilderCB,
    GraphqlASTBuilderCB: GraphqlASTBuilderCB
};

module.exports = internal;
